type ChainInfo @entity {
  id: ID!
  specVersion: Int!
  transactionVersion: Int!
  genesisHash: String!
  blockHash: String!
  blockNumber: Int! @index
  existentialDeposit: BigInt!
  timestamp: DateTime!
  marketplace: Marketplace
}

type Marketplace {
  protocolFee: Float!
  fixedPriceListingCount: Int!
  auctionListingCount: Int!
  listingActiveDelay: Int!
  listingDeposit: BigInt!
  maxRoundingError: BigInt!
  maxSaltLength: Int!
  minimumBidIncreasePercentage: Float!
}

type Fee {
  amount: BigInt
  who: Account
}

type Extrinsic @entity {
  id: ID!
  extrinsicIndex: String!
  extrinsicHash: String!
  blockNumber: Int!
  blockHash: String!
  success: Boolean!
  pallet: String!
  method: String!
  args: JSON
  signature: JSON!
  signer: Account!
  nonce: Int!
  tip: BigInt
  fee: Fee
  error: String
  createdAt: DateTime!

  events: [Event] @derivedFrom(field: "extrinsic")
}

type Event @entity {
  id: ID!

  extrinsic: Extrinsic!
  collection: Collection
  token: Token

  data: EventData
}

union EventData = MultiTokensApproved | MultiTokensAttributeRemoved | MultiTokensAttributeSet | MultiTokensBurned
  | MultiTokensCollectionAccountCreated | MultiTokensCollectionAccountDestroyed | MultiTokensCollectionCreated
  | MultiTokensCollectionDestroyed | MultiTokensCollectionMutated | MultiTokensFrozen | MultiTokensMinted
  | MultiTokensThawed | MultiTokensTokenAccountCreated | MultiTokensTokenAccountDestroyed | MultiTokensTokenCreated
  | MultiTokensTokenDestroyed | MultiTokensTokenMutated | MultiTokensTransferred | MultiTokensUnapproved
  | MarketplaceAuctionFinalized | MarketplaceBidPlaced | MarketplaceListingCancelled | MarketplaceListingCreated
  | MarketplaceListingFilled | BalancesTransfer

type BalancesTransfer {
  from: Account!
  to: Account!
  amount: BigInt
}

type MarketplaceAuctionFinalized {
  listing: Listing!
  winningBid: Bid
  protocolFee: Float!
  royalty: BigInt!
}

type MarketplaceBidPlaced {
  listing: Listing!
  bid: Bid!
}

type MarketplaceListingCancelled {
  listing: Listing!
}

type MarketplaceListingCreated {
  listing: Listing!
}

type MarketplaceListingFilled {
  listing: Listing!
  buyer: Account!
  amountFilled: BigInt!
  amountRemaining: BigInt!
  protocolFee: Float!
  royalty: BigInt!
}

type MultiTokensApproved {
  collectionId: BigInt!
  tokenId: BigInt
  owner: Account!
  operator: Account!
  amount: BigInt
  expiration: BigInt
}

type MultiTokensAttributeRemoved {
  collectionId: BigInt!
  tokenId: BigInt
  key: String!
}

type MultiTokensAttributeSet {
  collectionId: BigInt!
  tokenId: BigInt
  key: String!
  value: String!
}

type MultiTokensBurned {
  collectionId: BigInt!
  tokenId: BigInt!
  account: Account!
  amount: BigInt!
}

type MultiTokensCollectionAccountCreated {
  collectionId: BigInt!
  account: Account!
}

type MultiTokensCollectionAccountDestroyed {
  collectionId: BigInt!
  account: Account!
}

type MultiTokensCollectionCreated {
  collectionId: BigInt!
  owner: Account!
}

type MultiTokensCollectionDestroyed {
  collectionId: BigInt!
  called: Account!
}

type MultiTokensCollectionMutated {
  extrinsic: Extrinsic!
}

type MultiTokensFrozen {
  extrinsic: Extrinsic!
}

type MultiTokensMinted {
  collectionId: BigInt!
  tokenId: BigInt!
  issuer: Account!
  recipient: Account!
  amount: BigInt!
}

type MultiTokensThawed {
  extrinsic: Extrinsic!
}

type MultiTokensTokenAccountCreated {
  collectionId: BigInt!
  tokenId: BigInt!
  account: Account!
  balance: BigInt!
}

type MultiTokensTokenAccountDestroyed {
  collectionId: BigInt!
  tokenId: BigInt!
  accountId: Account!
}

type MultiTokensTokenCreated {
  collectionId: BigInt!
  tokenId: BigInt!
  issuer: Account!
  initialSupply: BigInt!
}

type MultiTokensTokenDestroyed {
  collectionId: BigInt!
  tokenId: BigInt!
  caller: Account!
}

type MultiTokensTokenMutated {
  extrinsic: Extrinsic!
}

type MultiTokensTransferred {
  collectionId: BigInt!
  tokenId: BigInt!
  operator: Account!
  from: Account!
  to: Account!
  amount: BigInt!
}

type MultiTokensUnapproved {
  collectionId: BigInt!
  tokenId: BigInt
  owner: Account!
  operator: Account!
}

type Balance {
  free: BigInt!
  reserved: BigInt!
  miscFrozen: BigInt!
  feeFrozen: BigInt!
}

type Account @entity {
  id: ID!

  # Storage defaults
  nonce: Int!
  balance: Balance

  # Relations
  extrinsics: [Extrinsic] @derivedFrom(field: "signer")
  collectionsOwned: [Collection] @derivedFrom(field: "owner")
  collectionAccounts: [CollectionAccount] @derivedFrom(field: "account")
  tokenAccounts: [TokenAccount] @derivedFrom(field: "account")

  # Extras
  lastUpdateBlock: Int!
}

type MintPolicy {
  maxTokenCount: BigInt
  maxTokenSupply: BigInt
  forceSingleMint: Boolean!
}

type TransferPolicy {
  isFrozen: Boolean
}

type MarketPolicy {
  royalty: Royalty!
}

type RoyaltyCurrency @entity {
  id: ID!

  collection: Collection!
  token: Token!
}

type CollectionStats {
    floorPrice: BigInt
    lastSale: BigInt
    highestSale: BigInt
    tokenCount: Int!
    salesCount: Int!
    rank: Int!
    marketCap: BigInt!
    volume: BigInt!
}

type Collection @entity {
  id: ID!

  # Storage defaults
  owner: Account!
  mintPolicy: MintPolicy!
  marketPolicy: MarketPolicy
  explicitRoyaltyCurrencies: [RoyaltyCurrency] @derivedFrom(field: "collection")
  burnPolicy: String
  transferPolicy: TransferPolicy
  attributePolicy: String
  attributeCount: Int!
  totalDeposit: BigInt!

  # Relations
  tokens: [Token] @derivedFrom(field: "collection")
  collectionAccounts: [CollectionAccount] @derivedFrom(field: "collection")
  tokenAccounts: [TokenAccount] @derivedFrom(field: "collection")
  attributes: [Attribute] @derivedFrom(field: "collection")

  # Extras
  metadata: Metadata
  createdAt: DateTime!

  # Marketplace analytics
  stats: CollectionStats!
}

type CollectionApproval {
  account: String!
  expiration: Int
}

type CollectionAccount @entity {
  id: ID!

  # Storage defaults
  isFrozen: Boolean!
  approvals: [CollectionApproval!]
  accountCount: Int!

  # Relations
  account: Account!
  collection: Collection!

  # Extras
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum CapType {
  SingleMint
  Supply
}

union TokenCap = TokenCapSingleMint | TokenCapSupply

type TokenCapSingleMint {
  type: CapType!
}

type TokenCapSupply {
  type: CapType!
  supply: BigInt!
}

enum TokenBehaviorType {
  HasRoyalty
  IsCurrency
}

union TokenBehavior = TokenBehaviorHasRoyalty | TokenBehaviorIsCurrency

type Royalty {
  beneficiary: Account!
  percentage: Float!
}

type TokenBehaviorHasRoyalty {
  type: TokenBehaviorType!
  royalty: Royalty!
}

type TokenBehaviorIsCurrency {
  type: TokenBehaviorType!
}

type Token @entity {
  id: ID!

  # Extrinsic defaults
  tokenId: BigInt!
  supply: BigInt!
  isFrozen: Boolean!
  cap: TokenCap
  behavior: TokenBehavior
  listingForbidden: Boolean!
  unitPrice: BigInt!

  # Storage extras
  minimumBalance: BigInt!
  mintDeposit: BigInt!
  attributeCount: Int!

  # Relations
  collection: Collection!
  tokenAccounts: [TokenAccount] @derivedFrom(field: "token")
  attributes: [Attribute] @derivedFrom(field: "token")
  listings: [Listing] @derivedFrom(field: "makeAssetId")
  offers: [Listing] @derivedFrom(field: "takeAssetId")
  events: [Event] @derivedFrom(field: "token")

  # Extras
  nonFungible: Boolean
  metadata: Metadata
  createdAt: DateTime!
}

type TokenApproval {
  account: String!
  amount: BigInt!
  expiration: Int
}

type TokenNamedReserve {
  pallet: String!
  amount: BigInt!
}

type TokenLock {
  pallet: String!
  amount: BigInt!
}

type TokenAccount @entity {
  id: ID!

  # Storage defaults
  balance: BigInt!
  reservedBalance: BigInt!
  lockedBalance: BigInt!
  namedReserves: [TokenNamedReserve!]
  locks: [TokenLock!]
  approvals: [TokenApproval!]
  isFrozen: Boolean!

  # Relations
  account: Account!
  collection: Collection!
  token: Token!

  # Extras
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MetadataMeta {
  version: Float!
  language: String
  sensitiveContent: String
}

type MetadataMedia {
  url: String!
  alt: String
  type: String
}

type Metadata {
  name: String
  description: String
  externalUrl: String
  keywords: [String]
  fallbackImage: String
  media: [MetadataMedia]
  meta: MetadataMeta
  attributes: JSON
}

type Attribute @entity {
  id: ID!

  # Storage defaults
  key: String!
  value: String!
  deposit: BigInt!

  # Relations
  collection: Collection!
  token: Token

  # Extras
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum FeeSide {
  NoFee
  Make
  Take
}

enum ListingType {
  FixedPrice
  Auction
}

type FixedPriceData {
  listingType: ListingType!
}

type AuctionData {
  listingType: ListingType!
  startHeight: Int!
  endHeight: Int!
}

union ListingData = FixedPriceData | AuctionData

type FixedPriceState {
  listingType: ListingType!
  amountFilled: BigInt!
}

type AuctionState {
  listingType: ListingType!
  highBid: Bid
}

type Bid @entity {
  id: ID!

  # Storage defaults
  bidder: Account!
  price: BigInt!

  # Extras
  listing: Listing!
  height: Int!

  createdAt: DateTime!
}

union ListingState = FixedPriceState | AuctionState

enum ListingStatusType {
  Active
  Cancelled
  Finalized
}

type ListingStatus @entity {
    id: ID!
    type: ListingStatusType!
    listing: Listing!
    height: Int!
    createdAt: DateTime!
}

type Listing @entity {
  id: ID!

  # Storage defaults
  seller: Account!
  makeAssetId: Token!
  takeAssetId: Token!
  amount: BigInt!
  price: BigInt!
  minTakeValue: BigInt!
  feeSide: FeeSide!
  height: Int!
  deposit: BigInt!
  salt: String!
  data: ListingData!
  state: ListingState!

  # Relations
  bids: [Bid] @derivedFrom(field: "listing")
  status: [ListingStatus] @derivedFrom(field: "listing")

  # Extras
  highestPrice: BigInt!

  createdAt: DateTime!
  updatedAt: DateTime!
}