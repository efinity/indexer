type ChainInfo @entity {
  id: ID!
  specVersion: Int!
  transactionVersion: Int!
  genesisHash: String!
  blockHash: String!
  blockNumber: Int! @index
  existentialDeposit: BigInt!
  timestamp: DateTime!
}

type Account @entity {
  id: ID!

  collectionsOwned: [Collection] @derivedFrom(field: "owner")
  collectionAccounts: [CollectionAccount] @derivedFrom(field: "account")
  tokenAccounts: [TokenAccount] @derivedFrom(field: "account")

  lastUpdateBlock: Int!
}

type MintPolicy {
  maxTokenCount: BigInt
  maxTokenSupply: BigInt
  forceSingleMint: Boolean!
}

type TransferPolicy {
  isFrozen: Boolean
}

type Collection @entity {
  id: ID!

  # Storage defaults
  owner: Account!
  mintPolicy: MintPolicy!
  burnPolicy: String
  transferPolicy: TransferPolicy
  attributePolicy: String
  tokenCount: Int!
  attributeCount: Int!
  totalDeposit: BigInt!

  # Relations
  tokens: [Token] @derivedFrom(field: "collection")
  collectionAccounts: [CollectionAccount] @derivedFrom(field: "collection")
  tokenAccounts: [TokenAccount] @derivedFrom(field: "collection")
  attributes: [Attribute] @derivedFrom(field: "collection")

  # Extras
  name: String
  createdAt: DateTime!
}

type CollectionApproval {
  account: String!
  expiration: Int
}

type CollectionAccount @entity {
  id: ID!

  # Storage defaults
  isFrozen: Boolean!
  approvals: [CollectionApproval!]
  accountCount: Int!

  # Relations
  account: Account!
  collection: Collection!

  # Extras
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum CapType {
  SingleMint
  Supply
}

type Token @entity {
  id: ID!

  # Storage defaults
  tokenId: BigInt!
  supply: BigInt!
  capType: CapType
  capSupply: BigInt
  isFrozen: Boolean!
  minimumBalance: BigInt!
  unitPrice: BigInt!
  mintDeposit: BigInt!
  attributeCount: Int!

  # Relations
  collection: Collection!
  tokenAccounts: [TokenAccount] @derivedFrom(field: "token")
  attributes: [Attribute] @derivedFrom(field: "token")

  # Extras
  name: String
  createdAt: DateTime!
}

type TokenApproval {
  account: String!
  amount: BigInt!
  expiration: Int
}

type TokenNamedReserve {
  pallet: String!
  amount: BigInt!
}

type TokenLock {
  pallet: String!
  amount: BigInt!
}

type TokenAccount @entity {
  id: ID!

  # Storage defaults
  balance: BigInt!
  reservedBalance: BigInt!
  lockedBalance: BigInt!
  namedReserves: [TokenNamedReserve!]
  locks: [TokenLock!]
  approvals: [TokenApproval!]
  isFrozen: Boolean!

  # Relations
  account: Account!
  collection: Collection!
  token: Token!

  # Extras
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Attribute @entity {
  id: ID!

  # Storage defaults
  key: String!
  value: String!
  deposit: BigInt!

  # Relations
  collection: Collection!
  token: Token

  # Extras
  createdAt: DateTime!
  updatedAt: DateTime!
}