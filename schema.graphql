type ChainInfo @entity {
  id: ID!
  specVersion: Int!
  transactionVersion: Int!
  genesisHash: String!
  blockHash: String!
  blockNumber: Int! @index
  existentialDeposit: BigInt!
  timestamp: DateTime!
  marketplace: Marketplace
}

type Marketplace {
  protocolFee: Float!
  fixedPriceListingCount: Int!
  auctionListingCount: Int!
}

interface Action {
  timestamp: DateTime
  blockNumber: Int
  extrinsicHash: String
}

interface CanFail {
  success: Boolean
}

enum TransferDirection {
  From
  To
}

type Fee @entity {
  id: ID!
  amount: BigInt
  who: Account!
}

type Transfer implements Action & CanFail @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String! @index
  to: TransferLocationAccount
  from: TransferLocationAccount!
  asset: TransferAsset!
  fee: Fee
  tip: BigInt
  error: String
  success: Boolean! @index
  type: TransferType!
}

type TransferLocationAccount {
  id: String!
}

union TransferAsset = TransferAssetToken | TransferAssetMultiToken

enum TransferType {
  Native
}

type TransferAssetToken {
  symbol: String
  amount: BigInt
}

type TransferAssetMultiToken {
  tokens: [TransferAssetToken]
}

# entity for linking account and transfer
type AccountTransfer @entity {
  id: ID!
  transfer: Transfer
  account: Account!
  direction: TransferDirection
}

type Account @entity {
  id: ID!

  transfers: [AccountTransfer!] @derivedFrom(field: "account")

  collectionsOwned: [Collection] @derivedFrom(field: "owner")
  collectionAccounts: [CollectionAccount] @derivedFrom(field: "account")
  tokenAccounts: [TokenAccount] @derivedFrom(field: "account")

  lastUpdateBlock: Int!
}

type MintPolicy {
  maxTokenCount: BigInt
  maxTokenSupply: BigInt
  forceSingleMint: Boolean!
}

type TransferPolicy {
  isFrozen: Boolean
}

type MarketPolicy {
  royalty: Royalty!
}

type RoyaltyCurrency @entity {
  id: ID!

  collection: Collection!
  token: Token!
}

type Collection @entity {
  id: ID!

  # Storage defaults
  owner: Account!
  mintPolicy: MintPolicy!
  marketPolicy: MarketPolicy
  explicitRoyaltyCurrencies: [RoyaltyCurrency] @derivedFrom(field: "collection")
  burnPolicy: String
  transferPolicy: TransferPolicy
  attributePolicy: String
  tokenCount: Int!
  attributeCount: Int!
  totalDeposit: BigInt!

  # Relations
  tokens: [Token] @derivedFrom(field: "collection")
  collectionAccounts: [CollectionAccount] @derivedFrom(field: "collection")
  tokenAccounts: [TokenAccount] @derivedFrom(field: "collection")
  attributes: [Attribute] @derivedFrom(field: "collection")

  # Extras
  metadata: Metadata
  createdAt: DateTime!

  # Marketplace analytics
  floorListing: Listing
  lastSale: Listing
  highestSale: Listing
}

type CollectionApproval {
  account: String!
  expiration: Int
}

type CollectionAccount @entity {
  id: ID!

  # Storage defaults
  isFrozen: Boolean!
  approvals: [CollectionApproval!]
  accountCount: Int!

  # Relations
  account: Account!
  collection: Collection!

  # Extras
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum CapType {
  SingleMint
  Supply
}

union TokenCap = TokenCapSingleMint | TokenCapSupply

type TokenCapSingleMint {
  type: CapType!
}

type TokenCapSupply {
  type: CapType!
  supply: BigInt!
}

enum TokenBehaviorType {
  HasRoyalty
  IsCurrency
}

union TokenBehavior = TokenBehaviorHasRoyalty | TokenBehaviorIsCurrency

type Royalty {
  beneficiary: Account!
  percentage: Float!
}

type TokenBehaviorHasRoyalty {
  type: TokenBehaviorType!
  royalty: Royalty!
}

type TokenBehaviorIsCurrency {
  type: TokenBehaviorType!
}

type Token @entity {
  id: ID!

  # Extrinsic defaults
  tokenId: BigInt!
  supply: BigInt!
  isFrozen: Boolean!
  cap: TokenCap
  behavior: TokenBehavior
  listingForbidden: Boolean!
  unitPrice: BigInt!

  # Storage extras
  minimumBalance: BigInt!
  mintDeposit: BigInt!
  attributeCount: Int!

  # Relations
  collection: Collection!
  tokenAccounts: [TokenAccount] @derivedFrom(field: "token")
  attributes: [Attribute] @derivedFrom(field: "token")
  listings: [Listing] @derivedFrom(field: "makeAssetId")
  offers: [Listing] @derivedFrom(field: "takeAssetId")
  events: [TokenEvent] @derivedFrom(field: "token")

  # Extras
  metadata: Metadata
  createdAt: DateTime!
}

type TokenApproval {
  account: String!
  amount: BigInt!
  expiration: Int
}

type TokenNamedReserve {
  pallet: String!
  amount: BigInt!
}

type TokenLock {
  pallet: String!
  amount: BigInt!
}

type TokenAccount @entity {
  id: ID!

  # Storage defaults
  balance: BigInt!
  reservedBalance: BigInt!
  lockedBalance: BigInt!
  namedReserves: [TokenNamedReserve!]
  locks: [TokenLock!]
  approvals: [TokenApproval!]
  isFrozen: Boolean!

  # Relations
  account: Account!
  collection: Collection!
  token: Token!

  # Extras
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MetadataMeta {
  version: Float!
  language: String
  sensitiveContent: String
}

type MetadataMedia {
  url: String!
  alt: String
  type: String
}

type Metadata {
  name: String
  description: String
  externalUrl: String
  keywords: [String]
  fallbackImage: String
  media: [MetadataMedia]
  meta: MetadataMeta
  attributes: JSON
}

type Attribute @entity {
  id: ID!

  # Storage defaults
  key: String!
  value: String!
  deposit: BigInt!

  # Relations
  collection: Collection!
  token: Token

  # Extras
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum FeeSide {
  NoFee
  Make
  Take
}

enum ListingType {
  FixedPrice
  Auction
}

type FixedPriceData {
  listingType: ListingType!
}

type AuctionData {
  listingType: ListingType!
  startHeight: Int!
  endHeight: Int!
}

union ListingData = FixedPriceData | AuctionData

type FixedPriceState {
  listingType: ListingType!
  amountFilled: BigInt!
}

type AuctionState {
  listingType: ListingType!
  highBid: Bid
}

type Bid @entity {
  id: ID!

  # Storage defaults
  bidder: Account!
  price: BigInt!

  # Extras
  listing: Listing!
  height: Int!

  createdAt: DateTime!
}

union ListingState = FixedPriceState | AuctionState

enum ListingStatusType {
  Active
  Cancelled
  Finalized
}

type ListingStatus @entity {
    id: ID!
    type: ListingStatusType!
    listing: Listing!
    height: Int!
    createdAt: DateTime!
}

type Listing @entity {
  id: ID!

  # Storage defaults
  seller: Account!
  makeAssetId: Token!
  takeAssetId: Token!
  amount: BigInt!
  price: BigInt!
  minTakeValue: BigInt!
  feeSide: FeeSide!
  height: Int!
  deposit: BigInt!
  salt: String!
  data: ListingData!
  state: ListingState!

  # Relations
  bids: [Bid] @derivedFrom(field: "listing")
  status: [ListingStatus] @derivedFrom(field: "listing")

  # Extras
  highestPrice: BigInt!

  createdAt: DateTime!
  updatedAt: DateTime!
}



""" asset events, added Event as suffix to prevent name collision """

type  MarketplaceListEvent {
  from: Account! # this field makes it easier to query user activities
  listing: Listing!
}

type MarketplacePurchaseEvent {
  from: Account!
  to:  Account!
  amount: BigInt!
  listing: Listing!
}

type MarketplaceListingCancelEvent {
  from: Account!
  listing: Listing!
}

type MarketplaceBidEvent {
  from: Account!
  bid: Bid!
}

type TransferEvent {
  from: Account!
  to:  Account!
}

type BurnEvent {
  from: Account!
  amount: BigInt!
}

union TokenEventType = MarketplaceListEvent | MarketplacePurchaseEvent | MarketplaceListingCancelEvent | MarketplaceBidEvent | TransferEvent | BurnEvent

type TokenEvent @entity {
  id: ID!

  event: TokenEventType!
  token: Token!
  height: Int!

  createdAt: DateTime!
}
