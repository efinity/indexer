import assert from 'assert'
import {Chain, ChainContext, CallContext, Call, Result, Option} from './support'
import * as v100 from './v100'
import * as matrixEnjinV603 from './matrixEnjinV603'
import * as v101 from './v101'
import * as v102 from './v102'
import * as v103 from './v103'
import * as matrixEnjinV1000 from './matrixEnjinV1000'
import * as matrixEnjinV1003 from './matrixEnjinV1003'
import * as v104 from './v104'
import * as v105 from './v105'
import * as v106 from './v106'
import * as v110 from './v110'
import * as v120 from './v120'
import * as v1021 from './v1021'
import * as v1022 from './v1022'
import * as v1023 from './v1023'

export class AssignedSlotsAssignPermParachainSlotCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssignedSlots.assign_perm_parachain_slot')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Assign a permanent parachain slot and immediately create a lease for it.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('AssignedSlots.assign_perm_parachain_slot') === '0fb20b5afc6a2830162f8daea8abc92a50d6411d977d5e83e205bdeb2dcd6598'
    }

    /**
     * Assign a permanent parachain slot and immediately create a lease for it.
     */
    get asV100(): {id: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class AssignedSlotsAssignTempParachainSlotCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssignedSlots.assign_temp_parachain_slot')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Assign a temporary parachain slot. The function tries to create a lease for it
     * immediately if `SlotLeasePeriodStart::Current` is specified, and if the number
     * of currently active temporary slots is below `MaxTemporarySlotPerLeasePeriod`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('AssignedSlots.assign_temp_parachain_slot') === '5b9a8d8ada8f003c5e19777e0e5305a363e6405ca8fca5f42ad9638e0b01552a'
    }

    /**
     * Assign a temporary parachain slot. The function tries to create a lease for it
     * immediately if `SlotLeasePeriodStart::Current` is specified, and if the number
     * of currently active temporary slots is below `MaxTemporarySlotPerLeasePeriod`.
     */
    get asV100(): {id: number, leasePeriodStart: v100.SlotLeasePeriodStart} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class AssignedSlotsUnassignParachainSlotCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssignedSlots.unassign_parachain_slot')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unassign a permanent or temporary parachain slot
     */
    get isV100(): boolean {
        return this._chain.getCallHash('AssignedSlots.unassign_parachain_slot') === '0fb20b5afc6a2830162f8daea8abc92a50d6411d977d5e83e205bdeb2dcd6598'
    }

    /**
     * Unassign a permanent or temporary parachain slot
     */
    get asV100(): {id: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class AuctionsBidCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Auctions.bid')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Make a new bid from an account (including a parachain account) for deploying a new
     * parachain.
     * 
     * Multiple simultaneous bids from the same bidder are allowed only as long as all active
     * bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
     * 
     * - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
     * funded by) the same account.
     * - `auction_index` is the index of the auction to bid on. Should just be the present
     * value of `AuctionCounter`.
     * - `first_slot` is the first lease period index of the range to bid on. This is the
     * absolute lease period index value, not an auction-specific offset.
     * - `last_slot` is the last lease period index of the range to bid on. This is the
     * absolute lease period index value, not an auction-specific offset.
     * - `amount` is the amount to bid to be held as deposit for the parachain should the
     * bid win. This amount is held throughout the range.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Auctions.bid') === '875d3f461aae7e3ba782bc8174e50928c136bb1285ec107fb43dee7de4f50f54'
    }

    /**
     * Make a new bid from an account (including a parachain account) for deploying a new
     * parachain.
     * 
     * Multiple simultaneous bids from the same bidder are allowed only as long as all active
     * bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
     * 
     * - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
     * funded by) the same account.
     * - `auction_index` is the index of the auction to bid on. Should just be the present
     * value of `AuctionCounter`.
     * - `first_slot` is the first lease period index of the range to bid on. This is the
     * absolute lease period index value, not an auction-specific offset.
     * - `last_slot` is the last lease period index of the range to bid on. This is the
     * absolute lease period index value, not an auction-specific offset.
     * - `amount` is the amount to bid to be held as deposit for the parachain should the
     * bid win. This amount is held throughout the range.
     */
    get asV100(): {para: number, auctionIndex: number, firstSlot: number, lastSlot: number, amount: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class AuctionsCancelAuctionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Auctions.cancel_auction')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel an in-progress auction.
     * 
     * Can only be called by Root origin.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Auctions.cancel_auction') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Cancel an in-progress auction.
     * 
     * Can only be called by Root origin.
     */
    get asV100(): null {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class AuctionsNewAuctionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Auctions.new_auction')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a new auction.
     * 
     * This can only happen when there isn't already an auction in progress and may only be
     * called by the root origin. Accepts the `duration` of this auction and the
     * `lease_period_index` of the initial lease period of the four that are to be auctioned.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Auctions.new_auction') === 'f9c6104e2d8ee4a5650bf6b22307030d44c7c7014eb5b79c3fdc26e37431996c'
    }

    /**
     * Create a new auction.
     * 
     * This can only happen when there isn't already an auction in progress and may only be
     * called by the root origin. Accepts the `duration` of this auction and the
     * `lease_period_index` of the initial lease period of the four that are to be auctioned.
     */
    get asV100(): {duration: number, leasePeriodIndex: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class BabePlanConfigChangeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Babe.plan_config_change')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Plan an epoch config change. The epoch config change is recorded and will be enacted on
     * the next call to `enact_epoch_change`. The config will be activated one epoch after.
     * Multiple calls to this method will replace any existing planned config change that had
     * not been enacted yet.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Babe.plan_config_change') === '445d07b89db2246e1bb7a27672210d26caa40906751dc15e2e91036d19c646c3'
    }

    /**
     * Plan an epoch config change. The epoch config change is recorded and will be enacted on
     * the next call to `enact_epoch_change`. The config will be activated one epoch after.
     * Multiple calls to this method will replace any existing planned config change that had
     * not been enacted yet.
     */
    get asV100(): {config: v100.NextConfigDescriptor} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class BabeReportEquivocationCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Babe.report_equivocation')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Babe.report_equivocation') === '40d799eb32ff6f2d8c0e11e555d627ab95ad001691371ef039423f40d5d53b2b'
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     */
    get asV100(): {equivocationProof: v100.EquivocationProof, keyOwnerProof: v100.MembershipProof} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class BabeReportEquivocationUnsignedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Babe.report_equivocation_unsigned')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Babe.report_equivocation_unsigned') === '40d799eb32ff6f2d8c0e11e555d627ab95ad001691371ef039423f40d5d53b2b'
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get asV100(): {equivocationProof: v100.EquivocationProof, keyOwnerProof: v100.MembershipProof} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesForceSetBalanceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.force_set_balance')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the regular balance of a given account.
     * 
     * The dispatch origin for this call is `root`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Balances.force_set_balance') === 'd0f1dc28aeba8805f92a7e983d0fba2621912dc1665264dd9c38cd3c0c912737'
    }

    /**
     * Set the regular balance of a given account.
     * 
     * The dispatch origin for this call is `root`.
     */
    get asMatrixEnjinV603(): {who: matrixEnjinV603.MultiAddress, newFree: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesForceTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.force_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Balances.force_transfer') === 'e5944fbe8224a17fe49f9c1d1d01efaf87fb1778fd39618512af54c9ba6f9dff'
    }

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     */
    get asMatrixEnjinV603(): {source: matrixEnjinV603.MultiAddress, dest: matrixEnjinV603.MultiAddress, value: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesForceUnreserveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.force_unreserve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unreserve some balance from a user by force.
     * 
     * Can only be called by ROOT.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Balances.force_unreserve') === '30bc48977e2a7ad3fc8ac014948ded50fc54886bad9a1f65b02bb64f27d8a6be'
    }

    /**
     * Unreserve some balance from a user by force.
     * 
     * Can only be called by ROOT.
     */
    get asMatrixEnjinV603(): {who: matrixEnjinV603.MultiAddress, amount: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesSetBalanceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.set_balance')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     * also alter the total issuance of the system (`TotalIssuance`) appropriately.
     * If the new free or reserved balance is below the existential deposit,
     * it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     * The dispatch origin for this call is `root`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Balances.set_balance') === 'beb82909d38c015bc075ff8b107e47a02f8772bf5cf681d6cd84ef685e448a8f'
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     * also alter the total issuance of the system (`TotalIssuance`) appropriately.
     * If the new free or reserved balance is below the existential deposit,
     * it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     * The dispatch origin for this call is `root`.
     */
    get asV100(): {who: v100.MultiAddress, newFree: bigint, newReserved: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesSetBalanceDeprecatedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.set_balance_deprecated')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the regular balance of a given account; it also takes a reserved balance but this
     * must be the same as the account's current reserved balance.
     * 
     * The dispatch origin for this call is `root`.
     * 
     * WARNING: This call is DEPRECATED! Use `force_set_balance` instead.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Balances.set_balance_deprecated') === 'cd8eaf83a985e64a94900c5c58bbc2bbd20e03f5d571cf6065020f1a4281ff19'
    }

    /**
     * Set the regular balance of a given account; it also takes a reserved balance but this
     * must be the same as the account's current reserved balance.
     * 
     * The dispatch origin for this call is `root`.
     * 
     * WARNING: This call is DEPRECATED! Use `force_set_balance` instead.
     */
    get asMatrixEnjinV603(): {who: matrixEnjinV603.MultiAddress, newFree: bigint, oldReserved: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Alias for `transfer_allow_death`, provided only for name-wise compatibility.
     * 
     * WARNING: DEPRECATED! Will be released in approximately 3 months.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Balances.transfer') === 'fc85bea9d0d171982f66e8a55667d58dc9a1612bcafe84309942bf47e23e3094'
    }

    /**
     * Alias for `transfer_allow_death`, provided only for name-wise compatibility.
     * 
     * WARNING: DEPRECATED! Will be released in approximately 3 months.
     */
    get asMatrixEnjinV603(): {dest: matrixEnjinV603.MultiAddress, value: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesTransferAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.transfer_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer the entire transferable balance from the caller account.
     * 
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     * 
     * The dispatch origin of this call must be Signed.
     * 
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     *   of the funds the account has, causing the sender account to be killed (false), or
     *   transfer everything except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Balances.transfer_all') === '9c94c2ca9979f6551af6e123fb6b6ba14d026f862f9a023706f8f88c556b355f'
    }

    /**
     * Transfer the entire transferable balance from the caller account.
     * 
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     * 
     * The dispatch origin of this call must be Signed.
     * 
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     *   of the funds the account has, causing the sender account to be killed (false), or
     *   transfer everything except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get asMatrixEnjinV603(): {dest: matrixEnjinV603.MultiAddress, keepAlive: boolean} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesTransferAllowDeathCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.transfer_allow_death')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the transactor.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Balances.transfer_allow_death') === 'fc85bea9d0d171982f66e8a55667d58dc9a1612bcafe84309942bf47e23e3094'
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the transactor.
     */
    get asMatrixEnjinV603(): {dest: matrixEnjinV603.MultiAddress, value: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesTransferKeepAliveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.transfer_keep_alive')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     * 
     * 99% of the time you want [`transfer_allow_death`] instead.
     * 
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Balances.transfer_keep_alive') === 'fc85bea9d0d171982f66e8a55667d58dc9a1612bcafe84309942bf47e23e3094'
    }

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     * 
     * 99% of the time you want [`transfer_allow_death`] instead.
     * 
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     */
    get asMatrixEnjinV603(): {dest: matrixEnjinV603.MultiAddress, value: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesUpgradeAccountsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.upgrade_accounts')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Upgrade a specified account.
     * 
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     * 
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibililty of churn).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Balances.upgrade_accounts') === 'e074d5a93414f189b47fbb5d94c57b62cfb9e63808a3c94665eeb2cfe53be8df'
    }

    /**
     * Upgrade a specified account.
     * 
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     * 
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibililty of churn).
     */
    get asMatrixEnjinV603(): {who: Uint8Array[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BeefyReportEquivocationCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Beefy.report_equivocation')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Beefy.report_equivocation') === 'c03bafe7cb39484ad7fa83270d39839d184a4213ac79fe3be1e3db28892ff96a'
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     */
    get asV104(): {equivocationProof: v104.Type_558, keyOwnerProof: v104.MembershipProof} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }
}

export class BeefyReportEquivocationUnsignedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Beefy.report_equivocation_unsigned')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     * 
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Beefy.report_equivocation_unsigned') === 'c03bafe7cb39484ad7fa83270d39839d184a4213ac79fe3be1e3db28892ff96a'
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     * 
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get asV104(): {equivocationProof: v104.Type_558, keyOwnerProof: v104.MembershipProof} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesAcceptCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.accept_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Accept the curator role for a bounty.
     * A deposit will be reserved from curator and refund upon successful payout.
     * 
     * May only be called from the curator.
     * 
     * ## Complexity
     * - O(1).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Bounties.accept_curator') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     * Accept the curator role for a bounty.
     * A deposit will be reserved from curator and refund upon successful payout.
     * 
     * May only be called from the curator.
     * 
     * ## Complexity
     * - O(1).
     */
    get asMatrixEnjinV603(): {bountyId: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesApproveBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.approve_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Approve a bounty proposal. At a later time, the bounty will be funded and become active
     * and the original deposit will be returned.
     * 
     * May only be called from `T::SpendOrigin`.
     * 
     * ## Complexity
     * - O(1).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Bounties.approve_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     * Approve a bounty proposal. At a later time, the bounty will be funded and become active
     * and the original deposit will be returned.
     * 
     * May only be called from `T::SpendOrigin`.
     * 
     * ## Complexity
     * - O(1).
     */
    get asMatrixEnjinV603(): {bountyId: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesAwardBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.award_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
     * after a delay.
     * 
     * The dispatch origin for this call must be the curator of this bounty.
     * 
     * - `bounty_id`: Bounty ID to award.
     * - `beneficiary`: The beneficiary account whom will receive the payout.
     * 
     * ## Complexity
     * - O(1).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Bounties.award_bounty') === 'cfa73dafdcbe89b3b4e24bfc41cf4f3b1fcd9527b052ecc6549b6ac07b965606'
    }

    /**
     * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
     * after a delay.
     * 
     * The dispatch origin for this call must be the curator of this bounty.
     * 
     * - `bounty_id`: Bounty ID to award.
     * - `beneficiary`: The beneficiary account whom will receive the payout.
     * 
     * ## Complexity
     * - O(1).
     */
    get asMatrixEnjinV603(): {bountyId: number, beneficiary: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesClaimBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.claim_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Claim the payout from an awarded bounty after payout delay.
     * 
     * The dispatch origin for this call must be the beneficiary of this bounty.
     * 
     * - `bounty_id`: Bounty ID to claim.
     * 
     * ## Complexity
     * - O(1).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Bounties.claim_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     * Claim the payout from an awarded bounty after payout delay.
     * 
     * The dispatch origin for this call must be the beneficiary of this bounty.
     * 
     * - `bounty_id`: Bounty ID to claim.
     * 
     * ## Complexity
     * - O(1).
     */
    get asMatrixEnjinV603(): {bountyId: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesCloseBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.close_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel a proposed or active bounty. All the funds will be sent to treasury and
     * the curator deposit will be unreserved if possible.
     * 
     * Only `T::RejectOrigin` is able to cancel a bounty.
     * 
     * - `bounty_id`: Bounty ID to cancel.
     * 
     * ## Complexity
     * - O(1).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Bounties.close_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     * Cancel a proposed or active bounty. All the funds will be sent to treasury and
     * the curator deposit will be unreserved if possible.
     * 
     * Only `T::RejectOrigin` is able to cancel a bounty.
     * 
     * - `bounty_id`: Bounty ID to cancel.
     * 
     * ## Complexity
     * - O(1).
     */
    get asMatrixEnjinV603(): {bountyId: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesExtendBountyExpiryCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.extend_bounty_expiry')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Extend the expiry time of an active bounty.
     * 
     * The dispatch origin for this call must be the curator of this bounty.
     * 
     * - `bounty_id`: Bounty ID to extend.
     * - `remark`: additional information.
     * 
     * ## Complexity
     * - O(1).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Bounties.extend_bounty_expiry') === '710d6b76ffcee45bd9bffc1f299fa0b621450769559963379fa259c0f427f1bb'
    }

    /**
     * Extend the expiry time of an active bounty.
     * 
     * The dispatch origin for this call must be the curator of this bounty.
     * 
     * - `bounty_id`: Bounty ID to extend.
     * - `remark`: additional information.
     * 
     * ## Complexity
     * - O(1).
     */
    get asMatrixEnjinV603(): {bountyId: number, remark: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesProposeBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.propose_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Propose a new bounty.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     * or slashed when rejected.
     * 
     * - `curator`: The curator account whom will manage this bounty.
     * - `fee`: The curator fee.
     * - `value`: The total payment amount of this bounty, curator fee included.
     * - `description`: The description of this bounty.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Bounties.propose_bounty') === '6a012b4069a991972d0d3268cb20dfba3163919c325c7ebbe980b2dc15f1b1f5'
    }

    /**
     * Propose a new bounty.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     * or slashed when rejected.
     * 
     * - `curator`: The curator account whom will manage this bounty.
     * - `fee`: The curator fee.
     * - `value`: The total payment amount of this bounty, curator fee included.
     * - `description`: The description of this bounty.
     */
    get asMatrixEnjinV603(): {value: bigint, description: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesProposeCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.propose_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Assign a curator to a funded bounty.
     * 
     * May only be called from `T::SpendOrigin`.
     * 
     * ## Complexity
     * - O(1).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Bounties.propose_curator') === 'db115713847ce9db3eac62037c4aefcca595bcd9aa876776d8fba64491d881d3'
    }

    /**
     * Assign a curator to a funded bounty.
     * 
     * May only be called from `T::SpendOrigin`.
     * 
     * ## Complexity
     * - O(1).
     */
    get asMatrixEnjinV603(): {bountyId: number, curator: matrixEnjinV603.MultiAddress, fee: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesUnassignCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.unassign_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unassign curator from a bounty.
     * 
     * This function can only be called by the `RejectOrigin` a signed origin.
     * 
     * If this function is called by the `RejectOrigin`, we assume that the curator is
     * malicious or inactive. As a result, we will slash the curator when possible.
     * 
     * If the origin is the curator, we take this as a sign they are unable to do their job and
     * they willingly give up. We could slash them, but for now we allow them to recover their
     * deposit and exit without issue. (We may want to change this if it is abused.)
     * 
     * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     * anyone in the community to call out that a curator is not doing their due diligence, and
     * we should pick a new curator. In this case the curator should also be slashed.
     * 
     * ## Complexity
     * - O(1).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Bounties.unassign_curator') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     * Unassign curator from a bounty.
     * 
     * This function can only be called by the `RejectOrigin` a signed origin.
     * 
     * If this function is called by the `RejectOrigin`, we assume that the curator is
     * malicious or inactive. As a result, we will slash the curator when possible.
     * 
     * If the origin is the curator, we take this as a sign they are unable to do their job and
     * they willingly give up. We could slash them, but for now we allow them to recover their
     * deposit and exit without issue. (We may want to change this if it is abused.)
     * 
     * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     * anyone in the community to call out that a curator is not doing their due diligence, and
     * we should pick a new curator. In this case the curator should also be slashed.
     * 
     * ## Complexity
     * - O(1).
     */
    get asMatrixEnjinV603(): {bountyId: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsApproveClaimsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.approve_claims')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * It takes a list of transaction hashes and approves the claims for those transactions
     * 
     * Parameters:
     * 
     * * `origin`: OriginFor<T>
     * * `block_number`: The block number of the Latest ETH block of Approver
     * * `batch_data`: This is a vector of transaction hashes.
     * * `chain`: The chain that the transactions are from (Ethereum/Efinity Parachain).
     * 
     * Returns:
     * 
     * DispatchResult
     * </weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * And approve the pending ETH transaction
     * 
     * Total Complexity: O(N)
     * </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Claims.approve_claims') === 'bfe7af9c4d6496e02e0b9c2f94b1a9e975d6fd5be09fcbf5a33329375e20c7cf'
    }

    /**
     * It takes a list of transaction hashes and approves the claims for those transactions
     * 
     * Parameters:
     * 
     * * `origin`: OriginFor<T>
     * * `block_number`: The block number of the Latest ETH block of Approver
     * * `batch_data`: This is a vector of transaction hashes.
     * * `chain`: The chain that the transactions are from (Ethereum/Efinity Parachain).
     * 
     * Returns:
     * 
     * DispatchResult
     * </weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * And approve the pending ETH transaction
     * 
     * Total Complexity: O(N)
     * </weight>
     */
    get asV101(): {blockNumber: number, batchData: [Uint8Array, (number | undefined)][], chain: v101.Chain} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.claim')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Make a claim to collect your EFI.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)
     * 
     * and `address` matches the `dest` account.
     * 
     * Parameters:
     * - `dest`: The destination account to payout the claim.
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address` : The Ethereum address from which the message is signed.
     * 
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to validate unsigned `claim` call.
     * 
     * Total Complexity: O(1)
     * </weight>
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Claims.claim') === 'c6d14dccc555713bdf44b4d352cbee9695186c0e43c78a2f17735b65bbc25426'
    }

    /**
     * Make a claim to collect your EFI.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)
     * 
     * and `address` matches the `dest` account.
     * 
     * Parameters:
     * - `dest`: The destination account to payout the claim.
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address` : The Ethereum address from which the message is signed.
     * 
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to validate unsigned `claim` call.
     * 
     * Total Complexity: O(1)
     * </weight>
     */
    get asMatrixEnjinV603(): {dest: Uint8Array, ethereumSignature: Uint8Array, ethereumAddress: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Make a claim to collect your EFI.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)
     * 
     * and `address` matches the `dest` account.
     * 
     * Parameters:
     * - `dest`: The destination account to payout the claim.
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * 
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to validate unsigned `claim` call.
     * 
     * Total Complexity: O(1)
     * </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Claims.claim') === '46f6fbe643b51ee7e3a08e102493b6291f118e76145971a19fb90446b9af7251'
    }

    /**
     * Make a claim to collect your EFI.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)
     * 
     * and `address` matches the `dest` account.
     * 
     * Parameters:
     * - `dest`: The destination account to payout the claim.
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * 
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to validate unsigned `claim` call.
     * 
     * Total Complexity: O(1)
     * </weight>
     */
    get asV101(): {dest: Uint8Array, ethereumSignature: Uint8Array} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsClaimEarlyBirdRewardCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.claim_early_bird_reward')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `claim_early_bird_reward` is a function that lets a user to claim early bird bonus for
     * his stake. User will be able to claim bonus only if he has staked previously and its
     * been 90 days since he staked.
     * 
     * Caller must be the same as the account that has staked ENJ2.
     * 
     * Returns:
     * 
     * DispatchResult
     * Conditions:
     * - If there's no entry for the user in the `EarlyBirdRewards` mapping.
     * - If the user tries to claim early bird bonus for his stake before 90 days
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Claims.claim_early_bird_reward') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * `claim_early_bird_reward` is a function that lets a user to claim early bird bonus for
     * his stake. User will be able to claim bonus only if he has staked previously and its
     * been 90 days since he staked.
     * 
     * Caller must be the same as the account that has staked ENJ2.
     * 
     * Returns:
     * 
     * DispatchResult
     * Conditions:
     * - If there's no entry for the user in the `EarlyBirdRewards` mapping.
     * - If the user tries to claim early bird bonus for his stake before 90 days
     */
    get asV102(): null {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsClaimFromEfinityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.claim_from_efinity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Claim Enjin that was burned on the Efinity Parachain.
     * Optionally provide an alternate destination.
     * 
     * Caller must be the same as the account that burned the EFI.
     * 
     * Parameters:
     * - `origin`: The account that burned the EFI.
     * - `dest`: The destination account to payout the claim. If None, the caller is used.
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Claims.claim_from_efinity') === '668e91341797bf94bb751499e22a0ac0612a896d75f159be357f45d7cf102c1a'
    }

    /**
     * Claim Enjin that was burned on the Efinity Parachain.
     * Optionally provide an alternate destination.
     * 
     * Caller must be the same as the account that burned the EFI.
     * 
     * Parameters:
     * - `origin`: The account that burned the EFI.
     * - `dest`: The destination account to payout the claim. If None, the caller is used.
     */
    get asV101(): {dest: (Uint8Array | undefined)} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Claim Enjin that was burned on the Efinity Parachain.
     * Optionally provide an alternate destination.
     * 
     * Caller must be the same as the account that burned the EFI.
     * 
     * Parameters:
     * - `origin`: The account that burned the EFI.
     * - `dest`: The destination account to payout the claim. If None, the caller is used.
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Claims.claim_from_efinity') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Claim Enjin that was burned on the Efinity Parachain.
     * Optionally provide an alternate destination.
     * 
     * Caller must be the same as the account that burned the EFI.
     * 
     * Parameters:
     * - `origin`: The account that burned the EFI.
     * - `dest`: The destination account to payout the claim. If None, the caller is used.
     */
    get asV102(): null {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsMintClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.mint_claim')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Mint a new claim to collect EFIs.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * Parameters:
     * - `who`: The Ethereum address allowed to collect this claim.
     * - `value`: The number of EFIs that will be claimed.
     * 
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * 
     * Total Complexity: O(1)
     * </weight>
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Claims.mint_claim') === 'bd93629e146aeda1b31bc7c1c194470feee46b9e4aed4d426ce152fe4c633fce'
    }

    /**
     * Mint a new claim to collect EFIs.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * Parameters:
     * - `who`: The Ethereum address allowed to collect this claim.
     * - `value`: The number of EFIs that will be claimed.
     * 
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * 
     * Total Complexity: O(1)
     * </weight>
     */
    get asMatrixEnjinV603(): {who: Uint8Array, value: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsMintEnjFromNativeEfiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.mint_enj_from_native_efi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Bridge EFI from the Efinity parachain to the Enjin Relay Chain
     * 
     * Parameters:
     * - `origin`: The account initiating the claim and from which EFI will be burned.
     * - `amount`: Number of EFIs to burn in order to bridge to the Enjin Relay Chain. The
     * conversion rate will be according to the `ExchangeRate` storage on the Enjin Relay
     * Chain.
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Claims.mint_enj_from_native_efi') === 'a3bdd43eed59e7b65720eef9b2dfe72389ca71ac9dbe7fe2874438aae4f18886'
    }

    /**
     * Bridge EFI from the Efinity parachain to the Enjin Relay Chain
     * 
     * Parameters:
     * - `origin`: The account initiating the claim and from which EFI will be burned.
     * - `amount`: Number of EFIs to burn in order to bridge to the Enjin Relay Chain. The
     * conversion rate will be according to the `ExchangeRate` storage on the Enjin Relay
     * Chain.
     */
    get asV101(): {amount: bigint} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsMoveClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.move_claim')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `move_claim` moves the claim from one Ethereum address to another
     * 
     * Arguments:
     * 
     * * `old`: EthereumAddress,
     * * `new`: EthereumAddress,
     * 
     * The weight of this call is invariant over the input parameters.
     * 
     * Total Complexity: O(1)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Claims.move_claim') === '391b7a792248e7221ffbf77c01942251d2928a4e2b37c8103704237e0d5f69b6'
    }

    /**
     * `move_claim` moves the claim from one Ethereum address to another
     * 
     * Arguments:
     * 
     * * `old`: EthereumAddress,
     * * `new`: EthereumAddress,
     * 
     * The weight of this call is invariant over the input parameters.
     * 
     * Total Complexity: O(1)
     */
    get asMatrixEnjinV603(): {old: Uint8Array, new: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `move_claim` moves the claim from one Ethereum address to another
     * 
     * Arguments:
     * 
     * * `origin`: OriginFor<T>
     * * `old`: EthereumAddress,
     * * `new`: EthereumAddress,
     * 
     * Returns:
     * 
     * DispatchResultWithPostInfo
     * 
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * 
     * Total Complexity: O(1)
     * </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Claims.move_claim') === 'cd849edba2cd433399c9d865ac4e953cb579c5080c4dc0941d23eedd023327fa'
    }

    /**
     * `move_claim` moves the claim from one Ethereum address to another
     * 
     * Arguments:
     * 
     * * `origin`: OriginFor<T>
     * * `old`: EthereumAddress,
     * * `new`: EthereumAddress,
     * 
     * Returns:
     * 
     * DispatchResultWithPostInfo
     * 
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * 
     * Total Complexity: O(1)
     * </weight>
     */
    get asV101(): {old: v101.Account, new: v101.Account} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsRejectClaimsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.reject_claims')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `reject_claims` is a function that is called by ForceOrigin and allows to reject a batch
     * of claims
     * 
     * Arguments:
     * 
     * * `batch_data`: A vector of user accounts and transaction hashes.
     * 
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * And REMOVE the pending ETH transaction
     * 
     * Total Complexity: O(N)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Claims.reject_claims') === 'ba8c7423005b3c776672afeea4787184e35d7635ce8a807d29ad34a56bb3ec3a'
    }

    /**
     * `reject_claims` is a function that is called by ForceOrigin and allows to reject a batch
     * of claims
     * 
     * Arguments:
     * 
     * * `batch_data`: A vector of user accounts and transaction hashes.
     * 
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * And REMOVE the pending ETH transaction
     * 
     * Total Complexity: O(N)
     */
    get asMatrixEnjinV603(): {batchData: matrixEnjinV603.RejectData[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `reject_claims` is a function that allows the `Approver` to reject a batch of claims
     * 
     * Arguments:
     * 
     * * `origin`: OriginFor<T>
     * * `batch_data`: A vector of transaction hashes.
     * 
     * Returns:
     * 
     * DispatchResult
     * </weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * And REMOVE the pending ETH transaction
     * 
     * Total Complexity: O(N)
     * </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Claims.reject_claims') === '601314ffd448dede3ecc3d0eef396fdd3e6a0ffa494fcc8c06361853d804a633'
    }

    /**
     * `reject_claims` is a function that allows the `Approver` to reject a batch of claims
     * 
     * Arguments:
     * 
     * * `origin`: OriginFor<T>
     * * `batch_data`: A vector of transaction hashes.
     * 
     * Returns:
     * 
     * DispatchResult
     * </weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * And REMOVE the pending ETH transaction
     * 
     * Total Complexity: O(N)
     * </weight>
     */
    get asV101(): {batchData: [Uint8Array, (number | undefined)][]} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `reject_claims` is a function that lets us reject a batch of claims
     * 
     * Arguments:
     * 
     * * `batch_data`: A vector of transaction hashes.
     * 
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * And REMOVE the pending ETH transaction
     * 
     * Total Complexity: O(N)
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Claims.reject_claims') === 'd17799c0439dd4be515df671a5e4dad9ea7b02bb6b10891917389da31b88e070'
    }

    /**
     * `reject_claims` is a function that lets us reject a batch of claims
     * 
     * Arguments:
     * 
     * * `batch_data`: A vector of transaction hashes.
     * 
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * And REMOVE the pending ETH transaction
     * 
     * Total Complexity: O(N)
     */
    get asV102(): {batchData: v102.RejectData[]} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsRequestClaimsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.request_claims')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `request_claims` is a function that allows a relayer to request claims for a batch of
     * transactions
     * 
     * Parameters:
     * 
     * * `block_number`: The block number of Ethereum or Parachain block that contains the
     *   transaction.
     * * `batch_data`: A vector of EthereumTransactionDataOf structs.
     * 
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * 
     * Total Complexity: O(N)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Claims.request_claims') === '8651d50612fce74f8dc56916ca34482bfbf847715d78b6a5abe3e656171b63d0'
    }

    /**
     * `request_claims` is a function that allows a relayer to request claims for a batch of
     * transactions
     * 
     * Parameters:
     * 
     * * `block_number`: The block number of Ethereum or Parachain block that contains the
     *   transaction.
     * * `batch_data`: A vector of EthereumTransactionDataOf structs.
     * 
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * 
     * Total Complexity: O(N)
     */
    get asMatrixEnjinV603(): {blockNumber: number, batchData: matrixEnjinV603.Claim[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `request_claims` is a function that allows a relayer to request claims for a batch of
     * transactions
     * 
     * Parameters:
     * 
     * * `origin`: OriginFor<T>
     * * `block_number`: The block number of Ethereum or Parachain block that contains the
     *   transaction.
     * * `batch_data`: A vector of EthereumTransactionDataOf structs.
     * * `chain`: The chain that the transactions are from (Ethereum/Efinity Parachain).
     * 
     * Returns:
     * 
     * DispatchResult
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * 
     * Total Complexity: O(N)
     * </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Claims.request_claims') === '4223f850613b41b0a74ade8d6509f976b14ee2e5f9aff9bd0f9c686581eceec7'
    }

    /**
     * `request_claims` is a function that allows a relayer to request claims for a batch of
     * transactions
     * 
     * Parameters:
     * 
     * * `origin`: OriginFor<T>
     * * `block_number`: The block number of Ethereum or Parachain block that contains the
     *   transaction.
     * * `batch_data`: A vector of EthereumTransactionDataOf structs.
     * * `chain`: The chain that the transactions are from (Ethereum/Efinity Parachain).
     * 
     * Returns:
     * 
     * DispatchResult
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * 
     * Total Complexity: O(N)
     * </weight>
     */
    get asV101(): {blockNumber: number, batchData: v101.Claim[], chain: v101.Chain} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `request_claims` is a function that allows a relayer to request claims for a batch of
     * transactions
     * 
     * Parameters:
     * 
     * * `block_number`: The block number of Ethereum or Parachain block that contains the
     *   transaction.
     * * `batch_data`: A vector of EthereumTransactionDataOf structs.
     * * `chain`: The chain that the transactions are from (Ethereum/Efinity Parachain).
     * 
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * 
     * Total Complexity: O(N)
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Claims.request_claims') === '912806abf3463bda3c9dc56944f3e75f59cf6e22c9da4310a51975b96c9d4605'
    }

    /**
     * `request_claims` is a function that allows a relayer to request claims for a batch of
     * transactions
     * 
     * Parameters:
     * 
     * * `block_number`: The block number of Ethereum or Parachain block that contains the
     *   transaction.
     * * `batch_data`: A vector of EthereumTransactionDataOf structs.
     * * `chain`: The chain that the transactions are from (Ethereum/Efinity Parachain).
     * 
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to iterate over pending approval ETH transaction
     * 
     * Total Complexity: O(N)
     */
    get asV102(): {blockNumber: number, batchData: v102.Claim[], chain: v102.Chain} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsSetDelayTimeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.set_delay_time')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * This function sets a delay time for claims and requires a governance origin to execute.
     * 
     * Arguments:
     * 
     * * `delay_time`: The delay_time parameter is the number of blocks that must pass before a
     * certain action can be taken. In this case, it is being used to set the delay time for
     * claims in the governance pallet.
     * 
     * Returns:
     * 
     * either `Ok(())` if the delay time is successfully set, or an `Err` with a
     * `DispatchError` if the delay time is less than 24 hours.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Claims.set_delay_time') === '9919843de279df806342c680fb041fef5bf53146b6b6c11827b8297e977076c8'
    }

    /**
     * This function sets a delay time for claims and requires a governance origin to execute.
     * 
     * Arguments:
     * 
     * * `delay_time`: The delay_time parameter is the number of blocks that must pass before a
     * certain action can be taken. In this case, it is being used to set the delay time for
     * claims in the governance pallet.
     * 
     * Returns:
     * 
     * either `Ok(())` if the delay time is successfully set, or an `Err` with a
     * `DispatchError` if the delay time is less than 24 hours.
     */
    get asMatrixEnjinV603(): {delayTime: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsSetExchangeRateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.set_exchange_rate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `set_exchange_rate` is a function that can be called by ForceOrigin and
     * it sets the exchange rate
     * 
     * Parameters:
     * 
     * * `numerator`: u128,
     * * `denominator`: u128,
     * 
     * The weight of this call is invariant over the input parameters.
     * 
     * Total Complexity: O(1)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Claims.set_exchange_rate') === 'da214b06a2cf61183fd833c1552f319c06e2eddcf08a00a207b203ca34682446'
    }

    /**
     * `set_exchange_rate` is a function that can be called by ForceOrigin and
     * it sets the exchange rate
     * 
     * Parameters:
     * 
     * * `numerator`: u128,
     * * `denominator`: u128,
     * 
     * The weight of this call is invariant over the input parameters.
     * 
     * Total Complexity: O(1)
     */
    get asMatrixEnjinV603(): {numerator: bigint, denominator: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorStakingForceSetCurrentMaxCandidatesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorStaking.force_set_current_max_candidates')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the current max candidates, must be within 0 and
     * [`MaxCandidates`](Config::MaxCandidates)
     * 
     * Only [`ForceOrigin`](Config::ForceOrigin) can call this function.
     * 
     * # Errors
     * 
     * - [`Error::TooManyCandidates`] if the number of candidates is already at the maximum.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CollatorStaking.force_set_current_max_candidates') === '310ae211a2124713dfde4d9d728ef98d0b24b616c3e5410d3181c5ef2e8ddade'
    }

    /**
     * Set the current max candidates, must be within 0 and
     * [`MaxCandidates`](Config::MaxCandidates)
     * 
     * Only [`ForceOrigin`](Config::ForceOrigin) can call this function.
     * 
     * # Errors
     * 
     * - [`Error::TooManyCandidates`] if the number of candidates is already at the maximum.
     */
    get asMatrixEnjinV603(): {maxCandidates: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorStakingForceSetMinCollatorStakeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorStaking.force_set_min_collator_stake')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the minimum collator stake amount
     * 
     * [`T::ForceOrigin`](Config::ForceOrigin) call only
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CollatorStaking.force_set_min_collator_stake') === '06eff2469bc17d7aebdedd42c10947459c1f0d4fae809ce8e19728d9c971339c'
    }

    /**
     * Set the minimum collator stake amount
     * 
     * [`T::ForceOrigin`](Config::ForceOrigin) call only
     */
    get asMatrixEnjinV603(): {minCollatorStake: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorStakingJoinCandidatesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorStaking.join_candidates')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Join the list of candidates for collation.
     * 
     * # Errors
     * 
     * - [`Error::BelowMinStakeAmount`] if `amount` is below the minimum required amount.
     * - [`Error::NominationExists`] if nomination already exists.
     * - [`Error::AccountIdNotRegistered`] if `AccountId` is not registered as a collator.
     * - [`Error::NoAssociatedValidatorId`] if no associated validator ID for `AccountId`.
     * - [`Error::TooManyCandidates`] if the number of candidates is already at the maximum.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CollatorStaking.join_candidates') === 'f6b28a93d2ad8a91812f4261c4e03231091780b2314de37559af3b8f507099bc'
    }

    /**
     * Join the list of candidates for collation.
     * 
     * # Errors
     * 
     * - [`Error::BelowMinStakeAmount`] if `amount` is below the minimum required amount.
     * - [`Error::NominationExists`] if nomination already exists.
     * - [`Error::AccountIdNotRegistered`] if `AccountId` is not registered as a collator.
     * - [`Error::NoAssociatedValidatorId`] if no associated validator ID for `AccountId`.
     * - [`Error::TooManyCandidates`] if the number of candidates is already at the maximum.
     */
    get asMatrixEnjinV603(): {amount: bigint, rewardsCut: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorStakingNominateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorStaking.nominate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Nominate a specific candidate to be selected for collation and block production.
     * 
     * # Errors
     * 
     * - [`Error::CandidateDoesNotExist`] if the candidate does not exist.
     * - [`Error::NominationExists`] if the nomination already exists.
     * - [`Error::BelowMinNominationStakeAmount`] if the nomination amount is below the
     *   minimum.
     * - [`Error::TooManyNominations`] if there are too many nominations for the candidate.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CollatorStaking.nominate') === '30f29e64cc7b4f99f08cb48567ffb4af918d57fe9455b7152205397218f72966'
    }

    /**
     * Nominate a specific candidate to be selected for collation and block production.
     * 
     * # Errors
     * 
     * - [`Error::CandidateDoesNotExist`] if the candidate does not exist.
     * - [`Error::NominationExists`] if the nomination already exists.
     * - [`Error::BelowMinNominationStakeAmount`] if the nomination amount is below the
     *   minimum.
     * - [`Error::TooManyNominations`] if there are too many nominations for the candidate.
     */
    get asMatrixEnjinV603(): {collatorId: Uint8Array, amount: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorStakingRemoveNominationCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorStaking.remove_nomination')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a nomination previously registered for a specific collator candidate.
     * 
     * # Errors
     * 
     * - [`Error::CandidateDoesNotExist`] if the candidate does not exist.
     * - [`Error::NominationDoesNotExist`] if the nomination does not exist.
     * - [`Error::TooManyCandidates`] if there are too many candidates in the set.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CollatorStaking.remove_nomination') === '850c9ad9685e8b8f2587b1f9106e128c780b5d96e4560a40cf7d75d51543f181'
    }

    /**
     * Remove a nomination previously registered for a specific collator candidate.
     * 
     * # Errors
     * 
     * - [`Error::CandidateDoesNotExist`] if the candidate does not exist.
     * - [`Error::NominationDoesNotExist`] if the nomination does not exist.
     * - [`Error::TooManyCandidates`] if there are too many candidates in the set.
     */
    get asMatrixEnjinV603(): {collatorId: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorStakingSetInvulnerablesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorStaking.set_invulnerables')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force set the invulnerables.
     * 
     * [`ForceOrigin`](Config::ForceOrigin) call only.
     * 
     * # Errors
     * 
     * - [`Error::TooManyInvulnerables`] if the number of invulnerables exceeds the maximum
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CollatorStaking.set_invulnerables') === 'f991968966792a125cac7c888dc7194239a215e624de7c15edbe7afe0e683c8a'
    }

    /**
     * Force set the invulnerables.
     * 
     * [`ForceOrigin`](Config::ForceOrigin) call only.
     * 
     * # Errors
     * 
     * - [`Error::TooManyInvulnerables`] if the number of invulnerables exceeds the maximum
     */
    get asMatrixEnjinV603(): {accounts: Uint8Array[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorStakingUnbondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorStaking.unbond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Leave the collator set of this parachain.
     * 
     * In this case, if the calling account is already a collator, an exit
     * is registered so that this account is not selected for the next set of collators.
     * Otherwise, if the account is only a candidate, this candidate will be removed
     * and the nominations would be freed up.
     * 
     * # Errors
     * 
     * - [`Error::CandidateDoesNotExist`] if candidate does not exist.
     * - [`Error::CannotUnbondInvulnerable`] cannot unbond an invulnerable collator.
     * - [`Error::ExitInProgress`] if unbonding for collator already in progress.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CollatorStaking.unbond') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Leave the collator set of this parachain.
     * 
     * In this case, if the calling account is already a collator, an exit
     * is registered so that this account is not selected for the next set of collators.
     * Otherwise, if the account is only a candidate, this candidate will be removed
     * and the nominations would be freed up.
     * 
     * # Errors
     * 
     * - [`Error::CandidateDoesNotExist`] if candidate does not exist.
     * - [`Error::CannotUnbondInvulnerable`] cannot unbond an invulnerable collator.
     * - [`Error::ExitInProgress`] if unbonding for collator already in progress.
     */
    get asMatrixEnjinV603(): null {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CommunityPoolApproveProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CommunityPool.approve_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
     * and the original deposit will be returned.
     * 
     * May only be called from `T::ApproveOrigin`.
     * 
     * ## Complexity
     *  - O(1).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CommunityPool.approve_proposal') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     * Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
     * and the original deposit will be returned.
     * 
     * May only be called from `T::ApproveOrigin`.
     * 
     * ## Complexity
     *  - O(1).
     */
    get asMatrixEnjinV603(): {proposalId: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CommunityPoolProposeSpendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CommunityPool.propose_spend')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Put forward a suggestion for spending. A deposit proportional to the value
     * is reserved and slashed if the proposal is rejected. It is returned once the
     * proposal is awarded.
     * 
     * ## Complexity
     * - O(1)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CommunityPool.propose_spend') === 'ffef9f31e8ae5085e7c0a55a685daef52218f0bf7083015ac904dafceedf09ee'
    }

    /**
     * Put forward a suggestion for spending. A deposit proportional to the value
     * is reserved and slashed if the proposal is rejected. It is returned once the
     * proposal is awarded.
     * 
     * ## Complexity
     * - O(1)
     */
    get asMatrixEnjinV603(): {value: bigint, beneficiary: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CommunityPoolRejectProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CommunityPool.reject_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Reject a proposed spend. The original deposit will be slashed.
     * 
     * May only be called from `T::RejectOrigin`.
     * 
     * ## Complexity
     * - O(1)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CommunityPool.reject_proposal') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     * Reject a proposed spend. The original deposit will be slashed.
     * 
     * May only be called from `T::RejectOrigin`.
     * 
     * ## Complexity
     * - O(1)
     */
    get asMatrixEnjinV603(): {proposalId: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CommunityPoolRemoveApprovalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CommunityPool.remove_approval')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     * The original deposit will no longer be returned.
     * 
     * May only be called from `T::RejectOrigin`.
     * - `proposal_id`: The index of a proposal
     * 
     * ## Complexity
     * - O(A) where `A` is the number of approvals
     * 
     * Errors:
     * - `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
     * i.e., the proposal has not been approved. This could also mean the proposal does not
     * exist altogether, thus there is no way it would have been approved in the first place.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CommunityPool.remove_approval') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     * The original deposit will no longer be returned.
     * 
     * May only be called from `T::RejectOrigin`.
     * - `proposal_id`: The index of a proposal
     * 
     * ## Complexity
     * - O(A) where `A` is the number of approvals
     * 
     * Errors:
     * - `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
     * i.e., the proposal has not been approved. This could also mean the proposal does not
     * exist altogether, thus there is no way it would have been approved in the first place.
     */
    get asMatrixEnjinV603(): {proposalId: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CommunityPoolSpendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CommunityPool.spend')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Propose and approve a spend of treasury funds.
     * 
     * - `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     * 
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('CommunityPool.spend') === '18a5bcfd718b2b225ac128952f0fc34fff8371520e0ab5bac3a0ab20286b496d'
    }

    /**
     * Propose and approve a spend of treasury funds.
     * 
     * - `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     * 
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     */
    get asMatrixEnjinV603(): {amount: bigint, beneficiary: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetAsyncBackingParamsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_async_backing_params')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the asynchronous backing parameters.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Configuration.set_async_backing_params') === '1c1b805cf8e6d6b9ec6baa9c21ef458b772d0077453262792e5f8db8da2706f0'
    }

    /**
     * Set the asynchronous backing parameters.
     */
    get asV104(): {new: v104.AsyncBackingParams} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetBypassConsistencyCheckCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_bypass_consistency_check')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Setting this to true will disable consistency checks for the configuration setters.
     * Use with caution.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_bypass_consistency_check') === 'd05b18ea2c0001429a8a368f643f1f81d54c8340ae4e7a6d0779f3174891b509'
    }

    /**
     * Setting this to true will disable consistency checks for the configuration setters.
     * Use with caution.
     */
    get asV100(): {new: boolean} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetChainAvailabilityPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_chain_availability_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the availability period for parachains.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_chain_availability_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the availability period for parachains.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetCodeRetentionPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_code_retention_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the acceptance period for an included candidate.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_code_retention_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the acceptance period for an included candidate.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetDisputeConclusionByTimeOutPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_dispute_conclusion_by_time_out_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the dispute conclusion by time out period.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_dispute_conclusion_by_time_out_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the dispute conclusion by time out period.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetDisputePeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_dispute_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the dispute period, in number of sessions to keep for disputes.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_dispute_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the dispute period, in number of sessions to keep for disputes.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetDisputePostConclusionAcceptancePeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_dispute_post_conclusion_acceptance_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the dispute post conclusion acceptance period.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_dispute_post_conclusion_acceptance_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the dispute post conclusion acceptance period.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetExecutorParamsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_executor_params')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set PVF executor parameters.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Configuration.set_executor_params') === '6fe6cd5ffee4adb2a6388dede2294fdfccce64aeee62fd1d114629b18378a1c2'
    }

    /**
     * Set PVF executor parameters.
     */
    get asV104(): {new: v104.V4ExecutorParam[]} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetGroupRotationFrequencyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_group_rotation_frequency')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the parachain validator-group rotation frequency
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_group_rotation_frequency') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the parachain validator-group rotation frequency
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpChannelMaxCapacityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_channel_max_capacity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum number of messages allowed in an HRMP channel at once.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_channel_max_capacity') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum number of messages allowed in an HRMP channel at once.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpChannelMaxMessageSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_channel_max_message_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum size of a message that could ever be put into an HRMP channel.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_channel_max_message_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum size of a message that could ever be put into an HRMP channel.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpChannelMaxTotalSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_channel_max_total_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum total size of messages in bytes allowed in an HRMP channel at once.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_channel_max_total_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum total size of messages in bytes allowed in an HRMP channel at once.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpMaxMessageNumPerCandidateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_max_message_num_per_candidate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum number of outbound HRMP messages can be sent by a candidate.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_max_message_num_per_candidate') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum number of outbound HRMP messages can be sent by a candidate.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpMaxParachainInboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_max_parachain_inbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum number of inbound HRMP channels a parachain is allowed to accept.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_max_parachain_inbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum number of inbound HRMP channels a parachain is allowed to accept.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpMaxParachainOutboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_max_parachain_outbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum number of outbound HRMP channels a parachain is allowed to open.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_max_parachain_outbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum number of outbound HRMP channels a parachain is allowed to open.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpMaxParathreadInboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_max_parathread_inbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum number of inbound HRMP channels a parathread is allowed to accept.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_max_parathread_inbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum number of inbound HRMP channels a parathread is allowed to accept.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpMaxParathreadOutboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_max_parathread_outbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum number of outbound HRMP channels a parathread is allowed to open.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_max_parathread_outbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum number of outbound HRMP channels a parathread is allowed to open.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpOpenRequestTtlCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_open_request_ttl')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the number of sessions after which an HRMP open channel request expires.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_open_request_ttl') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the number of sessions after which an HRMP open channel request expires.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpRecipientDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_recipient_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the amount of funds that the recipient should provide for accepting opening an HRMP
     * channel.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_recipient_deposit') === '86d3c70a5efeaca7d1a72b006ed6757b84fb71871eb54ca1d98d6a8fdeb79e3a'
    }

    /**
     * Sets the amount of funds that the recipient should provide for accepting opening an HRMP
     * channel.
     */
    get asV100(): {new: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpSenderDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_sender_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the amount of funds that the sender should provide for opening an HRMP channel.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_sender_deposit') === '86d3c70a5efeaca7d1a72b006ed6757b84fb71871eb54ca1d98d6a8fdeb79e3a'
    }

    /**
     * Sets the amount of funds that the sender should provide for opening an HRMP channel.
     */
    get asV100(): {new: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxCodeSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_code_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the max validation code size for incoming upgrades.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_max_code_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the max validation code size for incoming upgrades.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxDownwardMessageSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_downward_message_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the critical downward message size.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_max_downward_message_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the critical downward message size.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxHeadDataSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_head_data_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the max head data size for paras.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_max_head_data_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the max head data size for paras.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxPovSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_pov_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the max POV block size for incoming upgrades.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_max_pov_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the max POV block size for incoming upgrades.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxUpwardMessageNumPerCandidateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_upward_message_num_per_candidate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum number of messages that a candidate can contain.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_max_upward_message_num_per_candidate') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum number of messages that a candidate can contain.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxUpwardMessageSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_upward_message_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum size of an upward message that can be sent by a candidate.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_max_upward_message_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum size of an upward message that can be sent by a candidate.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxUpwardQueueCountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_upward_queue_count')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum items that can present in a upward dispatch queue at once.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_max_upward_queue_count') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum items that can present in a upward dispatch queue at once.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxUpwardQueueSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_upward_queue_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum total size of items that can present in a upward dispatch queue at once.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_max_upward_queue_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the maximum total size of items that can present in a upward dispatch queue at once.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxValidatorsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_validators')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the maximum number of validators to use in parachain consensus.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_max_validators') === 'b271d6a449f9641d900bc39e1a293351b09e8f890436186c9fc6db7592ba0967'
    }

    /**
     * Set the maximum number of validators to use in parachain consensus.
     */
    get asV100(): {new: (number | undefined)} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxValidatorsPerCoreCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_validators_per_core')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the maximum number of validators to assign to any core.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_max_validators_per_core') === 'b271d6a449f9641d900bc39e1a293351b09e8f890436186c9fc6db7592ba0967'
    }

    /**
     * Set the maximum number of validators to assign to any core.
     */
    get asV100(): {new: (number | undefined)} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMinimumValidationUpgradeDelayCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_minimum_validation_upgrade_delay')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the minimum delay between announcing the upgrade block for a parachain until the
     * upgrade taking place.
     * 
     * See the field documentation for information and constraints for the new value.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_minimum_validation_upgrade_delay') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the minimum delay between announcing the upgrade block for a parachain until the
     * upgrade taking place.
     * 
     * See the field documentation for information and constraints for the new value.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetNDelayTranchesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_n_delay_tranches')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the total number of delay tranches.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_n_delay_tranches') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the total number of delay tranches.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetNeededApprovalsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_needed_approvals')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the number of validators needed to approve a block.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_needed_approvals') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the number of validators needed to approve a block.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetNoShowSlotsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_no_show_slots')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the no show slots, in number of number of consensus slots.
     * Must be at least 1.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_no_show_slots') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the no show slots, in number of number of consensus slots.
     * Must be at least 1.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetParathreadCoresCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_parathread_cores')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the number of parathread execution cores.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_parathread_cores') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the number of parathread execution cores.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetParathreadRetriesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_parathread_retries')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the number of retries for a particular parathread.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_parathread_retries') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the number of retries for a particular parathread.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetPvfCheckingEnabledCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_pvf_checking_enabled')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Enable or disable PVF pre-checking. Consult the field documentation prior executing.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_pvf_checking_enabled') === 'd05b18ea2c0001429a8a368f643f1f81d54c8340ae4e7a6d0779f3174891b509'
    }

    /**
     * Enable or disable PVF pre-checking. Consult the field documentation prior executing.
     */
    get asV100(): {new: boolean} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetPvfVotingTtlCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_pvf_voting_ttl')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the number of session changes after which a PVF pre-checking voting is rejected.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_pvf_voting_ttl') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the number of session changes after which a PVF pre-checking voting is rejected.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetRelayVrfModuloSamplesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_relay_vrf_modulo_samples')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the number of samples to do of the `RelayVRFModulo` approval assignment criterion.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_relay_vrf_modulo_samples') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the number of samples to do of the `RelayVRFModulo` approval assignment criterion.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetSchedulingLookaheadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_scheduling_lookahead')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the scheduling lookahead, in expected number of blocks at peak throughput.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_scheduling_lookahead') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the scheduling lookahead, in expected number of blocks at peak throughput.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetThreadAvailabilityPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_thread_availability_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the availability period for parathreads.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_thread_availability_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the availability period for parathreads.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetUmpMaxIndividualWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_ump_max_individual_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the maximum amount of weight any individual upward message may consume.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_ump_max_individual_weight') === '75eef6f2cd3523e44f50db837d1610f4db03539037986ac2704c4a043d58ba81'
    }

    /**
     * Sets the maximum amount of weight any individual upward message may consume.
     */
    get asV100(): {new: v100.Weight} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetUmpServiceTotalWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_ump_service_total_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_ump_service_total_weight') === '75eef6f2cd3523e44f50db837d1610f4db03539037986ac2704c4a043d58ba81'
    }

    /**
     * Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get asV100(): {new: v100.Weight} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetValidationUpgradeCooldownCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_validation_upgrade_cooldown')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the validation upgrade cooldown.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_validation_upgrade_cooldown') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the validation upgrade cooldown.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetValidationUpgradeDelayCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_validation_upgrade_delay')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the validation upgrade delay.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_validation_upgrade_delay') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the validation upgrade delay.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetZerothDelayTrancheWidthCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_zeroth_delay_tranche_width')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the zeroth delay tranche width.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Configuration.set_zeroth_delay_tranche_width') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the zeroth delay tranche width.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingDelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.delegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     * 
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     * 
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     *   - be delegating already; or
     *   - have no voting activity (if there is, then it will need to be removed/consolidated
     *     through `reap_vote` or `unvote`).
     * 
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     *   to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     *   account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     *   be more than the account's current balance.
     * 
     * Emits `Delegated`.
     * 
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     *   voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ConvictionVoting.delegate') === '563d5eab734fe469b3fd1a773588895c1e243f7cab2958e6049514318be32953'
    }

    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     * 
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     * 
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     *   - be delegating already; or
     *   - have no voting activity (if there is, then it will need to be removed/consolidated
     *     through `reap_vote` or `unvote`).
     * 
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     *   to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     *   account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     *   be more than the account's current balance.
     * 
     * Emits `Delegated`.
     * 
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     *   voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    get asV100(): {class: number, to: v100.MultiAddress, conviction: v100.Conviction, balance: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingRemoveOtherVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.remove_other_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a vote for a poll.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     *   `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ConvictionVoting.remove_other_vote') === '852f4a0a1605e3f516a2a6871f4fb69a9ef09ca1678667ccfea4b04852621c76'
    }

    /**
     * Remove a vote for a poll.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     *   `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get asV100(): {target: v100.MultiAddress, class: number, index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingRemoveVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.remove_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a vote for a poll.
     * 
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     *   - the vote of the account was in opposition to the result; or
     *   - there was no conviction to the account's vote; or
     *   - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     * 
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     * 
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     * 
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     *   which have finished or are cancelled, this must be `Some`.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ConvictionVoting.remove_vote') === 'be8a5ba82f77b6bda5e0784b678fdfe0fe9d28837d87406cb5d907269bb45b25'
    }

    /**
     * Remove a vote for a poll.
     * 
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     *   - the vote of the account was in opposition to the result; or
     *   - there was no conviction to the account's vote; or
     *   - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     * 
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     * 
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     * 
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     *   which have finished or are cancelled, this must be `Some`.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get asV100(): {class: (number | undefined), index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingUndelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.undelegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     * 
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued has passed.
     * 
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     * 
     * - `class`: The class of polls to remove the delegation from.
     * 
     * Emits `Undelegated`.
     * 
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     *   voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ConvictionVoting.undelegate') === '55363f75c61dc45265060eec3a1e578e86c93c9059f3f1b3d63fc1f2da6e7ea5'
    }

    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     * 
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued has passed.
     * 
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     * 
     * - `class`: The class of polls to remove the delegation from.
     * 
     * Emits `Undelegated`.
     * 
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     *   voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    get asV100(): {class: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ConvictionVoting.unlock') === 'd0c817de5611525243564693dd06f5defa9929cf71d85585f26348b2a7e0ae97'
    }

    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get asV100(): {class: number, target: v100.MultiAddress} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ConvictionVoting.vote') === 'c659a6e0d84861cd97f11d84780117a5b61201e70e1e5533a740761dc9489558'
    }

    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     */
    get asV100(): {pollIndex: number, vote: v100.AccountVote} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilCloseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.close')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Council.close') === 'a88911953f51bddf0f0aeafa7caa7ca904d30cdb24f940ff177d2acf7088d3bd'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     */
    get asMatrixEnjinV603(): {proposalHash: Uint8Array, index: number, proposalWeightBound: matrixEnjinV603.Weight, lengthBound: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilDisapproveProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.disapprove_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     * 
     * Must be called by the Root origin.
     * 
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     * ## Complexity
     * O(P) where P is the number of max proposals
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Council.disapprove_proposal') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     * 
     * Must be called by the Root origin.
     * 
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     * ## Complexity
     * O(P) where P is the number of max proposals
     */
    get asMatrixEnjinV603(): {proposalHash: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilExecuteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.execute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Council.execute') === '42e02516da5b061d1088373ba15312fb75350b4c460c86553b77632c49a1bfff'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get asMatrixEnjinV603(): {proposal: matrixEnjinV603.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Council.execute') === '0528eb882b25dbc861bdb3dd23bf719192247ea0286b4ba762894271e9b24340'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get asMatrixEnjinV1000(): {proposal: matrixEnjinV1000.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Council.execute') === '8436778e072de5fd031e538ef23b88424ea15c5d94208a400f13f01159fbfb00'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get asMatrixEnjinV1003(): {proposal: matrixEnjinV1003.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Council.propose') === 'ad8e807bb31ab0d0a1cc9796c09abc6d953cde11f68353038cb230910f45f5a9'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get asMatrixEnjinV603(): {threshold: number, proposal: matrixEnjinV603.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Council.propose') === '23bce148208de1a3e941cab0a9183111169beffd2c4b17fa55c77063a17ed2db'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get asMatrixEnjinV1000(): {threshold: number, proposal: matrixEnjinV1000.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Council.propose') === '0318441ab0a9bd4ab2b6e923b6c88985852689b516a4d2084ccf14caa5f03be6'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get asMatrixEnjinV1003(): {threshold: number, proposal: matrixEnjinV1003.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilSetMembersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.set_members')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the collective's membership.
     * 
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     *   weight estimation.
     * 
     * The dispatch of this call must be `SetMembersOrigin`.
     * 
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     *       the weight estimations rely on it to estimate dispatchable weight.
     * 
     * # WARNING:
     * 
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     * 
     * ## Complexity:
     * - `O(MP + N)` where:
     *   - `M` old-members-count (code- and governance-bounded)
     *   - `N` new-members-count (code- and governance-bounded)
     *   - `P` proposals-count (code-bounded)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Council.set_members') === '71b7fcb1d8a62eff96a9ef006517578ce9189e6d931948a256a04ca75ff68d4a'
    }

    /**
     * Set the collective's membership.
     * 
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     *   weight estimation.
     * 
     * The dispatch of this call must be `SetMembersOrigin`.
     * 
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     *       the weight estimations rely on it to estimate dispatchable weight.
     * 
     * # WARNING:
     * 
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     * 
     * ## Complexity:
     * - `O(MP + N)` where:
     *   - `M` old-members-count (code- and governance-bounded)
     *   - `N` new-members-count (code- and governance-bounded)
     *   - `P` proposals-count (code-bounded)
     */
    get asMatrixEnjinV603(): {newMembers: Uint8Array[], prime: (Uint8Array | undefined), oldCount: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     * 
     * Requires the sender to be a member.
     * 
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Council.vote') === 'f8a1069a57f7b721f47c086d08b6838ae1a0c08f58caddb82428ba5f1407540f'
    }

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     * 
     * Requires the sender to be a member.
     * 
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     */
    get asMatrixEnjinV603(): {proposal: Uint8Array, index: number, approve: boolean} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanAddMemoCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.add_memo')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add an optional memo to an existing crowdloan contribution.
     * 
     * Origin must be Signed, and the user must have contributed to the crowdloan.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Crowdloan.add_memo') === 'd6cb52d8c86e57166a333b4d42b2009bcfa3453e4607b97f850eeb1a96f78389'
    }

    /**
     * Add an optional memo to an existing crowdloan contribution.
     * 
     * Origin must be Signed, and the user must have contributed to the crowdloan.
     */
    get asV100(): {index: number, memo: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanContributeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.contribute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Contribute to a crowd sale. This will transfer some balance over to fund a parachain
     * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Crowdloan.contribute') === 'c85a49d78a97667f6d8d7cdda206ad3ba38bd873ab2e82a42135a31c48152a6c'
    }

    /**
     * Contribute to a crowd sale. This will transfer some balance over to fund a parachain
     * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
     */
    get asV100(): {index: number, value: bigint, signature: (v100.MultiSignature | undefined)} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanContributeAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.contribute_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Contribute your entire balance to a crowd sale. This will transfer the entire balance of a user over to fund a parachain
     * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Crowdloan.contribute_all') === '321aa21eccdd4e2a7dd0dbf8127848aa93dbaa207ef379b0f6f21d3d57327f71'
    }

    /**
     * Contribute your entire balance to a crowd sale. This will transfer the entire balance of a user over to fund a parachain
     * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
     */
    get asV100(): {index: number, signature: (v100.MultiSignature | undefined)} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanCreateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.create')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a new crowdloaning campaign for a parachain slot with the given lease period range.
     * 
     * This applies a lock to your parachain configuration, ensuring that it cannot be changed
     * by the parachain manager.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Crowdloan.create') === '9d0529ac9fb92b6a7eca157299243acd0d2eb82a352509475556c79f78f47aa3'
    }

    /**
     * Create a new crowdloaning campaign for a parachain slot with the given lease period range.
     * 
     * This applies a lock to your parachain configuration, ensuring that it cannot be changed
     * by the parachain manager.
     */
    get asV100(): {index: number, cap: bigint, firstPeriod: number, lastPeriod: number, end: number, verifier: (v100.MultiSigner | undefined)} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanDissolveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.dissolve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Crowdloan.dissolve') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanEditCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.edit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Edit the configuration for an in-progress crowdloan.
     * 
     * Can only be called by Root origin.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Crowdloan.edit') === '9d0529ac9fb92b6a7eca157299243acd0d2eb82a352509475556c79f78f47aa3'
    }

    /**
     * Edit the configuration for an in-progress crowdloan.
     * 
     * Can only be called by Root origin.
     */
    get asV100(): {index: number, cap: bigint, firstPeriod: number, lastPeriod: number, end: number, verifier: (v100.MultiSigner | undefined)} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanPokeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.poke')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Poke the fund into `NewRaise`
     * 
     * Origin must be Signed, and the fund has non-zero raise.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Crowdloan.poke') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Poke the fund into `NewRaise`
     * 
     * Origin must be Signed, and the fund has non-zero raise.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanRefundCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.refund')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Automatically refund contributors of an ended crowdloan.
     * Due to weight restrictions, this function may need to be called multiple
     * times to fully refund all users. We will refund `RemoveKeysLimit` users at a time.
     * 
     * Origin must be signed, but can come from anyone.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Crowdloan.refund') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    /**
     * Automatically refund contributors of an ended crowdloan.
     * Due to weight restrictions, this function may need to be called multiple
     * times to fully refund all users. We will refund `RemoveKeysLimit` users at a time.
     * 
     * Origin must be signed, but can come from anyone.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanWithdrawCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.withdraw')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Withdraw full balance of a specific contributor.
     * 
     * Origin must be signed, but can come from anyone.
     * 
     * The fund must be either in, or ready for, retirement. For a fund to be *in* retirement, then the retirement
     * flag must be set. For a fund to be ready for retirement, then:
     * - it must not already be in retirement;
     * - the amount of raised funds must be bigger than the _free_ balance of the account;
     * - and either:
     *   - the block number must be at least `end`; or
     *   - the current lease period must be greater than the fund's `last_period`.
     * 
     * In this case, the fund's retirement flag is set and its `end` is reset to the current block
     * number.
     * 
     * - `who`: The account whose contribution should be withdrawn.
     * - `index`: The parachain to whose crowdloan the contribution was made.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Crowdloan.withdraw') === '02cd16eba62d1217d4cb6a31d6568e8ad8fdc99a88200e787453e7eba24cad9e'
    }

    /**
     * Withdraw full balance of a specific contributor.
     * 
     * Origin must be signed, but can come from anyone.
     * 
     * The fund must be either in, or ready for, retirement. For a fund to be *in* retirement, then the retirement
     * flag must be set. For a fund to be ready for retirement, then:
     * - it must not already be in retirement;
     * - the amount of raised funds must be bigger than the _free_ balance of the account;
     * - and either:
     *   - the block number must be at least `end`; or
     *   - the current lease period must be greater than the fund's `last_period`.
     * 
     * In this case, the fund's retirement flag is set and its `end` is reset to the current block
     * number.
     * 
     * - `who`: The account whose contribution should be withdrawn.
     * - `index`: The parachain to whose crowdloan the contribution was made.
     */
    get asV100(): {who: Uint8Array, index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyBlacklistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.blacklist')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Permanently place a proposal into the blacklist. This prevents it from ever being
     * proposed again.
     * 
     * If called on a queued public or external proposal, then this will result in it being
     * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
     * then it will be cancelled.
     * 
     * The dispatch origin of this call must be `BlacklistOrigin`.
     * 
     * - `proposal_hash`: The proposal hash to blacklist permanently.
     * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
     * cancelled.
     * 
     * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
     *   reasonable value).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.blacklist') === '8d8922c0775adfb1df719211ab4fc6fb40b6cc8864038bcb1b544d9cf039b30a'
    }

    /**
     * Permanently place a proposal into the blacklist. This prevents it from ever being
     * proposed again.
     * 
     * If called on a queued public or external proposal, then this will result in it being
     * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
     * then it will be cancelled.
     * 
     * The dispatch origin of this call must be `BlacklistOrigin`.
     * 
     * - `proposal_hash`: The proposal hash to blacklist permanently.
     * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
     * cancelled.
     * 
     * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
     *   reasonable value).
     */
    get asMatrixEnjinV603(): {proposalHash: Uint8Array, maybeRefIndex: (number | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyCancelProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.cancel_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a proposal.
     * 
     * The dispatch origin of this call must be `CancelProposalOrigin`.
     * 
     * - `prop_index`: The index of the proposal to cancel.
     * 
     * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.cancel_proposal') === '0e50c7564a4a7f4e6a09a0abcc8022f4445c064144d2318ed086e6080bee800d'
    }

    /**
     * Remove a proposal.
     * 
     * The dispatch origin of this call must be `CancelProposalOrigin`.
     * 
     * - `prop_index`: The index of the proposal to cancel.
     * 
     * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
     */
    get asMatrixEnjinV603(): {propIndex: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyCancelReferendumCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.cancel_referendum')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a referendum.
     * 
     * The dispatch origin of this call must be _Root_.
     * 
     * - `ref_index`: The index of the referendum to cancel.
     * 
     * # Weight: `O(1)`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.cancel_referendum') === 'efe4ecff834678ca8b73ea6e2f38e514997eb402e82da2ce4cf036008844a857'
    }

    /**
     * Remove a referendum.
     * 
     * The dispatch origin of this call must be _Root_.
     * 
     * - `ref_index`: The index of the referendum to cancel.
     * 
     * # Weight: `O(1)`.
     */
    get asMatrixEnjinV603(): {refIndex: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyClearPublicProposalsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.clear_public_proposals')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Clears all public proposals.
     * 
     * The dispatch origin of this call must be _Root_.
     * 
     * Weight: `O(1)`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.clear_public_proposals') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Clears all public proposals.
     * 
     * The dispatch origin of this call must be _Root_.
     * 
     * Weight: `O(1)`.
     */
    get asMatrixEnjinV603(): null {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyDelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.delegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Delegate the voting power (with some given conviction) of the sending account.
     * 
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     * 
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     *   - be delegating already; or
     *   - have no voting activity (if there is, then it will need to be removed/consolidated
     *     through `reap_vote` or `unvote`).
     * 
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     *   account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     *   be more than the account's current balance.
     * 
     * Emits `Delegated`.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *   voted on. Weight is charged as if maximum votes.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.delegate') === '789db36a1c43e1ffdad52288f8573a492f529890632f51821e7bd1d74ba6cffc'
    }

    /**
     * Delegate the voting power (with some given conviction) of the sending account.
     * 
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     * 
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     *   - be delegating already; or
     *   - have no voting activity (if there is, then it will need to be removed/consolidated
     *     through `reap_vote` or `unvote`).
     * 
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     *   account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     *   be more than the account's current balance.
     * 
     * Emits `Delegated`.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *   voted on. Weight is charged as if maximum votes.
     */
    get asMatrixEnjinV603(): {to: matrixEnjinV603.MultiAddress, conviction: matrixEnjinV603.Conviction, balance: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyEmergencyCancelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.emergency_cancel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
     * referendum.
     * 
     * The dispatch origin of this call must be `CancellationOrigin`.
     * 
     * -`ref_index`: The index of the referendum to cancel.
     * 
     * Weight: `O(1)`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.emergency_cancel') === '8a84371403a09e2f8fc2aac80f5a8a53229b346c4b3859069867b8e656b13450'
    }

    /**
     * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
     * referendum.
     * 
     * The dispatch origin of this call must be `CancellationOrigin`.
     * 
     * -`ref_index`: The index of the referendum to cancel.
     * 
     * Weight: `O(1)`.
     */
    get asMatrixEnjinV603(): {refIndex: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyExternalProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.external_propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule a referendum to be tabled once it is legal to schedule an external
     * referendum.
     * 
     * The dispatch origin of this call must be `ExternalOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.external_propose') === 'e44fb402f80afe0e08cb6de5a4ed457a1a66e080379319fd281acd81eaf457ac'
    }

    /**
     * Schedule a referendum to be tabled once it is legal to schedule an external
     * referendum.
     * 
     * The dispatch origin of this call must be `ExternalOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     */
    get asMatrixEnjinV603(): {proposal: matrixEnjinV603.Bounded} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyExternalProposeDefaultCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.external_propose_default')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     * schedule an external referendum.
     * 
     * The dispatch of this call must be `ExternalDefaultOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_default') === 'e44fb402f80afe0e08cb6de5a4ed457a1a66e080379319fd281acd81eaf457ac'
    }

    /**
     * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     * schedule an external referendum.
     * 
     * The dispatch of this call must be `ExternalDefaultOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get asMatrixEnjinV603(): {proposal: matrixEnjinV603.Bounded} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyExternalProposeMajorityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.external_propose_majority')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     * an external referendum.
     * 
     * The dispatch of this call must be `ExternalMajorityOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_majority') === 'e44fb402f80afe0e08cb6de5a4ed457a1a66e080379319fd281acd81eaf457ac'
    }

    /**
     * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     * an external referendum.
     * 
     * The dispatch of this call must be `ExternalMajorityOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get asMatrixEnjinV603(): {proposal: matrixEnjinV603.Bounded} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyFastTrackCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.fast_track')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule the currently externally-proposed majority-carries referendum to be tabled
     * immediately. If there is no externally-proposed referendum currently, or if there is one
     * but it is not a majority-carries referendum then it fails.
     * 
     * The dispatch of this call must be `FastTrackOrigin`.
     * 
     * - `proposal_hash`: The hash of the current external proposal.
     * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
     * 	Must be always greater than zero.
     * 	For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
     * - `delay`: The number of block after voting has ended in approval and this should be
     *   enacted. This doesn't have a minimum amount.
     * 
     * Emits `Started`.
     * 
     * Weight: `O(1)`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.fast_track') === '27cb200e922e485b41e3150b3d7bf5e8624346f6ff1d78601373ba3d80689c89'
    }

    /**
     * Schedule the currently externally-proposed majority-carries referendum to be tabled
     * immediately. If there is no externally-proposed referendum currently, or if there is one
     * but it is not a majority-carries referendum then it fails.
     * 
     * The dispatch of this call must be `FastTrackOrigin`.
     * 
     * - `proposal_hash`: The hash of the current external proposal.
     * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
     * 	Must be always greater than zero.
     * 	For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
     * - `delay`: The number of block after voting has ended in approval and this should be
     *   enacted. This doesn't have a minimum amount.
     * 
     * Emits `Started`.
     * 
     * Weight: `O(1)`
     */
    get asMatrixEnjinV603(): {proposalHash: Uint8Array, votingPeriod: number, delay: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Propose a sensitive action to be taken.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender must
     * have funds to cover the deposit.
     * 
     * - `proposal_hash`: The hash of the proposal preimage.
     * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
     * 
     * Emits `Proposed`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.propose') === 'db924825c9fd40cb04a839b510db55dcdd425c7b06116ccd22d4834d1201e8db'
    }

    /**
     * Propose a sensitive action to be taken.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender must
     * have funds to cover the deposit.
     * 
     * - `proposal_hash`: The hash of the proposal preimage.
     * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
     * 
     * Emits `Proposed`.
     */
    get asMatrixEnjinV603(): {proposal: matrixEnjinV603.Bounded, value: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyRemoveOtherVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.remove_other_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a vote for a referendum.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the referendum was cancelled, because the voter lost the referendum or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for
     *   referendum `index`.
     * - `index`: The index of referendum of the vote to be removed.
     * 
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.remove_other_vote') === '43d317508cc3ba04dcadb411eb6499f25532d64ab5a169b27410116c72f40a26'
    }

    /**
     * Remove a vote for a referendum.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the referendum was cancelled, because the voter lost the referendum or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for
     *   referendum `index`.
     * - `index`: The index of referendum of the vote to be removed.
     * 
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get asMatrixEnjinV603(): {target: matrixEnjinV603.MultiAddress, index: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyRemoveVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.remove_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a vote for a referendum.
     * 
     * If:
     * - the referendum was cancelled, or
     * - the referendum is ongoing, or
     * - the referendum has ended such that
     *   - the vote of the account was in opposition to the result; or
     *   - there was no conviction to the account's vote; or
     *   - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     * 
     * If, however, the referendum has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     * 
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for referendum `index`.
     * 
     * - `index`: The index of referendum of the vote to be removed.
     * 
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.remove_vote') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Remove a vote for a referendum.
     * 
     * If:
     * - the referendum was cancelled, or
     * - the referendum is ongoing, or
     * - the referendum has ended such that
     *   - the vote of the account was in opposition to the result; or
     *   - there was no conviction to the account's vote; or
     *   - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     * 
     * If, however, the referendum has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     * 
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for referendum `index`.
     * 
     * - `index`: The index of referendum of the vote to be removed.
     * 
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get asMatrixEnjinV603(): {index: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracySecondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.second')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Signals agreement with a particular proposal.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender
     * must have funds to cover the deposit, equal to the original deposit.
     * 
     * - `proposal`: The index of the proposal to second.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.second') === '7ac80a800d6686f21181e7b5b45c8949dc5b807bc6ec111188c7c6850a21b898'
    }

    /**
     * Signals agreement with a particular proposal.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender
     * must have funds to cover the deposit, equal to the original deposit.
     * 
     * - `proposal`: The index of the proposal to second.
     */
    get asMatrixEnjinV603(): {proposal: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracySetMetadataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.set_metadata')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set or clear a metadata of a proposal or a referendum.
     * 
     * Parameters:
     * - `origin`: Must correspond to the `MetadataOwner`.
     *     - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
     *       threshold.
     *     - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
     *       threshold.
     *     - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
     *       threshold.
     *     - `Signed` by a creator for a public proposal.
     *     - `Signed` to clear a metadata for a finished referendum.
     *     - `Root` to set a metadata for an ongoing referendum.
     * - `owner`: an identifier of a metadata owner.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.set_metadata') === '8a33eb55343342fba9c677650a4010c3766a354183990db37b268b1fef0c72fe'
    }

    /**
     * Set or clear a metadata of a proposal or a referendum.
     * 
     * Parameters:
     * - `origin`: Must correspond to the `MetadataOwner`.
     *     - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
     *       threshold.
     *     - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
     *       threshold.
     *     - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
     *       threshold.
     *     - `Signed` by a creator for a public proposal.
     *     - `Signed` to clear a metadata for a finished referendum.
     *     - `Root` to set a metadata for an ongoing referendum.
     * - `owner`: an identifier of a metadata owner.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     */
    get asMatrixEnjinV603(): {owner: matrixEnjinV603.MetadataOwner, maybeHash: (Uint8Array | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyUndelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.undelegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Undelegate the voting power of the sending account.
     * 
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued.
     * 
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     * 
     * Emits `Undelegated`.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *   voted on. Weight is charged as if maximum votes.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.undelegate') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Undelegate the voting power of the sending account.
     * 
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued.
     * 
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     * 
     * Emits `Undelegated`.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *   voted on. Weight is charged as if maximum votes.
     */
    get asMatrixEnjinV603(): null {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unlock tokens that have an expired lock.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.unlock') === '8142da248a3023c20f65ce8f6287f9eaf75336ab8815cb15537149abcdd0c20c'
    }

    /**
     * Unlock tokens that have an expired lock.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get asMatrixEnjinV603(): {target: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyVetoExternalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.veto_external')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Veto and blacklist the external proposal hash.
     * 
     * The dispatch origin of this call must be `VetoOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
     * 
     * Emits `Vetoed`.
     * 
     * Weight: `O(V + log(V))` where V is number of `existing vetoers`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.veto_external') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     * Veto and blacklist the external proposal hash.
     * 
     * The dispatch origin of this call must be `VetoOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
     * 
     * Emits `Vetoed`.
     * 
     * Weight: `O(V + log(V))` where V is number of `existing vetoers`
     */
    get asMatrixEnjinV603(): {proposalHash: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `ref_index`: The index of the referendum to vote for.
     * - `vote`: The vote configuration.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Democracy.vote') === '3936a4cb49f77280bd94142d4ec458afcf5cb8a5e5b0d602b1b1530928021e28'
    }

    /**
     * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `ref_index`: The index of the referendum to vote for.
     * - `vote`: The vote configuration.
     */
    get asMatrixEnjinV603(): {refIndex: number, vote: matrixEnjinV603.AccountVote} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class DmpQueueServiceOverweightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'DmpQueue.service_overweight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Service a single overweight message.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('DmpQueue.service_overweight') === '80fae8875bf513efc1e06b7dac547fccfc1e5fc45888cc8afd9b43812cf51bf5'
    }

    /**
     * Service a single overweight message.
     */
    get asMatrixEnjinV603(): {index: bigint, weightLimit: matrixEnjinV603.Weight} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionProviderMultiPhaseGovernanceFallbackCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionProviderMultiPhase.governance_fallback')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Trigger the governance fallback.
     * 
     * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
     * calling [`Call::set_emergency_election_result`].
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.governance_fallback') === 'f3179fd0f0529838d5758e1e919a1900aa58425b96768e9648bf806ee9c9b1ae'
    }

    /**
     * Trigger the governance fallback.
     * 
     * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
     * calling [`Call::set_emergency_election_result`].
     */
    get asV100(): {maybeMaxVoters: (number | undefined), maybeMaxTargets: (number | undefined)} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionProviderMultiPhaseSetEmergencyElectionResultCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionProviderMultiPhase.set_emergency_election_result')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set a solution in the queue, to be handed out to the client of this pallet in the next
     * call to `ElectionProvider::elect`.
     * 
     * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
     * 
     * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
     * feasibility check itself can in principle cause the election process to fail (due to
     * memory/weight constrains).
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.set_emergency_election_result') === '976eeea3dee9ad3c2d95e30c6751a49c4ae6a755a0448d0d6f282625dd92e539'
    }

    /**
     * Set a solution in the queue, to be handed out to the client of this pallet in the next
     * call to `ElectionProvider::elect`.
     * 
     * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
     * 
     * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
     * feasibility check itself can in principle cause the election process to fail (due to
     * memory/weight constrains).
     */
    get asV100(): {supports: [Uint8Array, v100.Support][]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionProviderMultiPhaseSetMinimumUntrustedScoreCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionProviderMultiPhase.set_minimum_untrusted_score')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set a new value for `MinimumUntrustedScore`.
     * 
     * Dispatch origin must be aligned with `T::ForceOrigin`.
     * 
     * This check can be turned off by setting the value to `None`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.set_minimum_untrusted_score') === '4b6d16ae537aca5ce887c10c25d838413bb18639efa0829f62aa6b722837c206'
    }

    /**
     * Set a new value for `MinimumUntrustedScore`.
     * 
     * Dispatch origin must be aligned with `T::ForceOrigin`.
     * 
     * This check can be turned off by setting the value to `None`.
     */
    get asV100(): {maybeNextScore: (v100.ElectionScore | undefined)} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionProviderMultiPhaseSubmitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionProviderMultiPhase.submit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Submit a solution for the signed phase.
     * 
     * The dispatch origin fo this call must be __signed__.
     * 
     * The solution is potentially queued, based on the claimed score and processed at the end
     * of the signed phase.
     * 
     * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     * might be rewarded, slashed, or get all or a part of the deposit back.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.submit') === '557615f0c49c60f0230763f545f02d629e721649044d5414869be2def11828ca'
    }

    /**
     * Submit a solution for the signed phase.
     * 
     * The dispatch origin fo this call must be __signed__.
     * 
     * The solution is potentially queued, based on the claimed score and processed at the end
     * of the signed phase.
     * 
     * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     * might be rewarded, slashed, or get all or a part of the deposit back.
     */
    get asV100(): {rawSolution: v100.RawSolution} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionProviderMultiPhaseSubmitUnsignedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionProviderMultiPhase.submit_unsigned')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Submit a solution for the unsigned phase.
     * 
     * The dispatch origin fo this call must be __none__.
     * 
     * This submission is checked on the fly. Moreover, this unsigned solution is only
     * validated when submitted to the pool from the **local** node. Effectively, this means
     * that only active validators can submit this transaction when authoring a block (similar
     * to an inherent).
     * 
     * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     * panic if the solution submitted by the validator is invalid in any way, effectively
     * putting their authoring reward at risk.
     * 
     * No deposit or reward is associated with this submission.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.submit_unsigned') === '957b20578c01a686cdcc45e9f29b8e199841a1cc05413837f9bfd713633890d6'
    }

    /**
     * Submit a solution for the unsigned phase.
     * 
     * The dispatch origin fo this call must be __none__.
     * 
     * This submission is checked on the fly. Moreover, this unsigned solution is only
     * validated when submitted to the pool from the **local** node. Effectively, this means
     * that only active validators can submit this transaction when authoring a block (similar
     * to an inherent).
     * 
     * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     * panic if the solution submitted by the validator is invalid in any way, effectively
     * putting their authoring reward at risk.
     * 
     * No deposit or reward is associated with this submission.
     */
    get asV100(): {rawSolution: v100.RawSolution, witness: v100.SolutionOrSnapshotSize} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ExtrinsicPausePauseExtrinsicCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ExtrinsicPause.pause_extrinsic')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === 'c5ca046c3e628825c4f962ecee1fb8f169fc9ec1170abc23027691646568f362'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asMatrixEnjinV603(): {call: matrixEnjinV603.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === 'dfdc85c4bce39de3c59558df6914b9e6c165ee6a0c4fe5fcfaf34dedd3b3cc02'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asMatrixEnjinV1000(): {call: matrixEnjinV1000.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === 'd6954ca3e8c613f063c1cc4cb8a1427954836cf9b43c22a2085ff35970df2b19'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asMatrixEnjinV1003(): {call: matrixEnjinV1003.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isV102(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === 'c6ddc94340246e91abb3367adb41bc80690e3e6a472fa0d66ea75db13001b602'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asV102(): {call: v102.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isV103(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === '7d52dffcab7981dd9ccd0a4323e8b55c3424594f7a0e0fb65fdb91d77e539d25'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asV103(): {call: v103.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === '224db957837f82bfe574e8412f9136db1b8c93f9a56767ed6562bb904d01d00c'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asV104(): {call: v104.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === '5c340eff106e5e77bf3fc7ed448c5cfe63d1620a4c075fca0a2a2880999c802d'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asV105(): {call: v105.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === 'a13d1e403b41dc771eee170f336bea96287f3f31353c045e716a1589e374771c'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asV106(): {call: v106.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === 'aa20d5aed3e490df4727fa4a57fc54ecacbd5da9beafa373852a9c550ec8776c'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asV110(): {call: v110.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === 'c2db18f7ac5cb8e6425e8449fa2cc8ed81bd1dfa727d493cedb03fbef6db8c1b'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asV120(): {call: v120.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === '6014621c9f993d5160a4e6af5f3ce72aab4aa8ad57239bdceacaf3f7f490ecd0'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asV1021(): {call: v1021.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === '8c9cad6e847f61d9f1fabd60c1105770298f522f0936204e2fb6e20673d7ba53'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asV1022(): {call: v1022.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.pause_extrinsic') === 'd708c62f18d125750dcb631c6f479f26353507105d91cb3693056e735db0e2ee'
    }

    /**
     * Pause execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To pause the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is paused, else the entire pallet is paused.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     * - [`Error::CannotPauseSelf`] if the pallet name is the same as the name of this pallet.
     */
    get asV1023(): {call: v1023.Call, pauseOnlyExtrinsic: boolean} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class ExtrinsicPauseResumeExtrinsicCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ExtrinsicPause.resume_extrinsic')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === '1d150745e6ed925df16c2c548e329b7a5e8069f57fe385c83b6f156a72d9ab69'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asMatrixEnjinV603(): {call: matrixEnjinV603.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === 'd2e9cff4a1017eda50c75e870e039fac02110ee75edcc7c36272bba0f9e53572'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asMatrixEnjinV1000(): {call: matrixEnjinV1000.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === '2868d2f123fb7eb424d929b21b8898623752bf6cb09d15597ed65811eea81c36'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asMatrixEnjinV1003(): {call: matrixEnjinV1003.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isV102(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === '27ead2a983fc116f9dbb572d1d6c8f49c966390f354421f231b84c7f6de2e540'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asV102(): {call: v102.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isV103(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === '756f2f32d9ed7bf8fe133653bf9b563731281dea6f8357fb4d1db132ab10c497'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asV103(): {call: v103.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === '95f5ca2b262e988384cedbd3eff6880ef5f8f1ea04a1b3b80b4b58470cf0ed53'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asV104(): {call: v104.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === 'cd5c3824b773fa9204b0a5263c2e04ad9df716b6a80f1aa494611638c45a0568'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asV105(): {call: v105.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === 'aaab21ed4357437deca0aa607c94c55f2e3dd17962fc0f7c43df79bb6df844de'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asV106(): {call: v106.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === '2649963d7477e30cb632955335bf1045d83ec7c3ae4d654700af47cdb0557d3d'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asV110(): {call: v110.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === '20f07ad6a61773888740f6ed244817e8fac053006601694c497db81c09107b41'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asV120(): {call: v120.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === 'e9d968cbb4000c9ea18d9a52b62f7725412448f4db807118f7a15b6652abcfbc'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asV1021(): {call: v1021.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === '38914964d3e76013b951af507129f3fa2d381e05c18673d4ac900616ebfebae1'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asV1022(): {call: v1022.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('ExtrinsicPause.resume_extrinsic') === 'f5b2db18ec28c60f7cadfea8244cddfc6bb667f64a860b52fb8dd5751b920dbb'
    }

    /**
     * Resume execution of extrinsic(s)
     * 
     * The values of pallet_name and extrinsic_name are extracted from the `call` parameter.
     * Ex : To resume the multi_tokens pallet, the `call` parameter should be of the type
     * `pallet_multi_tokens::Call` If `pause_only_extrinsic` is true, then only the extrinsic
     * is resumed, else the entire pallet is resumed.
     * 
     * # Errors
     * 
     * - [`Error::CannotProcessInput`] if the pallet name or extrinsic name is faulty.
     */
    get asV1023(): {call: v1023.Call, resumeOnlyExtrinsic: boolean} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectiveAddMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.add_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Introduce a new member.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of non-member which will become a member.
     * - `rank`: The rank to give the new member.
     * 
     * Weight: `O(1)`
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipCollective.add_member') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Introduce a new member.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of non-member which will become a member.
     * - `rank`: The rank to give the new member.
     * 
     * Weight: `O(1)`
     */
    get asV100(): {who: v100.MultiAddress} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectiveCleanupPollCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.cleanup_poll')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove votes from the given poll. It must have ended.
     * 
     * - `origin`: Must be `Signed` by any account.
     * - `poll_index`: Index of a poll which is completed and for which votes continue to
     *   exist.
     * - `max`: Maximum number of vote items from remove in this call.
     * 
     * Transaction fees are waived if the operation is successful.
     * 
     * Weight `O(max)` (less if there are fewer items to remove than `max`).
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipCollective.cleanup_poll') === '615caab6c9d00e9434a2a62bdbb08a0eb77297b001692b7d050ea0ec818af5a7'
    }

    /**
     * Remove votes from the given poll. It must have ended.
     * 
     * - `origin`: Must be `Signed` by any account.
     * - `poll_index`: Index of a poll which is completed and for which votes continue to
     *   exist.
     * - `max`: Maximum number of vote items from remove in this call.
     * 
     * Transaction fees are waived if the operation is successful.
     * 
     * Weight `O(max)` (less if there are fewer items to remove than `max`).
     */
    get asV100(): {pollIndex: number, max: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectiveDemoteMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.demote_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Decrement the rank of an existing member by one. If the member is already at rank zero,
     * then they are removed entirely.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * 
     * Weight: `O(1)`, less if the member's index is highest in its rank.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipCollective.demote_member') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Decrement the rank of an existing member by one. If the member is already at rank zero,
     * then they are removed entirely.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * 
     * Weight: `O(1)`, less if the member's index is highest in its rank.
     */
    get asV100(): {who: v100.MultiAddress} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectivePromoteMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.promote_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Increment the rank of an existing member by one.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member.
     * 
     * Weight: `O(1)`
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipCollective.promote_member') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Increment the rank of an existing member by one.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member.
     * 
     * Weight: `O(1)`
     */
    get asV100(): {who: v100.MultiAddress} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectiveRemoveMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.remove_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the member entirely.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * - `min_rank`: The rank of the member or greater.
     * 
     * Weight: `O(min_rank)`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipCollective.remove_member') === '5848311fd06c03b30fa0c3e38db7f30b932bfcf1c54417fb40a23a7aa5690f18'
    }

    /**
     * Remove the member entirely.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * - `min_rank`: The rank of the member or greater.
     * 
     * Weight: `O(min_rank)`.
     */
    get asV100(): {who: v100.MultiAddress, minRank: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectiveVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     * 
     * - `origin`: Must be `Signed` by a member account.
     * - `poll`: Index of a poll which is ongoing.
     * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
     * 
     * Transaction fees are be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * 
     * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipCollective.vote') === '3b92ae59b712230cb36e2d4be01eaefb25ea0777001bbd698d8598221faca7d3'
    }

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     * 
     * - `origin`: Must be `Signed` by a member account.
     * - `poll`: Index of a poll which is ongoing.
     * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
     * 
     * Transaction fees are be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * 
     * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
     */
    get asV100(): {poll: number, aye: boolean} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaCancelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.cancel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel an ongoing referendum.
     * 
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Cancelled`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.cancel') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Cancel an ongoing referendum.
     * 
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Cancelled`.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaKillCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.kill')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel an ongoing referendum and slash the deposits.
     * 
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Killed` and `DepositSlashed`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.kill') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Cancel an ongoing referendum and slash the deposits.
     * 
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Killed` and `DepositSlashed`.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaNudgeReferendumCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.nudge_referendum')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.nudge_referendum') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaOneFewerDecidingCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.one_fewer_deciding')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Advance a track onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     * 
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.one_fewer_deciding') === '75d849d1c0275ad91cee68e888f612b619530fe1a9f1955df3cd6d91e4d4ed1d'
    }

    /**
     * Advance a track onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     * 
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    get asV100(): {track: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaPlaceDecisionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.place_decision_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Post the Decision Deposit for a referendum.
     * 
     * - `origin`: must be `Signed` and the account must have funds available for the
     *   referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     *   posted.
     * 
     * Emits `DecisionDepositPlaced`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.place_decision_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Post the Decision Deposit for a referendum.
     * 
     * - `origin`: must be `Signed` and the account must have funds available for the
     *   referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     *   posted.
     * 
     * Emits `DecisionDepositPlaced`.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaRefundDecisionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.refund_decision_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     *   refunded.
     * 
     * Emits `DecisionDepositRefunded`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.refund_decision_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     *   refunded.
     * 
     * Emits `DecisionDepositRefunded`.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaRefundSubmissionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.refund_submission_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     *   refunded.
     * 
     * Emits `SubmissionDepositRefunded`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.refund_submission_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     *   refunded.
     * 
     * Emits `SubmissionDepositRefunded`.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaSetMetadataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.set_metadata')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set or clear metadata of a referendum.
     * 
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     *   metadata of a finished referendum.
     * - `index`:  The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.set_metadata') === '3130106e44cfd70dbb871159c7a9caa9e760fbb1b51fd56f1cc4d461eeca38c2'
    }

    /**
     * Set or clear metadata of a referendum.
     * 
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     *   metadata of a finished referendum.
     * - `index`:  The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     */
    get asV104(): {index: number, maybeHash: (Uint8Array | undefined)} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaSubmitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.submit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.submit') === 'c6b1866b08bcf6b99803902eeac819703f700657631221410ba67d5facc7a2f1'
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get asV100(): {proposalOrigin: v100.OriginCaller, proposal: v100.Bounded, enactmentMoment: v100.DispatchTime} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.submit') === '5b0326c13e12b7d51945c5a2ce3b43a61b1185e72b4e7d43b5d12c3e8d214b34'
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get asV105(): {proposalOrigin: v105.OriginCaller, proposal: v105.Bounded, enactmentMoment: v105.DispatchTime} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksAddAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.add_account')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Adds new account for `user_id` to fuel tank at `tank_id`. An account is
     * required to dispatch calls. A deposit is required, and may be paid by
     * the user or the fuel tank, depending on the settings.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank at `tank_id` does not exist
     * - [`Error::NoPermission`] if `origin` does not have permission to add an account
     * - [`Error::AccountAlreadyExists`] if account at `user_id` already exists
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.add_account') === '6b49a9c6d7cc4fec142fc02f8f252f4fa0bd06e832d1e877b43f77b3d8ef27b3'
    }

    /**
     * Adds new account for `user_id` to fuel tank at `tank_id`. An account is
     * required to dispatch calls. A deposit is required, and may be paid by
     * the user or the fuel tank, depending on the settings.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank at `tank_id` does not exist
     * - [`Error::NoPermission`] if `origin` does not have permission to add an account
     * - [`Error::AccountAlreadyExists`] if account at `user_id` already exists
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, userId: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksBatchAddAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.batch_add_account')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Similar to add_account but takes a list of
     * [`AccountId`](frame_system::Config::AccountId)s to insert into a fuel tank.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if fuel tank at `tank_id` does not exist
     * - [`Error::NoPermission`] if `origin` does not have permission to add an account
     * - [`Error::AccountAlreadyExists`] if account at `user_id` already exists
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.batch_add_account') === 'e548a21f55c9e5bef7a56196dab640774174a939562687e1e6e32b377168ebb5'
    }

    /**
     * Similar to add_account but takes a list of
     * [`AccountId`](frame_system::Config::AccountId)s to insert into a fuel tank.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if fuel tank at `tank_id` does not exist
     * - [`Error::NoPermission`] if `origin` does not have permission to add an account
     * - [`Error::AccountAlreadyExists`] if account at `user_id` already exists
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, userIds: matrixEnjinV603.MultiAddress[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksBatchRemoveAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.batch_remove_account')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Similar to remove_account but takes a list of
     * [`AccountId`](frame_system::Config::AccountId)s to remove from a fuel tank.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if fuel tank at `tank_id` does not exist
     * - [`Error::NoPermission`] if `origin` does not have permission to add an account
     * - [`Error::AccountNotFound`] if account at `user_id` does not exist
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.batch_remove_account') === 'e548a21f55c9e5bef7a56196dab640774174a939562687e1e6e32b377168ebb5'
    }

    /**
     * Similar to remove_account but takes a list of
     * [`AccountId`](frame_system::Config::AccountId)s to remove from a fuel tank.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if fuel tank at `tank_id` does not exist
     * - [`Error::NoPermission`] if `origin` does not have permission to add an account
     * - [`Error::AccountNotFound`] if account at `user_id` does not exist
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, userIds: matrixEnjinV603.MultiAddress[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksCreateFuelTankCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.create_fuel_tank')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === '8a1d177d2d41d4dc5f95b0ef3afadb00553286606fe1f54f6189ca2f15550b1c'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asMatrixEnjinV603(): {descriptor: matrixEnjinV603.FuelTankDescriptor} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === '5cefe5fffba120b9986d54e5643f1824a36f86540473854c6f573344866921f5'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asMatrixEnjinV1000(): {descriptor: matrixEnjinV1000.FuelTankDescriptor} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === 'f453906e5ec08546019022707066080f5eabb1da54f0e905dec948830c860350'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asMatrixEnjinV1003(): {descriptor: matrixEnjinV1003.FuelTankDescriptor} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isV102(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === 'b2ba12b07134f799167a4e8c8c1684a6b97f1bf908a2c64fb4b5d228a2bbc047'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asV102(): {descriptor: v102.FuelTankDescriptor} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isV103(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === '51e89d79e9724a601d1f4607c13638a1764abb41c48e4d8494b8cc3fd4e052a2'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asV103(): {descriptor: v103.FuelTankDescriptor} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isV104(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === 'b90b93877b9bbc7987df75dfb97666ebd0725d67fcf472c33916f111fcbb5b63'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asV104(): {descriptor: v104.FuelTankDescriptor} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isV105(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === '1db92328b778cef924ffe49980d1c98ab48acf7fca84da87d865a83c06edf222'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asV105(): {descriptor: v105.FuelTankDescriptor} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isV106(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === '92f6b0f41b5b367a9f0310e6ea3b52586ea8680de8b66a3af9211e9fbfc4918f'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asV106(): {descriptor: v106.FuelTankDescriptor} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isV110(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === '9d2f4e72ee589e3eb9dea2b00733a6c5feb8d46bc1aa9fa0b678369000860dd1'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asV110(): {descriptor: v110.FuelTankDescriptor} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isV120(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === '3d979e4a454137ac047e55244be591f9f9160e75a0006d00afbb4c521465db0d'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asV120(): {descriptor: v120.FuelTankDescriptor} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === 'f11cd7a0c48dbbe47003b3dc0a67950417a88b945d4e76245603e795b89e7fbb'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asV1021(): {descriptor: v1021.FuelTankDescriptor} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === '21882e5d708f8bb046b5033ea95eaca271380234404937c2b10a556a9d712f20'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asV1022(): {descriptor: v1022.FuelTankDescriptor} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('FuelTanks.create_fuel_tank') === 'ae68b608517d604c41948bb5ce6469b07dbcc84d5f669f8c11cd9a16ca886e4a'
    }

    /**
     * Creates a fuel tank, given a descriptor
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     * - [`Error::DuplicateRuleKinds`] if a rule set has multiple rules of the same kind
     */
    get asV1023(): {descriptor: v1023.FuelTankDescriptor} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksDestroyFuelTankCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.destroy_fuel_tank')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Destroy the fuel tank by scheduling the deletion for `on_finalize` to execute
     * Only callable by owner
     * The fuel tank must be frozen
     * Can only be destroyed if all accounts are removed
     * 
     * # Errors
     * 
     * - [`Error::FuelTankNotFound`] if tank_id does not exist
     * - [`Error::NoPermission`] if caller is not owner
     * - [`Error::DestroyUnfrozenTank`] if tank is not frozen
     * - [`Error::DestroyWithExistingAccounts`] if there are still accounts on the tank
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.destroy_fuel_tank') === '2b9b490c0171de9f8a3f945d1457a9a08933564a71b77cb634db2aa898e91e63'
    }

    /**
     * Destroy the fuel tank by scheduling the deletion for `on_finalize` to execute
     * Only callable by owner
     * The fuel tank must be frozen
     * Can only be destroyed if all accounts are removed
     * 
     * # Errors
     * 
     * - [`Error::FuelTankNotFound`] if tank_id does not exist
     * - [`Error::NoPermission`] if caller is not owner
     * - [`Error::DestroyUnfrozenTank`] if tank is not frozen
     * - [`Error::DestroyWithExistingAccounts`] if there are still accounts on the tank
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksDispatchCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.dispatch')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === 'b677705c3bf454beffbb1db35ce5a5c1eedf672d0e2a8fb60318fc872fdf9185'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, ruleSetId: number, call: matrixEnjinV603.Call, settings: (matrixEnjinV603.DispatchSettings | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === '6a2e47ee4408602a7d3c9f5c665771e29bb8d4a3953bd40d5c7ab596b076f5a0'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asMatrixEnjinV1000(): {tankId: matrixEnjinV1000.MultiAddress, ruleSetId: number, call: matrixEnjinV1000.Call, settings: (matrixEnjinV1000.DispatchSettings | undefined)} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === 'b5bd8d4fd9f72fa240f91055db86aca70c41eba635451dcda30eb392907442b5'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asMatrixEnjinV1003(): {tankId: matrixEnjinV1003.MultiAddress, ruleSetId: number, call: matrixEnjinV1003.Call, settings: (matrixEnjinV1003.DispatchSettings | undefined)} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isV102(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === '53f8c16973bbcdd573b62e79bece0ffc60f67b378606ccd814ab9a2bbc7b30be'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asV102(): {tankId: v102.MultiAddress, ruleSetId: number, call: v102.Call, paysRemainingFee: boolean} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isV103(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === '8049bdcfdae4fddfdadc955ceade9fb1bc5564ded844d3f182f83e484b398df4'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asV103(): {tankId: v103.MultiAddress, ruleSetId: number, call: v103.Call, paysRemainingFee: boolean} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isV104(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === 'e0cd418a1e0f1b8a7bab91fff072bf013ee84e5497aa0b3160ab88f2885117ef'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asV104(): {tankId: v104.MultiAddress, ruleSetId: number, call: v104.Call, paysRemainingFee: boolean} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isV105(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === '733bb6de1fb77a032401f3896211616434dc44affb93cb885014aa2563ec8e11'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asV105(): {tankId: v105.MultiAddress, ruleSetId: number, call: v105.Call, paysRemainingFee: boolean} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isV106(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === '4d51056802f61c7c8d162a5e35e9d3546822c39333190ab92b5a78f6263dd720'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asV106(): {tankId: v106.MultiAddress, ruleSetId: number, call: v106.Call, settings: (v106.DispatchSettings | undefined)} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isV110(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === '12a22426fdd7aafc4edf4372044378109d956fe708d545e12f34eb3b9b755ef7'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asV110(): {tankId: v110.MultiAddress, ruleSetId: number, call: v110.Call, settings: (v110.DispatchSettings | undefined)} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isV120(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === '52f68c819d72900b3c4f498e6e18c542d46e31b2bbcfd4b8a7234d27f7607d82'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asV120(): {tankId: v120.MultiAddress, ruleSetId: number, call: v120.Call, settings: (v120.DispatchSettings | undefined)} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === '60e7368fedf0c92537dbb010125d4a1ff682131b9104c5e9b0fca59d2403b93a'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asV1021(): {tankId: v1021.MultiAddress, ruleSetId: number, call: v1021.Call, settings: (v1021.DispatchSettings | undefined)} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === 'b48ccf6bf627b344c44753148085628675521e0c6a614a9af228387d60fe032a'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asV1022(): {tankId: v1022.MultiAddress, ruleSetId: number, call: v1022.Call, settings: (v1022.DispatchSettings | undefined)} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch') === 'b1aaeee7bd419f04752054498df1a1f18f6eedb608b021acea93b51d3a250f7e'
    }

    /**
     * Dispatch a call using the `tank_id` subject to the rules of `rule_set_id`
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::UsageRestricted`] if caller is not part of ruleset whitelist
     * - [`Error::CallerDoesNotHaveRuleSetTokenBalance`] if caller does not own the tokens to
     *   use the ruleset for remaining_fee when `pays_remaining_fee` is true
     * - [`Error::FuelTankOutOfFunds`] if the fuel tank account cannot pay fees
     */
    get asV1023(): {tankId: v1023.MultiAddress, ruleSetId: number, call: v1023.Call, settings: (v1023.DispatchSettings | undefined)} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksDispatchAndTouchCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.dispatch_and_touch')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === 'b677705c3bf454beffbb1db35ce5a5c1eedf672d0e2a8fb60318fc872fdf9185'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, ruleSetId: number, call: matrixEnjinV603.Call, settings: (matrixEnjinV603.DispatchSettings | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === '6a2e47ee4408602a7d3c9f5c665771e29bb8d4a3953bd40d5c7ab596b076f5a0'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asMatrixEnjinV1000(): {tankId: matrixEnjinV1000.MultiAddress, ruleSetId: number, call: matrixEnjinV1000.Call, settings: (matrixEnjinV1000.DispatchSettings | undefined)} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === 'b5bd8d4fd9f72fa240f91055db86aca70c41eba635451dcda30eb392907442b5'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asMatrixEnjinV1003(): {tankId: matrixEnjinV1003.MultiAddress, ruleSetId: number, call: matrixEnjinV1003.Call, settings: (matrixEnjinV1003.DispatchSettings | undefined)} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isV102(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === '53f8c16973bbcdd573b62e79bece0ffc60f67b378606ccd814ab9a2bbc7b30be'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asV102(): {tankId: v102.MultiAddress, ruleSetId: number, call: v102.Call, paysRemainingFee: boolean} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isV103(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === '8049bdcfdae4fddfdadc955ceade9fb1bc5564ded844d3f182f83e484b398df4'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asV103(): {tankId: v103.MultiAddress, ruleSetId: number, call: v103.Call, paysRemainingFee: boolean} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isV104(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === 'e0cd418a1e0f1b8a7bab91fff072bf013ee84e5497aa0b3160ab88f2885117ef'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asV104(): {tankId: v104.MultiAddress, ruleSetId: number, call: v104.Call, paysRemainingFee: boolean} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isV105(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === '733bb6de1fb77a032401f3896211616434dc44affb93cb885014aa2563ec8e11'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asV105(): {tankId: v105.MultiAddress, ruleSetId: number, call: v105.Call, paysRemainingFee: boolean} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isV106(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === '4d51056802f61c7c8d162a5e35e9d3546822c39333190ab92b5a78f6263dd720'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asV106(): {tankId: v106.MultiAddress, ruleSetId: number, call: v106.Call, settings: (v106.DispatchSettings | undefined)} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isV110(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === '12a22426fdd7aafc4edf4372044378109d956fe708d545e12f34eb3b9b755ef7'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asV110(): {tankId: v110.MultiAddress, ruleSetId: number, call: v110.Call, settings: (v110.DispatchSettings | undefined)} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isV120(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === '52f68c819d72900b3c4f498e6e18c542d46e31b2bbcfd4b8a7234d27f7607d82'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asV120(): {tankId: v120.MultiAddress, ruleSetId: number, call: v120.Call, settings: (v120.DispatchSettings | undefined)} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === '60e7368fedf0c92537dbb010125d4a1ff682131b9104c5e9b0fca59d2403b93a'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asV1021(): {tankId: v1021.MultiAddress, ruleSetId: number, call: v1021.Call, settings: (v1021.DispatchSettings | undefined)} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === 'b48ccf6bf627b344c44753148085628675521e0c6a614a9af228387d60fe032a'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asV1022(): {tankId: v1022.MultiAddress, ruleSetId: number, call: v1022.Call, settings: (v1022.DispatchSettings | undefined)} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('FuelTanks.dispatch_and_touch') === 'b1aaeee7bd419f04752054498df1a1f18f6eedb608b021acea93b51d3a250f7e'
    }

    /**
     * Same as [dispatch](Self::dispatch), but creates an account for `origin` if it does not
     * exist and is allowed by the fuel tank's `user_account_management` settings.
     * 
     * # Errors
     * 
     * Returns the same errors as [dispatch](Self::dispatch) and
     * [add_account](Self::add_account)
     */
    get asV1023(): {tankId: v1023.MultiAddress, ruleSetId: number, call: v1023.Call, settings: (v1023.DispatchSettings | undefined)} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksForceBatchAddAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.force_batch_add_account')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the account storage for give tank_id and account
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.force_batch_add_account') === '273995af5a1f02d81e273bca153f6c53d34f81cabdebda6175f6bd071a905efe'
    }

    /**
     * Sets the account storage for give tank_id and account
     */
    get asMatrixEnjinV603(): {owner: matrixEnjinV603.MultiAddress, tankId: matrixEnjinV603.MultiAddress, userIds: matrixEnjinV603.MultiAddress[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksForceCreateFuelTankCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.force_create_fuel_tank')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.force_create_fuel_tank') === '9fba66045ffe9823498216d94cdbc8a05b718af3834bbcff41bb4664bc9ca23e'
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get asMatrixEnjinV603(): {owner: matrixEnjinV603.MultiAddress, descriptor: matrixEnjinV603.FuelTankDescriptor} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('FuelTanks.force_create_fuel_tank') === '65b2820862588bf26febbe661faafddc4727b819473e3749928112987ca8e04c'
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get asMatrixEnjinV1000(): {owner: matrixEnjinV1000.MultiAddress, descriptor: matrixEnjinV1000.FuelTankDescriptor} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('FuelTanks.force_create_fuel_tank') === '2cd125920335ca612acd514a7052f6fe65e2b6123a2f4abeb4a8bdd647d6f58c'
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get asMatrixEnjinV1003(): {owner: matrixEnjinV1003.MultiAddress, descriptor: matrixEnjinV1003.FuelTankDescriptor} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get isV105(): boolean {
        return this._chain.getCallHash('FuelTanks.force_create_fuel_tank') === '060f8bcca064d6f5fcfa49cf7f2d62177fe149994fc5212e01840ba953368f5c'
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get asV105(): {owner: v105.MultiAddress, descriptor: v105.FuelTankDescriptor} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get isV106(): boolean {
        return this._chain.getCallHash('FuelTanks.force_create_fuel_tank') === '9f5abe28495aa6e9e31bae2e0cf2f6fe0b42d98bb98b757955b3361619488a08'
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get asV106(): {owner: v106.MultiAddress, descriptor: v106.FuelTankDescriptor} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get isV110(): boolean {
        return this._chain.getCallHash('FuelTanks.force_create_fuel_tank') === '2dbe6f76dc85cb34ba000e2674c43d9c0c76ac2145d82e0fa4aed55c38b26338'
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get asV110(): {owner: v110.MultiAddress, descriptor: v110.FuelTankDescriptor} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get isV120(): boolean {
        return this._chain.getCallHash('FuelTanks.force_create_fuel_tank') === '3d491331ff17c2669cdea5424ddee3162c2a13f0b39259193a878857bcfc04a1'
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get asV120(): {owner: v120.MultiAddress, descriptor: v120.FuelTankDescriptor} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('FuelTanks.force_create_fuel_tank') === '9ac6a32c513ce63ae581670ea196d97710108fc639d19d0c7165238651ce9b76'
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get asV1021(): {owner: v1021.MultiAddress, descriptor: v1021.FuelTankDescriptor} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('FuelTanks.force_create_fuel_tank') === 'df7940c7aaa47225103ee890cf54cb43c639e3df7c981bb4c73a4aaf9164df9f'
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get asV1022(): {owner: v1022.MultiAddress, descriptor: v1022.FuelTankDescriptor} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('FuelTanks.force_create_fuel_tank') === '54909f0f6101b9fdc72ee42184f451f2765f7faa6b074555341df57342f72238'
    }

    /**
     * Force creates a fuel tank
     * 
     * # Errors
     * 
     * - [`Error::FuelTankAlreadyExists`] if `tank_id` already exists
     */
    get asV1023(): {owner: v1023.MultiAddress, descriptor: v1023.FuelTankDescriptor} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksForceSetConsumptionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.force_set_consumption')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force set the fuel tank consumption
     * If `user_id` is [`Some`], it sets the consumption for that account.
     * If it is [`None`], it sets the consumption on the fuel tank directly.
     * 
     * # Errors
     * 
     * - [`Error::AccountNotFound`] if `user_id` is `Some` and account does not exist
     * - [`Error::FuelTankNotFound`] if tank_id does not exist
     * - [`Error::NoPermission`] if caller is not ForceOrigin or fuel tank owner
     * - [`Error::InvalidRuleSet`] if `rule_set_id` does not exist
     * - [`Error::MissingRequiredRule`] if `rule_set_id` does not have the required role
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.force_set_consumption') === '465df72f8d1b6dcfdd1b6a3bc9673a492b029ff7adea01f798ff0b1ae3e8dca4'
    }

    /**
     * Force set the fuel tank consumption
     * If `user_id` is [`Some`], it sets the consumption for that account.
     * If it is [`None`], it sets the consumption on the fuel tank directly.
     * 
     * # Errors
     * 
     * - [`Error::AccountNotFound`] if `user_id` is `Some` and account does not exist
     * - [`Error::FuelTankNotFound`] if tank_id does not exist
     * - [`Error::NoPermission`] if caller is not ForceOrigin or fuel tank owner
     * - [`Error::InvalidRuleSet`] if `rule_set_id` does not exist
     * - [`Error::MissingRequiredRule`] if `rule_set_id` does not have the required role
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, userId: (matrixEnjinV603.MultiAddress | undefined), ruleSetId: number, consumption: matrixEnjinV603.Consumption} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksInsertRuleSetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.insert_rule_set')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === 'df466f1c352194eb6e359ca229653c38d60917ad9c95b61fd8a70f0b1a53b65e'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, ruleSetId: number, rules: matrixEnjinV603.DispatchRuleDescriptor[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === 'e070f883d392ab1ce0c1d354817e6119ec0353f4c49435f6481055a1a1155fb6'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asMatrixEnjinV1000(): {tankId: matrixEnjinV1000.MultiAddress, ruleSetId: number, rules: matrixEnjinV1000.DispatchRuleDescriptor[]} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === '26b1fc4d62a36de9033bc84a5073e53cb066a1b1f1c06d4cabdf36fb1bb8d850'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asMatrixEnjinV1003(): {tankId: matrixEnjinV1003.MultiAddress, ruleSetId: number, rules: matrixEnjinV1003.DispatchRuleDescriptor[]} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isV102(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === '4c0ee06be44b3d0ef559f393b3061cde03e06d03f2dd2619f9efe6f6796f70c9'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asV102(): {tankId: v102.MultiAddress, ruleSetId: number, rules: v102.DispatchRuleDescriptor[]} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isV103(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === '36c467440003c6ddf8410c9f3c45103f899556350921f9e037771ed4797ba548'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asV103(): {tankId: v103.MultiAddress, ruleSetId: number, rules: v103.DispatchRuleDescriptor[]} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isV104(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === 'f378adf1758aa7b30476b9f22fd17a620a008f5566a519f85c178d631f0427b8'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asV104(): {tankId: v104.MultiAddress, ruleSetId: number, rules: v104.DispatchRuleDescriptor[]} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isV105(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === 'e4575f74975211fa1a7abd80402d8715ae0ca809beb6d789c1fba94e6e9e01f4'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asV105(): {tankId: v105.MultiAddress, ruleSetId: number, rules: v105.DispatchRuleDescriptor[]} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isV106(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === '3d94daf5337c6457471957172584136c3cebe6e3a8a7e63148ec6029a8f8bd7e'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asV106(): {tankId: v106.MultiAddress, ruleSetId: number, rules: v106.DispatchRuleDescriptor[]} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isV110(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === '7a9b62968a6a49c0671c60ac1f7d9122dc4a3421a62044632e55aa9c730bb5a2'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asV110(): {tankId: v110.MultiAddress, ruleSetId: number, rules: v110.DispatchRuleDescriptor[]} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isV120(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === '20050fd74b5028154d155537a4dc781bcc5a6a3531e00c7e5e70611197186aae'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asV120(): {tankId: v120.MultiAddress, ruleSetId: number, rules: v120.DispatchRuleDescriptor[]} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === 'd986604e773df743d45c9f6450df674cb40dc937ad6d77428ed0fee01025d6de'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asV1021(): {tankId: v1021.MultiAddress, ruleSetId: number, rules: v1021.DispatchRuleDescriptor[]} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === '67071f7b3cbafbac1e72416f9a169cb53cb65e427ff607f66e2381429c237e12'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asV1022(): {tankId: v1022.MultiAddress, ruleSetId: number, rules: v1022.DispatchRuleDescriptor[]} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('FuelTanks.insert_rule_set') === '3f8c0a1513d8e59e9ec3cf2eee67eb19adf88b78831162d25b5d5724642beb39'
    }

    /**
     * Insert a new rule set for `tank_id` and `rule_set_id`. It can be a new rule set
     * or it can replace an existing one. If it is replacing a rule set, a rule that is storing
     * data on any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove
     * the data first. If a rule is being replaced, it will be mutated with the new parameters,
     * and it will maintain any persistent data it already has.
     * 
     * This is only callable by the fuel tank's owner.
     * ### Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     * - [`Error::MaxRuleSetsExceeded`] if max number of rule sets was exceeded
     * - [`Error::DuplicateRuleKinds`] if adding a rule set with multiple rules of the same
     *   kind
     */
    get asV1023(): {tankId: v1023.MultiAddress, ruleSetId: number, rules: v1023.DispatchRuleDescriptor[]} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksMutateFreezeStateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.mutate_freeze_state')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Mutate `is_frozen` state that determines if fuel tank or rule set can be used
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not a fuel tank owner
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('FuelTanks.mutate_freeze_state') === '400d585823f6a5fce567d3e438bd1ddac0b7cc3662931a51424df14279fde426'
    }

    /**
     * Mutate `is_frozen` state that determines if fuel tank or rule set can be used
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not a fuel tank owner
     */
    get asMatrixEnjinV1000(): {tankId: matrixEnjinV1000.MultiAddress, ruleSetId: (number | undefined), isFrozen: boolean} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksMutateFuelTankCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.mutate_fuel_tank')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Apply `mutation` to fuel tank with `tank_id`.
     * 
     * # Errors
     * 
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if `origin` is not the fuel tank owner
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.mutate_fuel_tank') === '9c5fe3d87288410aa8a3827d63434bb6999ebb57c48bba28556304535ab68ca6'
    }

    /**
     * Apply `mutation` to fuel tank with `tank_id`.
     * 
     * # Errors
     * 
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if `origin` is not the fuel tank owner
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, mutation: matrixEnjinV603.DefaultTankMutation} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksRemoveAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.remove_account')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Removes account for `user_id` from fuel tank at `tank_id`. Any deposits
     * are returned.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank at `tank_id` does not exist
     * - [`Error::NoPermission`] if `origin` does not have permission to add an account
     * - [`Error::AccountNotFound`] if account at `user_id` does not exist
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.remove_account') === '6b49a9c6d7cc4fec142fc02f8f252f4fa0bd06e832d1e877b43f77b3d8ef27b3'
    }

    /**
     * Removes account for `user_id` from fuel tank at `tank_id`. Any deposits
     * are returned.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank at `tank_id` does not exist
     * - [`Error::NoPermission`] if `origin` does not have permission to add an account
     * - [`Error::AccountNotFound`] if account at `user_id` does not exist
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, userId: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksRemoveAccountRuleDataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.remove_account_rule_data')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove account rule data if it exists. Only callable by the fuel tank's owner. Requires
     * the fuel tank or the rule set to be frozen.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank for `tank_id` doesn't exist
     * - [`Error::NoPermission`] if called by non-owner
     * - [`Error::AccountNotFound`] if account does not exist for `user_id`
     * - [`Error::RuleSetNotFound`] if rule set does not exist for `rule_set_id`
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::RuleNotFound`] if rule does not exist for `rule_kind`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.remove_account_rule_data') === 'd62fe8a27ba66b6d7b8ed9f74f289bdc41bebf234c0df25965f0147b92569176'
    }

    /**
     * Remove account rule data if it exists. Only callable by the fuel tank's owner. Requires
     * the fuel tank or the rule set to be frozen.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank for `tank_id` doesn't exist
     * - [`Error::NoPermission`] if called by non-owner
     * - [`Error::AccountNotFound`] if account does not exist for `user_id`
     * - [`Error::RuleSetNotFound`] if rule set does not exist for `rule_set_id`
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::RuleNotFound`] if rule does not exist for `rule_kind`
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, userId: matrixEnjinV603.MultiAddress, ruleSetId: number, ruleKind: matrixEnjinV603.DispatchRuleKind} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove account rule data if it exists. Only callable by the fuel tank's owner. Requires
     * the fuel tank or the rule set to be frozen.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank for `tank_id` doesn't exist
     * - [`Error::NoPermission`] if called by non-owner
     * - [`Error::AccountNotFound`] if account does not exist for `user_id`
     * - [`Error::RuleSetNotFound`] if rule set does not exist for `rule_set_id`
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::RuleNotFound`] if rule does not exist for `rule_kind`
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('FuelTanks.remove_account_rule_data') === '73f11459363469dcd8d6653808d665b035e40c7f501c5c20f873dca721350eef'
    }

    /**
     * Remove account rule data if it exists. Only callable by the fuel tank's owner. Requires
     * the fuel tank or the rule set to be frozen.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank for `tank_id` doesn't exist
     * - [`Error::NoPermission`] if called by non-owner
     * - [`Error::AccountNotFound`] if account does not exist for `user_id`
     * - [`Error::RuleSetNotFound`] if rule set does not exist for `rule_set_id`
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::RuleNotFound`] if rule does not exist for `rule_kind`
     */
    get asMatrixEnjinV1000(): {tankId: matrixEnjinV1000.MultiAddress, userId: matrixEnjinV1000.MultiAddress, ruleSetId: number, ruleKind: matrixEnjinV1000.DispatchRuleKind} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove account rule data if it exists. Only callable by the fuel tank's owner. Requires
     * the fuel tank or the rule set to be frozen.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank for `tank_id` doesn't exist
     * - [`Error::NoPermission`] if called by non-owner
     * - [`Error::AccountNotFound`] if account does not exist for `user_id`
     * - [`Error::RuleSetNotFound`] if rule set does not exist for `rule_set_id`
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::RuleNotFound`] if rule does not exist for `rule_kind`
     */
    get isV102(): boolean {
        return this._chain.getCallHash('FuelTanks.remove_account_rule_data') === 'd62fe8a27ba66b6d7b8ed9f74f289bdc41bebf234c0df25965f0147b92569176'
    }

    /**
     * Remove account rule data if it exists. Only callable by the fuel tank's owner. Requires
     * the fuel tank or the rule set to be frozen.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank for `tank_id` doesn't exist
     * - [`Error::NoPermission`] if called by non-owner
     * - [`Error::AccountNotFound`] if account does not exist for `user_id`
     * - [`Error::RuleSetNotFound`] if rule set does not exist for `rule_set_id`
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::RuleNotFound`] if rule does not exist for `rule_kind`
     */
    get asV102(): {tankId: v102.MultiAddress, userId: v102.MultiAddress, ruleSetId: number, ruleKind: v102.DispatchRuleKind} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove account rule data if it exists. Only callable by the fuel tank's owner. Requires
     * the fuel tank or the rule set to be frozen.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank for `tank_id` doesn't exist
     * - [`Error::NoPermission`] if called by non-owner
     * - [`Error::AccountNotFound`] if account does not exist for `user_id`
     * - [`Error::RuleSetNotFound`] if rule set does not exist for `rule_set_id`
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::RuleNotFound`] if rule does not exist for `rule_kind`
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('FuelTanks.remove_account_rule_data') === '73f11459363469dcd8d6653808d665b035e40c7f501c5c20f873dca721350eef'
    }

    /**
     * Remove account rule data if it exists. Only callable by the fuel tank's owner. Requires
     * the fuel tank or the rule set to be frozen.
     * 
     * ### Errors
     * 
     * - [`Error::FuelTankNotFound`] if fuel tank for `tank_id` doesn't exist
     * - [`Error::NoPermission`] if called by non-owner
     * - [`Error::AccountNotFound`] if account does not exist for `user_id`
     * - [`Error::RuleSetNotFound`] if rule set does not exist for `rule_set_id`
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::RuleNotFound`] if rule does not exist for `rule_kind`
     */
    get asV1021(): {tankId: v1021.MultiAddress, userId: v1021.MultiAddress, ruleSetId: number, ruleKind: v1021.DispatchRuleKind} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksRemoveRuleSetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.remove_rule_set')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove rule set for `tank_id` and `rule_set_id`. A rule that is storing data on
     * any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove the
     * data first. This is only callable by the fuel tank's owner.
     * # Errors
     * 
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.remove_rule_set') === 'f09ae45a5e0ac6e1a34b392a13e3d81deefc3581926451813030e95e15c397fb'
    }

    /**
     * Remove rule set for `tank_id` and `rule_set_id`. A rule that is storing data on
     * any accounts cannot be removed. Use [Self::remove_account_rule_data] to remove the
     * data first. This is only callable by the fuel tank's owner.
     * # Errors
     * 
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not the fuel tank owner
     * - [`Error::RequiresFrozenTankOrRuleset`] if tank or rule set is not frozen
     * - [`Error::CannotRemoveRuleThatIsStoringAccountData`] if removing a rule that is storing
     *   account data
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, ruleSetId: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class FuelTanksScheduleMutateFreezeStateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FuelTanks.schedule_mutate_freeze_state')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule mutating of `is_frozen` state that determines if fuel tank or rule set can be
     * used
     * 
     * Additional 1 read and 1 write are added to account for `on_finalize` storage operations
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not a fuel tank owner
     * - [`Error::FreezeQueueFull`] if the queue is full
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('FuelTanks.schedule_mutate_freeze_state') === '400d585823f6a5fce567d3e438bd1ddac0b7cc3662931a51424df14279fde426'
    }

    /**
     * Schedule mutating of `is_frozen` state that determines if fuel tank or rule set can be
     * used
     * 
     * Additional 1 read and 1 write are added to account for `on_finalize` storage operations
     * 
     * # Errors
     * - [`Error::FuelTankNotFound`] if `tank_id` does not exist.
     * - [`Error::NoPermission`] if caller is not a fuel tank owner
     * - [`Error::FreezeQueueFull`] if the queue is full
     */
    get asMatrixEnjinV603(): {tankId: matrixEnjinV603.MultiAddress, ruleSetId: (number | undefined), isFrozen: boolean} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class GrandpaNoteStalledCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Grandpa.note_stalled')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Note that the current authority set of the GRANDPA finality gadget has stalled.
     * 
     * This will trigger a forced authority set change at the beginning of the next session, to
     * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
     * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
     * The block production rate (which may be slowed down because of finality lagging) should
     * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
     * authority will start voting on top of `best_finalized_block_number` for new finalized
     * blocks. `best_finalized_block_number` should be the highest of the latest finalized
     * block of all validators of the new authority set.
     * 
     * Only callable by root.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Grandpa.note_stalled') === '6bb454c2ae9db6ee64dc7f433f0fd3b839727f70c6c835943383346896272c40'
    }

    /**
     * Note that the current authority set of the GRANDPA finality gadget has stalled.
     * 
     * This will trigger a forced authority set change at the beginning of the next session, to
     * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
     * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
     * The block production rate (which may be slowed down because of finality lagging) should
     * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
     * authority will start voting on top of `best_finalized_block_number` for new finalized
     * blocks. `best_finalized_block_number` should be the highest of the latest finalized
     * block of all validators of the new authority set.
     * 
     * Only callable by root.
     */
    get asV100(): {delay: number, bestFinalizedBlockNumber: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class GrandpaReportEquivocationCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Grandpa.report_equivocation')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Grandpa.report_equivocation') === 'c013519536bd18b242d3dd1699b5d15a8ae1fccf0dd04c12f721418f3b34a23b'
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     */
    get asV100(): {equivocationProof: v100.Type_335, keyOwnerProof: v100.Void} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Grandpa.report_equivocation') === '2c17e0cc8689d3a9ff22e793f8bfe646fd06a870bc9abcba005b8b772edc8677'
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     */
    get asV104(): {equivocationProof: v104.Type_374, keyOwnerProof: v104.MembershipProof} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }
}

export class GrandpaReportEquivocationUnsignedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Grandpa.report_equivocation_unsigned')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     * 
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Grandpa.report_equivocation_unsigned') === 'c013519536bd18b242d3dd1699b5d15a8ae1fccf0dd04c12f721418f3b34a23b'
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     * 
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get asV100(): {equivocationProof: v100.Type_335, keyOwnerProof: v100.Void} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     * 
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Grandpa.report_equivocation_unsigned') === '2c17e0cc8689d3a9ff22e793f8bfe646fd06a870bc9abcba005b8b772edc8677'
    }

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     * 
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get asV104(): {equivocationProof: v104.Type_374, keyOwnerProof: v104.MembershipProof} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpForceCleanHrmpCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.force_clean_hrmp')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * This extrinsic triggers the cleanup of all the HRMP storage items that
     * a para may have. Normally this happens once per session, but this allows
     * you to trigger the cleanup immediately for a specific parachain.
     * 
     * Origin must be Root.
     * 
     * Number of inbound and outbound channels for `para` must be provided as witness data of weighing.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Hrmp.force_clean_hrmp') === '6d445266a2edc9bbe1d2186a1974f7f3f588ab7369e71b81eff7ef89b2fd7a57'
    }

    /**
     * This extrinsic triggers the cleanup of all the HRMP storage items that
     * a para may have. Normally this happens once per session, but this allows
     * you to trigger the cleanup immediately for a specific parachain.
     * 
     * Origin must be Root.
     * 
     * Number of inbound and outbound channels for `para` must be provided as witness data of weighing.
     */
    get asV100(): {para: number, inbound: number, outbound: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpForceOpenHrmpChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.force_open_hrmp_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Open a channel from a `sender` to a `recipient` `ParaId` using the Root origin. Although
     * opened by Root, the `max_capacity` and `max_message_size` are still subject to the Relay
     * Chain's configured limits.
     * 
     * Expected use is when one of the `ParaId`s involved in the channel is governed by the
     * Relay Chain, e.g. a common good parachain.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Hrmp.force_open_hrmp_channel') === '1d371021acfdf0ba68e1334173a7b34a1c083269c2b7e3f6024692dbd7118650'
    }

    /**
     * Open a channel from a `sender` to a `recipient` `ParaId` using the Root origin. Although
     * opened by Root, the `max_capacity` and `max_message_size` are still subject to the Relay
     * Chain's configured limits.
     * 
     * Expected use is when one of the `ParaId`s involved in the channel is governed by the
     * Relay Chain, e.g. a common good parachain.
     */
    get asV100(): {sender: number, recipient: number, maxCapacity: number, maxMessageSize: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpForceProcessHrmpCloseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.force_process_hrmp_close')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force process HRMP close channel requests.
     * 
     * If there are pending HRMP close channel requests, you can use this
     * function process all of those requests immediately.
     * 
     * Total number of closing channels must be provided as witness data of weighing.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Hrmp.force_process_hrmp_close') === 'bbff5b4312625000db819c8e43a5a33d24b00331be3f9e0e32c792eca6dd854c'
    }

    /**
     * Force process HRMP close channel requests.
     * 
     * If there are pending HRMP close channel requests, you can use this
     * function process all of those requests immediately.
     * 
     * Total number of closing channels must be provided as witness data of weighing.
     */
    get asV100(): {channels: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpForceProcessHrmpOpenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.force_process_hrmp_open')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force process HRMP open channel requests.
     * 
     * If there are pending HRMP open channel requests, you can use this
     * function process all of those requests immediately.
     * 
     * Total number of opening channels must be provided as witness data of weighing.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Hrmp.force_process_hrmp_open') === 'bbff5b4312625000db819c8e43a5a33d24b00331be3f9e0e32c792eca6dd854c'
    }

    /**
     * Force process HRMP open channel requests.
     * 
     * If there are pending HRMP open channel requests, you can use this
     * function process all of those requests immediately.
     * 
     * Total number of opening channels must be provided as witness data of weighing.
     */
    get asV100(): {channels: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpHrmpAcceptOpenChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.hrmp_accept_open_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Accept a pending open channel request from the given sender.
     * 
     * The channel will be opened only on the next session boundary.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Hrmp.hrmp_accept_open_channel') === 'df73c5e1f40e14fb4e0ca9c4be4018d011ed0be4cb058df95899088220820d15'
    }

    /**
     * Accept a pending open channel request from the given sender.
     * 
     * The channel will be opened only on the next session boundary.
     */
    get asV100(): {sender: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpHrmpCancelOpenRequestCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.hrmp_cancel_open_request')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * This cancels a pending open channel request. It can be canceled by either of the sender
     * or the recipient for that request. The origin must be either of those.
     * 
     * The cancellation happens immediately. It is not possible to cancel the request if it is
     * already accepted.
     * 
     * Total number of open requests (i.e. `HrmpOpenChannelRequestsList`) must be provided as
     * witness data.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Hrmp.hrmp_cancel_open_request') === '1a7a633e43ca10d6015d9e560d206e2f2add06f22aae354dda82e8d74806ff9b'
    }

    /**
     * This cancels a pending open channel request. It can be canceled by either of the sender
     * or the recipient for that request. The origin must be either of those.
     * 
     * The cancellation happens immediately. It is not possible to cancel the request if it is
     * already accepted.
     * 
     * Total number of open requests (i.e. `HrmpOpenChannelRequestsList`) must be provided as
     * witness data.
     */
    get asV100(): {channelId: v100.HrmpChannelId, openRequests: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpHrmpCloseChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.hrmp_close_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Initiate unilateral closing of a channel. The origin must be either the sender or the
     * recipient in the channel being closed.
     * 
     * The closure can only happen on a session change.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Hrmp.hrmp_close_channel') === '275d8119c62cb1d6786e5fa90c24e50e47fd498185b8f9c73010e74bdbd984cd'
    }

    /**
     * Initiate unilateral closing of a channel. The origin must be either the sender or the
     * recipient in the channel being closed.
     * 
     * The closure can only happen on a session change.
     */
    get asV100(): {channelId: v100.HrmpChannelId} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpHrmpInitOpenChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.hrmp_init_open_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Initiate opening a channel from a parachain to a given recipient with given channel
     * parameters.
     * 
     * - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
     * - `proposed_max_message_size` - specifies the maximum size of the messages.
     * 
     * These numbers are a subject to the relay-chain configuration limits.
     * 
     * The channel can be opened only after the recipient confirms it and only on a session
     * change.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Hrmp.hrmp_init_open_channel') === 'c78d4e6da3f70d8bb4c2c00861e72fb4233df808203d0f148f572b5e16e04f71'
    }

    /**
     * Initiate opening a channel from a parachain to a given recipient with given channel
     * parameters.
     * 
     * - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
     * - `proposed_max_message_size` - specifies the maximum size of the messages.
     * 
     * These numbers are a subject to the relay-chain configuration limits.
     * 
     * The channel can be opened only after the recipient confirms it and only on a session
     * change.
     */
    get asV100(): {recipient: number, proposedMaxCapacity: number, proposedMaxMessageSize: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityAddRegistrarCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.add_registrar')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add a registrar to the system.
     * 
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     * 
     * - `account`: the account of the registrar.
     * 
     * Emits `RegistrarAdded` if successful.
     * 
     * ## Complexity
     * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.add_registrar') === '2842be90a4599435dbefe83c28be9576bf64e6ff14aa9fa87c5fdb6255ef27b2'
    }

    /**
     * Add a registrar to the system.
     * 
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     * 
     * - `account`: the account of the registrar.
     * 
     * Emits `RegistrarAdded` if successful.
     * 
     * ## Complexity
     * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
     */
    get asMatrixEnjinV1000(): {account: matrixEnjinV1000.MultiAddress} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityAddSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.add_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add the given account to the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.add_sub') === 'b7d02496580d984a1a588630bfbf580f423f08a761006f8706b057ac73069a38'
    }

    /**
     * Add the given account to the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get asMatrixEnjinV1000(): {sub: matrixEnjinV1000.MultiAddress, data: matrixEnjinV1000.Data} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityCancelRequestCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.cancel_request')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel a previous request.
     * 
     * Payment: A previously reserved deposit is returned on success.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     * 
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     * 
     * Emits `JudgementUnrequested` if successful.
     * 
     * ## Complexity
     * - `O(R + X)`.
     *   - where `R` registrar-count (governance-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.cancel_request') === '89d659d6a17ba36d0dfc7c90a7f043581d7fe980043895169d7dda1416ff7e5b'
    }

    /**
     * Cancel a previous request.
     * 
     * Payment: A previously reserved deposit is returned on success.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     * 
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     * 
     * Emits `JudgementUnrequested` if successful.
     * 
     * ## Complexity
     * - `O(R + X)`.
     *   - where `R` registrar-count (governance-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     */
    get asMatrixEnjinV1000(): {regIndex: number} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityClearIdentityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.clear_identity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     * 
     * Payment: All reserved balances on the account are returned.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     * 
     * Emits `IdentityCleared` if successful.
     * 
     * ## Complexity
     * - `O(R + S + X)`
     *   - where `R` registrar-count (governance-bounded).
     *   - where `S` subs-count (hard- and deposit-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.clear_identity') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     * 
     * Payment: All reserved balances on the account are returned.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     * 
     * Emits `IdentityCleared` if successful.
     * 
     * ## Complexity
     * - `O(R + S + X)`
     *   - where `R` registrar-count (governance-bounded).
     *   - where `S` subs-count (hard- and deposit-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     */
    get asMatrixEnjinV1000(): null {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityKillIdentityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.kill_identity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     * 
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     * 
     * The dispatch origin for this call must match `T::ForceOrigin`.
     * 
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * 
     * Emits `IdentityKilled` if successful.
     * 
     * ## Complexity
     * - `O(R + S + X)`
     *   - where `R` registrar-count (governance-bounded).
     *   - where `S` subs-count (hard- and deposit-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.kill_identity') === '8142da248a3023c20f65ce8f6287f9eaf75336ab8815cb15537149abcdd0c20c'
    }

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     * 
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     * 
     * The dispatch origin for this call must match `T::ForceOrigin`.
     * 
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * 
     * Emits `IdentityKilled` if successful.
     * 
     * ## Complexity
     * - `O(R + S + X)`
     *   - where `R` registrar-count (governance-bounded).
     *   - where `S` subs-count (hard- and deposit-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     */
    get asMatrixEnjinV1000(): {target: matrixEnjinV1000.MultiAddress} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityProvideJudgementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.provide_judgement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Provide a judgement for an account's identity.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     * 
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
     * 
     * Emits `JudgementGiven` if successful.
     * 
     * ## Complexity
     * - `O(R + X)`.
     *   - where `R` registrar-count (governance-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.provide_judgement') === '293a16f5e8f521553f92204e3de7063fafc7905d71ca7812337b8bc6e200bcf9'
    }

    /**
     * Provide a judgement for an account's identity.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     * 
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
     * 
     * Emits `JudgementGiven` if successful.
     * 
     * ## Complexity
     * - `O(R + X)`.
     *   - where `R` registrar-count (governance-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     */
    get asMatrixEnjinV1000(): {regIndex: number, target: matrixEnjinV1000.MultiAddress, judgement: matrixEnjinV1000.Judgement, identity: Uint8Array} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityQuitSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.quit_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the sender as a sub-account.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     * 
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.quit_sub') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Remove the sender as a sub-account.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     * 
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     */
    get asMatrixEnjinV1000(): null {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityRemoveSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.remove_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the given account from the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.remove_sub') === 'e2fd2e12228143db75d1c9482d7788894e6f224b6c362b650b73ac996f701805'
    }

    /**
     * Remove the given account from the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get asMatrixEnjinV1000(): {sub: matrixEnjinV1000.MultiAddress} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityRenameSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.rename_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Alter the associated name of the given sub-account.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.rename_sub') === 'b7d02496580d984a1a588630bfbf580f423f08a761006f8706b057ac73069a38'
    }

    /**
     * Alter the associated name of the given sub-account.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get asMatrixEnjinV1000(): {sub: matrixEnjinV1000.MultiAddress, data: matrixEnjinV1000.Data} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityRequestJudgementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.request_judgement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Request a judgement from a registrar.
     * 
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     * 
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     * 
     * ```nocompile
     * Self::registrars().get(reg_index).unwrap().fee
     * ```
     * 
     * Emits `JudgementRequested` if successful.
     * 
     * ## Complexity
     * - `O(R + X)`.
     *   - where `R` registrar-count (governance-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.request_judgement') === 'c6336282cbe5b8ccf3769cc13c92f532be2499335e3d52ebf566a888e92b5b7c'
    }

    /**
     * Request a judgement from a registrar.
     * 
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     * 
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     * 
     * ```nocompile
     * Self::registrars().get(reg_index).unwrap().fee
     * ```
     * 
     * Emits `JudgementRequested` if successful.
     * 
     * ## Complexity
     * - `O(R + X)`.
     *   - where `R` registrar-count (governance-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     */
    get asMatrixEnjinV1000(): {regIndex: number, maxFee: bigint} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetAccountIdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_account_id')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Change the account associated with a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     * 
     * ## Complexity
     * - `O(R)`.
     *   - where `R` registrar-count (governance-bounded).
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.set_account_id') === '7c569a09ae3438c742df387f66c9e012ebdf2af1dfe1befa9aba3df316cee1aa'
    }

    /**
     * Change the account associated with a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     * 
     * ## Complexity
     * - `O(R)`.
     *   - where `R` registrar-count (governance-bounded).
     */
    get asMatrixEnjinV1000(): {index: number, new: matrixEnjinV1000.MultiAddress} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     * 
     * ## Complexity
     * - `O(R)`.
     *   - where `R` registrar-count (governance-bounded).
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.set_fee') === '6418458414c3cef3d5c80c88232d781e76733c675303b2937b9cd30ae58d0fe4'
    }

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     * 
     * ## Complexity
     * - `O(R)`.
     *   - where `R` registrar-count (governance-bounded).
     */
    get asMatrixEnjinV1000(): {index: number, fee: bigint} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetFieldsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_fields')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the field information for a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     * 
     * ## Complexity
     * - `O(R)`.
     *   - where `R` registrar-count (governance-bounded).
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.set_fields') === 'b2c8998acd304e28e4f4a78e6a07f5bf7caf587532734dbd94b85c01a31c3e13'
    }

    /**
     * Set the field information for a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     * 
     * ## Complexity
     * - `O(R)`.
     *   - where `R` registrar-count (governance-bounded).
     */
    get asMatrixEnjinV1000(): {index: number, fields: bigint} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetIdentityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_identity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     * 
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `info`: The identity information.
     * 
     * Emits `IdentitySet` if successful.
     * 
     * ## Complexity
     * - `O(X + X' + R)`
     *   - where `X` additional-field-count (deposit-bounded and code-bounded)
     *   - where `R` judgements-count (registrar-count-bounded)
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.set_identity') === 'ab457704fd8cda5fee32e84ab7782778f4117cd54400c364cf7597eee5bc60ca'
    }

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     * 
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `info`: The identity information.
     * 
     * Emits `IdentitySet` if successful.
     * 
     * ## Complexity
     * - `O(X + X' + R)`
     *   - where `X` additional-field-count (deposit-bounded and code-bounded)
     *   - where `R` judgements-count (registrar-count-bounded)
     */
    get asMatrixEnjinV1000(): {info: matrixEnjinV1000.IdentityInfo} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetSubsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_subs')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the sub-accounts of the sender.
     * 
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     * 
     * - `subs`: The identity's (new) sub-accounts.
     * 
     * ## Complexity
     * - `O(P + S)`
     *   - where `P` old-subs-count (hard- and deposit-bounded).
     *   - where `S` subs-count (hard- and deposit-bounded).
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Identity.set_subs') === 'f156a100857e71b9e1eab839801795e8569b63b49f6c30333c5bf12811cbbe73'
    }

    /**
     * Set the sub-accounts of the sender.
     * 
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     * 
     * - `subs`: The identity's (new) sub-accounts.
     * 
     * ## Complexity
     * - `O(P + S)`
     *   - where `P` old-subs-count (hard- and deposit-bounded).
     *   - where `S` subs-count (hard- and deposit-bounded).
     */
    get asMatrixEnjinV1000(): {subs: [Uint8Array, matrixEnjinV1000.Data][]} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class ImOnlineHeartbeatCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ImOnline.heartbeat')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * # <weight>
     * - Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is
     *   length of `heartbeat.network_state.external_address`
     *   - `O(K)`: decoding of length `K`
     *   - `O(E)`: decoding/encoding of length `E`
     * - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,
     *   `ReceivedHeartbeats`
     * - DbWrites: `ReceivedHeartbeats`
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ImOnline.heartbeat') === 'ceb066f24cc1efdb862584018e591b1046da22acdc1c7daf8270a6f6f31baffe'
    }

    /**
     * # <weight>
     * - Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is
     *   length of `heartbeat.network_state.external_address`
     *   - `O(K)`: decoding of length `K`
     *   - `O(E)`: decoding/encoding of length `E`
     * - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,
     *   `ReceivedHeartbeats`
     * - DbWrites: `ReceivedHeartbeats`
     * # </weight>
     */
    get asV100(): {heartbeat: v100.Heartbeat, signature: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class InitializerForceApproveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Initializer.force_approve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Issue a signal to the consensus engine to forcibly act as though all parachain
     * blocks in all relay chain blocks up to and including the given number in the current
     * chain are valid and should be finalized.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Initializer.force_approve') === 'aa2b79ecc12cda7c6325357609f0dde737428c5b092dab0769d4e105b22bd955'
    }

    /**
     * Issue a signal to the consensus engine to forcibly act as though all parachain
     * blocks in all relay chain blocks up to and including the given number in the current
     * chain are valid and should be finalized.
     */
    get asV100(): {upTo: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class MarketplaceCancelListingCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Marketplace.cancel_listing')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancels the listing with `listing_id`. Only callable by the seller.
     * 
     * # Parameters
     * 
     * - `listing_id`: The ID of the listing to cancel
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::NoPermission`] if the listing seller is not the caller, `origin`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Marketplace.cancel_listing') === '56b483accb79407d2146b841c242046f1ff043c0a2fda9fb311497fdcd762679'
    }

    /**
     * Cancels the listing with `listing_id`. Only callable by the seller.
     * 
     * # Parameters
     * 
     * - `listing_id`: The ID of the listing to cancel
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::NoPermission`] if the listing seller is not the caller, `origin`
     */
    get asMatrixEnjinV603(): {listingId: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MarketplaceCreateListingCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Marketplace.create_listing')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     * 
     * # Parameters
     * 
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     * 
     * # Errors
     * 
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Marketplace.create_listing') === '78b7a393701f9f95d8413f0683f9a8071358025ff047a772b81cffc1c315d7b4'
    }

    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     * 
     * # Parameters
     * 
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     * 
     * # Errors
     * 
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    get asMatrixEnjinV603(): {makeAssetId: matrixEnjinV603.AssetId, takeAssetId: matrixEnjinV603.AssetId, amount: bigint, price: bigint, salt: Uint8Array, auctionData: (matrixEnjinV603.AuctionData | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MarketplaceFillListingCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Marketplace.fill_listing')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     * 
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::TakeValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Marketplace.fill_listing') === 'e370d131ef17581bf77299b58dd556c1a78d367f937bce7f44e290d100f7ed4d'
    }

    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     * 
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::TakeValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    get asMatrixEnjinV603(): {listingId: Uint8Array, amount: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MarketplaceFinalizeAuctionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Marketplace.finalize_auction')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over.
     * 
     * # Parameters
     * 
     * - `listing_id`: The ID for the listing to finalize
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::TakeValueUnderMinimum`] if the take value is less than the minimum required
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Marketplace.finalize_auction') === '56b483accb79407d2146b841c242046f1ff043c0a2fda9fb311497fdcd762679'
    }

    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over.
     * 
     * # Parameters
     * 
     * - `listing_id`: The ID for the listing to finalize
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::TakeValueUnderMinimum`] if the take value is less than the minimum required
     */
    get asMatrixEnjinV603(): {listingId: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MarketplaceForceCreateListingCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Marketplace.force_create_listing')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     * 
     * # Parameters
     * 
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     * 
     * # Errors
     * 
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Marketplace.force_create_listing') === '740d5c8aa6c755cb69b094d1cae70ff2f50500c1d18fd8c66c8e1fd05539a640'
    }

    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     * 
     * # Parameters
     * 
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     * 
     * # Errors
     * 
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    get asMatrixEnjinV603(): {seller: matrixEnjinV603.MultiAddress, makeAssetId: matrixEnjinV603.AssetId, takeAssetId: matrixEnjinV603.AssetId, amount: bigint, price: bigint, salt: Uint8Array, auctionData: (matrixEnjinV603.AuctionData | undefined), depositBacker: (matrixEnjinV603.MultiAddress | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MarketplaceForcePlaceBidCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Marketplace.force_place_bid')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Same as [create_listing](Self::place_bid), but allows specifying the `bidder` and can
     * place a bid in an inactive auction. Only callable by [`Config::ForceOrigin`]. If
     * `funds_backer` is `Some`, it will transfer balance if `bidder` does not have enough.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Marketplace.force_place_bid') === 'f038fdae96c9c9a8410db371543e140cca23088d4bf30a7098c7f7b58efc2ae5'
    }

    /**
     * Same as [create_listing](Self::place_bid), but allows specifying the `bidder` and can
     * place a bid in an inactive auction. Only callable by [`Config::ForceOrigin`]. If
     * `funds_backer` is `Some`, it will transfer balance if `bidder` does not have enough.
     */
    get asMatrixEnjinV603(): {bidder: matrixEnjinV603.MultiAddress, listingId: Uint8Array, price: bigint, fundsBacker: (matrixEnjinV603.MultiAddress | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MarketplacePlaceBidCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Marketplace.place_bid')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Places a bid on a listing. The listing must be an auction, and it must be currently
     * active.
     * 
     * # Parameters
     * 
     * - `listing_id`: The id for the listing to buy from
     * - `price`: The price for a single unit
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the bidder is the seller of the listing
     * - [`Error::InactiveAuction`] if listing operates outside of specified start and end
     *   block
     * - [`Error::InvalidPrice`] if price is less than minimum_price for a bid
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Marketplace.place_bid') === 'ef3821a4c9f8f54d06f376b33812844522af03669204d7f987e47edffe72dcf3'
    }

    /**
     * Places a bid on a listing. The listing must be an auction, and it must be currently
     * active.
     * 
     * # Parameters
     * 
     * - `listing_id`: The id for the listing to buy from
     * - `price`: The price for a single unit
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the bidder is the seller of the listing
     * - [`Error::InactiveAuction`] if listing operates outside of specified start and end
     *   block
     * - [`Error::InvalidPrice`] if price is less than minimum_price for a bid
     */
    get asMatrixEnjinV603(): {listingId: Uint8Array, price: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MarketplaceSetProtocolFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Marketplace.set_protocol_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Change the protocol fee to `protocol_fee`. Fails if `origin` is invalid.
     * 
     * #Parameters
     * 
     * - `protocol_fee`: Percentage of fee to set
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Marketplace.set_protocol_fee') === '164c71fe8ee3317ae364f8c5528ba44b7eddb84e7a9a394e59bb344ad0ec2293'
    }

    /**
     * Change the protocol fee to `protocol_fee`. Fails if `origin` is invalid.
     * 
     * #Parameters
     * 
     * - `protocol_fee`: Percentage of fee to set
     */
    get asMatrixEnjinV603(): {protocolFee: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MatrixUtilityBatchCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MatrixUtility.batch')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatch a batch of calls.
     * 
     * May be called from any origin except [`None`].
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing [`frame_system::Config::BaseCallFilter`]).
     * 
     * # Errors
     * 
     * - [`Error::TooManyCalls`]: If the number of calls exceeds the limit.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MatrixUtility.batch') === 'd62ee8112ec3c60241093b56ae224901f16f92caeeede499a20acae888ba7ab7'
    }

    /**
     * Dispatch a batch of calls.
     * 
     * May be called from any origin except [`None`].
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing [`frame_system::Config::BaseCallFilter`]).
     * 
     * # Errors
     * 
     * - [`Error::TooManyCalls`]: If the number of calls exceeds the limit.
     */
    get asMatrixEnjinV603(): {calls: matrixEnjinV603.Call[], continueOnFailure: boolean} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a batch of calls.
     * 
     * May be called from any origin except [`None`].
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing [`frame_system::Config::BaseCallFilter`]).
     * 
     * # Errors
     * 
     * - [`Error::TooManyCalls`]: If the number of calls exceeds the limit.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('MatrixUtility.batch') === '23e1d0c44dc6fefd566bf76e808f1efa03bf46b8a0a01e772a935c95b805d0c4'
    }

    /**
     * Dispatch a batch of calls.
     * 
     * May be called from any origin except [`None`].
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing [`frame_system::Config::BaseCallFilter`]).
     * 
     * # Errors
     * 
     * - [`Error::TooManyCalls`]: If the number of calls exceeds the limit.
     */
    get asMatrixEnjinV1000(): {calls: matrixEnjinV1000.Call[], continueOnFailure: boolean} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a batch of calls.
     * 
     * May be called from any origin except [`None`].
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing [`frame_system::Config::BaseCallFilter`]).
     * 
     * # Errors
     * 
     * - [`Error::TooManyCalls`]: If the number of calls exceeds the limit.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('MatrixUtility.batch') === 'cbf196d8ae488a10641203463a6e6089ac1f0b390593be56b3680556cce374d5'
    }

    /**
     * Dispatch a batch of calls.
     * 
     * May be called from any origin except [`None`].
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing [`frame_system::Config::BaseCallFilter`]).
     * 
     * # Errors
     * 
     * - [`Error::TooManyCalls`]: If the number of calls exceeds the limit.
     */
    get asMatrixEnjinV1003(): {calls: matrixEnjinV1003.Call[], continueOnFailure: boolean} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }
}

export class MatrixXcmForceSetMinimumWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MatrixXcm.force_set_minimum_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update xcm fees amount to be used in xcm.Withdraw message
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MatrixXcm.force_set_minimum_weight') === '4c92aee9cd2c92a06e50e7ae691000178c9980b7f9c4e035739e193479d9f615'
    }

    /**
     * Update xcm fees amount to be used in xcm.Withdraw message
     */
    get asMatrixEnjinV603(): {xcmCall: matrixEnjinV603.XcmOperation, xcmWeightFeeMisc: matrixEnjinV603.MinimumWeightFeePair} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MatrixXcmTransferAssetToParachainCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MatrixXcm.transfer_asset_to_parachain')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `origin` transfers `amount` of `asset` to `beneficiary` on the `parachain`
     * 
     * Note: `asset` needs to be registered as foreign token in destination parachain
     * 
     * - `para_id`: destination parachain
     * - `beneficiary`: account to receive `asset` in destination parachain
     * - `asset`: asset to transfer
     * - `amount`: amount of `asset` to transfer
     * - `dest_weight`: optional weight to be paid in destination chain, unlimited in case it's
     *   `None`
     * 
     * # Errors
     * 
     * - [`Error::InvalidAddress`]: `beneficiary` is invalid, i.e could not be converted to
     *   [`MultiLocation`]
     * - [`Error::NotTransferable`]: A corresponding multilocation could not be converted for
     *   the asset.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MatrixXcm.transfer_asset_to_parachain') === '6e0995af8a1271406f286250994b7e96ef4e950ec17addde0aa13d7dcf06db7e'
    }

    /**
     * `origin` transfers `amount` of `asset` to `beneficiary` on the `parachain`
     * 
     * Note: `asset` needs to be registered as foreign token in destination parachain
     * 
     * - `para_id`: destination parachain
     * - `beneficiary`: account to receive `asset` in destination parachain
     * - `asset`: asset to transfer
     * - `amount`: amount of `asset` to transfer
     * - `dest_weight`: optional weight to be paid in destination chain, unlimited in case it's
     *   `None`
     * 
     * # Errors
     * 
     * - [`Error::InvalidAddress`]: `beneficiary` is invalid, i.e could not be converted to
     *   [`MultiLocation`]
     * - [`Error::NotTransferable`]: A corresponding multilocation could not be converted for
     *   the asset.
     */
    get asMatrixEnjinV603(): {paraId: matrixEnjinV603.ParachainId, beneficiary: matrixEnjinV603.Account, currencyId: matrixEnjinV603.AssetId, amount: bigint, destWeight: (bigint | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MatrixXcmTransferAssetWithFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MatrixXcm.transfer_asset_with_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `origin` transfers `asset` to `beneficiary` at `parachain` using `fee_asset` for
     * the fee. This allows the transfer of custom assets like a non-fungible which
     * cannot be used to pay fees.
     * 
     * Note: each [`MultiAsset`] must be registered as a foreign asset at the destination
     * parachain.
     * 
     * - `asset`: asset to transfer
     * - `fee_asset`: asset to be used as fee
     * - `beneficiary`: account to receive `asset` in destination parachain
     * - `para_id`: destination parachain
     * - `dest_weight`: optional weight to be paid in destination chain, unlimited in case it's
     * 
     * # Errors
     * - [`Error::InvalidAddress`]: `beneficiary` is invalid, i.e could not be converted to
     *   [`MultiLocation`]
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MatrixXcm.transfer_asset_with_fee') === '253afe02afbaf582b39ed2b492eb0493066e690147b56578b4e8b20fb470b444'
    }

    /**
     * `origin` transfers `asset` to `beneficiary` at `parachain` using `fee_asset` for
     * the fee. This allows the transfer of custom assets like a non-fungible which
     * cannot be used to pay fees.
     * 
     * Note: each [`MultiAsset`] must be registered as a foreign asset at the destination
     * parachain.
     * 
     * - `asset`: asset to transfer
     * - `fee_asset`: asset to be used as fee
     * - `beneficiary`: account to receive `asset` in destination parachain
     * - `para_id`: destination parachain
     * - `dest_weight`: optional weight to be paid in destination chain, unlimited in case it's
     * 
     * # Errors
     * - [`Error::InvalidAddress`]: `beneficiary` is invalid, i.e could not be converted to
     *   [`MultiLocation`]
     */
    get asMatrixEnjinV603(): {assetPair: matrixEnjinV603.CurrencyIdAmountPair, feePair: matrixEnjinV603.CurrencyIdAmountPair, paraId: matrixEnjinV603.ParachainId, beneficiary: matrixEnjinV603.Account, destWeight: (bigint | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MatrixXcmTransferToParachainCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MatrixXcm.transfer_to_parachain')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `origin` transfers `amount` of EFI to `beneficiary` on the `parachain`
     * 
     * Note: EFI needs to be registered as foreign token in destination parachain
     * 
     * - `para_id`: destination parachain
     * - `beneficiary`: account to receive EFI in destination parachain
     * - `amount`: amount of EFI to transfer
     * - `dest_weight`: optional weight to be paid in destination chain, unlimited in case it's
     *   `None`
     * 
     * # Errors
     * 
     * - [`Error::InvalidAddress`]: `beneficiary` is invalid, i.e could not be converted to
     *   [`MultiLocation`]
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MatrixXcm.transfer_to_parachain') === 'b78bfbeb395c8dfe84788045085ed4230266e12ad40559a5ed1fdf518db02770'
    }

    /**
     * `origin` transfers `amount` of EFI to `beneficiary` on the `parachain`
     * 
     * Note: EFI needs to be registered as foreign token in destination parachain
     * 
     * - `para_id`: destination parachain
     * - `beneficiary`: account to receive EFI in destination parachain
     * - `amount`: amount of EFI to transfer
     * - `dest_weight`: optional weight to be paid in destination chain, unlimited in case it's
     *   `None`
     * 
     * # Errors
     * 
     * - [`Error::InvalidAddress`]: `beneficiary` is invalid, i.e could not be converted to
     *   [`MultiLocation`]
     */
    get asMatrixEnjinV603(): {paraId: matrixEnjinV603.ParachainId, beneficiary: matrixEnjinV603.Account, amount: bigint, destWeight: (bigint | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MessageQueueExecuteOverweightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MessageQueue.execute_overweight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Execute an overweight message.
     * 
     * Temporary processing errors will be propagated whereas permanent errors are treated
     * as success condition.
     * 
     * - `origin`: Must be `Signed`.
     * - `message_origin`: The origin from which the message to be executed arrived.
     * - `page`: The page in the queue in which the message to be executed is sitting.
     * - `index`: The index into the queue of the message to be executed.
     * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
     *   of the message.
     * 
     * Benchmark complexity considerations: O(index + weight_limit).
     */
    get isV105(): boolean {
        return this._chain.getCallHash('MessageQueue.execute_overweight') === '46d8a10105a905d92712a02d1910677d98c6b1ec62513f114b52e0d09a7cef49'
    }

    /**
     * Execute an overweight message.
     * 
     * Temporary processing errors will be propagated whereas permanent errors are treated
     * as success condition.
     * 
     * - `origin`: Must be `Signed`.
     * - `message_origin`: The origin from which the message to be executed arrived.
     * - `page`: The page in the queue in which the message to be executed is sitting.
     * - `index`: The index into the queue of the message to be executed.
     * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
     *   of the message.
     * 
     * Benchmark complexity considerations: O(index + weight_limit).
     */
    get asV105(): {messageOrigin: v105.AggregateMessageOrigin, page: number, index: number, weightLimit: v105.Weight} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }
}

export class MessageQueueReapPageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MessageQueue.reap_page')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a page which has no more messages remaining to be processed or is stale.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('MessageQueue.reap_page') === '424d00e6efeb4e7e95572098c7a493b4e070285ee05136974a240634b3741583'
    }

    /**
     * Remove a page which has no more messages remaining to be processed or is stale.
     */
    get asV105(): {messageOrigin: v105.AggregateMessageOrigin, pageIndex: number} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensApproveCollectionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.approve_collection')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Approve the `operator` to manage all of `origin`'s tokens belonging to `collection_id`.
     * If an `expiration` is provided, the approval will end when it expires.
     * 
     * # Errors
     * 
     * - [`Error::CannotApproveSelf`] if `origin == operator`
     * - [`Error::AlreadyExpired`] if `expiration` is earlier than now
     * - [`Error::CollectionAccountNotFound`] if the collection account does not exist
     * - [`Error::MaxApprovalsExceeded`] if approval count has exceeded the maximum
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.approve_collection') === '488accbd8a7ccff93c1ce6b5609ef67874c52cc8fc80b3b48a2cad226450c092'
    }

    /**
     * Approve the `operator` to manage all of `origin`'s tokens belonging to `collection_id`.
     * If an `expiration` is provided, the approval will end when it expires.
     * 
     * # Errors
     * 
     * - [`Error::CannotApproveSelf`] if `origin == operator`
     * - [`Error::AlreadyExpired`] if `expiration` is earlier than now
     * - [`Error::CollectionAccountNotFound`] if the collection account does not exist
     * - [`Error::MaxApprovalsExceeded`] if approval count has exceeded the maximum
     */
    get asMatrixEnjinV603(): {collectionId: bigint, operator: Uint8Array, expiration: (number | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensApproveTokenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.approve_token')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Approve `operator` to transfer up to `amount` of `caller`'s balance for `token_id` of
     * `collection_id`. An `expiration` can be provided. `current_amount` must match the
     * current approved amount.
     * 
     * # Errors
     * - [`Error::CannotApproveSelf`] if `origin == operator`
     * - [`Error::CollectionAlreadyApproved`] if `collection_id` is already approved
     * - [`Error::AlreadyExpired`] if `expiration` is earlier than now
     * - [`Error::TokenAccountNotFound`] if the token account does not exist
     * - [`Error::MaxApprovalsExceeded`] if approval count has exceeded the maximum
     * - [`Error::WrongCurrentApprovedAmount`] if `current_amount` does not match the current
     *   approval amount
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.approve_token') === '7266369f860222731cfac3b4dc9f7b3eb8550de09ee165a184b933efc53cd27a'
    }

    /**
     * Approve `operator` to transfer up to `amount` of `caller`'s balance for `token_id` of
     * `collection_id`. An `expiration` can be provided. `current_amount` must match the
     * current approved amount.
     * 
     * # Errors
     * - [`Error::CannotApproveSelf`] if `origin == operator`
     * - [`Error::CollectionAlreadyApproved`] if `collection_id` is already approved
     * - [`Error::AlreadyExpired`] if `expiration` is earlier than now
     * - [`Error::TokenAccountNotFound`] if the token account does not exist
     * - [`Error::MaxApprovalsExceeded`] if approval count has exceeded the maximum
     * - [`Error::WrongCurrentApprovedAmount`] if `current_amount` does not match the current
     *   approval amount
     */
    get asMatrixEnjinV603(): {collectionId: bigint, tokenId: bigint, operator: Uint8Array, amount: bigint, expiration: (number | undefined), currentAmount: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensBatchMintCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.batch_mint')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Collection owner mints tokens of `collection_id` to `recipients` consisting of an
     * [`AccountId`](frame_system::Config::AccountId) and [`MintParams`]. A single mint failure
     * will fail all of them in the batch.
     * 
     * # Errors
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `collection` does **not** exist.
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - [`Error::MaxTokenCountExceeded`] if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficient balance for
     *   token deposit
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.batch_mint') === 'a16058ed34379e8771cf8a93bddd3cb8d2085ccd127fa7774deb7e52dcd8575d'
    }

    /**
     * Collection owner mints tokens of `collection_id` to `recipients` consisting of an
     * [`AccountId`](frame_system::Config::AccountId) and [`MintParams`]. A single mint failure
     * will fail all of them in the batch.
     * 
     * # Errors
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `collection` does **not** exist.
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - [`Error::MaxTokenCountExceeded`] if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficient balance for
     *   token deposit
     */
    get asMatrixEnjinV603(): {collectionId: bigint, recipients: matrixEnjinV603.Type_395[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Collection owner mints tokens of `collection_id` to `recipients` consisting of an
     * [`AccountId`](frame_system::Config::AccountId) and [`MintParams`]. A single mint failure
     * will fail all of them in the batch.
     * 
     * # Errors
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `collection` does **not** exist.
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - [`Error::MaxTokenCountExceeded`] if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficent balance for
     *   token deposit
     */
    get isV100(): boolean {
        return this._chain.getCallHash('MultiTokens.batch_mint') === '29da27258672c2da5f2de8b8556bdcc1d50aabfa348c95bc373b6e0ab30fc41d'
    }

    /**
     * Collection owner mints tokens of `collection_id` to `recipients` consisting of an
     * [`AccountId`](frame_system::Config::AccountId) and [`MintParams`]. A single mint failure
     * will fail all of them in the batch.
     * 
     * # Errors
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `collection` does **not** exist.
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - [`Error::MaxTokenCountExceeded`] if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficent balance for
     *   token deposit
     */
    get asV100(): {collectionId: bigint, recipients: v100.Type_469[]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Collection owner mints tokens of `collection_id` to `recipients` consisting of an
     * [`AccountId`](frame_system::Config::AccountId) and [`MintParams`]. A single mint failure
     * will fail all of them in the batch.
     * 
     * # Errors
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `collection` does **not** exist.
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - [`Error::MaxTokenCountExceeded`] if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficent balance for
     *   token deposit
     */
    get isV102(): boolean {
        return this._chain.getCallHash('MultiTokens.batch_mint') === 'a16058ed34379e8771cf8a93bddd3cb8d2085ccd127fa7774deb7e52dcd8575d'
    }

    /**
     * Collection owner mints tokens of `collection_id` to `recipients` consisting of an
     * [`AccountId`](frame_system::Config::AccountId) and [`MintParams`]. A single mint failure
     * will fail all of them in the batch.
     * 
     * # Errors
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `collection` does **not** exist.
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - [`Error::MaxTokenCountExceeded`] if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficent balance for
     *   token deposit
     */
    get asV102(): {collectionId: bigint, recipients: v102.Type_513[]} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensBatchSetAttributeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.batch_set_attribute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Collection owner sets `attributes` to `collection_id`
     * 
     * If `token_id` is [`None`], the attribute is added to the collection. If it is [`Some`],
     * the attribute is added to the token.
     * 
     * # Errors
     * 
     * - [`Error::InvalidAttributeKey`] if `key.len() == 0`
     * - [`Error::CollectionNotFound`] if `collection_id` does not exist.
     * - [`Error::TokenNotFound`] if `token_id` is `Some` and does not exist.
     * - [`Error::NoPermission`] if `source` account is not the owner of the collection.
     * - [`Error::DepositReserveFailed`] if unable to reserve the deposit for the attribute
     *   storage.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.batch_set_attribute') === '4cfb7f21da2d822f4ecafcb406f87d73d214d01ed04db425fb85b84a776512f4'
    }

    /**
     * Collection owner sets `attributes` to `collection_id`
     * 
     * If `token_id` is [`None`], the attribute is added to the collection. If it is [`Some`],
     * the attribute is added to the token.
     * 
     * # Errors
     * 
     * - [`Error::InvalidAttributeKey`] if `key.len() == 0`
     * - [`Error::CollectionNotFound`] if `collection_id` does not exist.
     * - [`Error::TokenNotFound`] if `token_id` is `Some` and does not exist.
     * - [`Error::NoPermission`] if `source` account is not the owner of the collection.
     * - [`Error::DepositReserveFailed`] if unable to reserve the deposit for the attribute
     *   storage.
     */
    get asMatrixEnjinV603(): {collectionId: bigint, tokenId: (bigint | undefined), attributes: matrixEnjinV603.AttributeKeyValuePair[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensBatchTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.batch_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfers the specific amount of tokens of `collection` to `recipients` from `origin`
     * account. A single failure will fail all transfers.
     * 
     * # Errors
     * 
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::BalanceLow`] if `source` does not own enough amount of `collection`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.batch_transfer') === 'b19d3917f5096e2cef3e73752e8a3bd0b5e30cadfc6a4ff16c68ce84082c1ce5'
    }

    /**
     * Transfers the specific amount of tokens of `collection` to `recipients` from `origin`
     * account. A single failure will fail all transfers.
     * 
     * # Errors
     * 
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::BalanceLow`] if `source` does not own enough amount of `collection`.
     */
    get asMatrixEnjinV603(): {collectionId: bigint, recipients: matrixEnjinV603.Recipient[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensBurnCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.burn')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Reduces the balance of `owner` by `amount` of `token_id` from `collection_id`.
     * It also updates the total supply of `collection_id`.
     * 
     * # Errors
     * - [`Error::CollectionNotFound`] if `collection` does not exist.
     * - [`Error::BalanceLow`] if `owner` account does not has enough amount of any token in
     *   `tokens` of `collection`.
     * - [`Error::DepositUnreserveFailed`] if caller does not have enough reserved balance to
     *   unreserve
     * - [`Error::DestroyForbiddenByAttributeCount`] if removing token from storage but the
     *   attribute count is greater than zero
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.burn') === '5e518fd41f2e62474b4a1bae295d7c2b0bec3f70f20ccbfeb4517ee9e7984bc3'
    }

    /**
     * Reduces the balance of `owner` by `amount` of `token_id` from `collection_id`.
     * It also updates the total supply of `collection_id`.
     * 
     * # Errors
     * - [`Error::CollectionNotFound`] if `collection` does not exist.
     * - [`Error::BalanceLow`] if `owner` account does not has enough amount of any token in
     *   `tokens` of `collection`.
     * - [`Error::DepositUnreserveFailed`] if caller does not have enough reserved balance to
     *   unreserve
     * - [`Error::DestroyForbiddenByAttributeCount`] if removing token from storage but the
     *   attribute count is greater than zero
     */
    get asMatrixEnjinV603(): {collectionId: bigint, params: matrixEnjinV603.DefaultBurnParams} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensClaimCollectionsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.claim_collections')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfers ownership of collections to `destination` if the signature matches.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address) with nonce:{nonce}
     * 
     * and `address` matches the `destination` account. The nonce must also match.
     * 
     * This will always execute with weight of [`Config::MaxClaimableCollectionsPerAccount`]
     * and it will reimburse weight for collections under that number.
     * 
     * ### Parameters:
     * - `destination`: The account that will receive ownership of the collections
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address` : The Ethereum address from which the message is signed.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.claim_collections') === 'c2c9b14cf1920e63e88bb0ed4e4d7d24b7214a83d084075fadcc9df9fa04f151'
    }

    /**
     * Transfers ownership of collections to `destination` if the signature matches.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address) with nonce:{nonce}
     * 
     * and `address` matches the `destination` account. The nonce must also match.
     * 
     * This will always execute with weight of [`Config::MaxClaimableCollectionsPerAccount`]
     * and it will reimburse weight for collections under that number.
     * 
     * ### Parameters:
     * - `destination`: The account that will receive ownership of the collections
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address` : The Ethereum address from which the message is signed.
     */
    get asMatrixEnjinV603(): {destination: Uint8Array, ethereumSignature: Uint8Array, ethereumAddress: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfers ownership of collections to `destination` if the signature and
     * `collection_count` matches.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)
     * 
     * and `address` matches the `destination` account.
     * 
     * This will always execute with weight of [`Config::MaxClaimableCollectionsPerAccount`]
     * and it will reimburse weight for collections under that number.
     * 
     * ### Parameters:
     * - `destination`: The account that will receive ownership of the collections
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address`: The Ethereum address from which the message is signed.
     * - `collection_count`: The number of collections that will be claimed. It can also be
     *   higher than the actual number, but if it's lower it will fail.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('MultiTokens.claim_collections') === '1bb643643b1ec60049721f86e49d9cb8b2a620ba60b14cdc22f7dcf5b0746b99'
    }

    /**
     * Transfers ownership of collections to `destination` if the signature and
     * `collection_count` matches.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)
     * 
     * and `address` matches the `destination` account.
     * 
     * This will always execute with weight of [`Config::MaxClaimableCollectionsPerAccount`]
     * and it will reimburse weight for collections under that number.
     * 
     * ### Parameters:
     * - `destination`: The account that will receive ownership of the collections
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address`: The Ethereum address from which the message is signed.
     * - `collection_count`: The number of collections that will be claimed. It can also be
     *   higher than the actual number, but if it's lower it will fail.
     */
    get asMatrixEnjinV1000(): {destination: Uint8Array, ethereumSignature: Uint8Array, ethereumAddress: Uint8Array, collectionCount: number} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfers ownership of collections to `destination` if the signature matches.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address) with nonce:{nonce}
     * 
     * and `address` matches the `destination` account. The nonce must also match.
     * 
     * This will always execute with weight of [`Config::MaxClaimableCollectionsPerAccount`]
     * and it will reimburse weight for collections under that number.
     * 
     * ### Parameters:
     * - `destination`: The account that will receive ownership of the collections
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address` : The Ethereum address from which the message is signed.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('MultiTokens.claim_collections') === 'c2c9b14cf1920e63e88bb0ed4e4d7d24b7214a83d084075fadcc9df9fa04f151'
    }

    /**
     * Transfers ownership of collections to `destination` if the signature matches.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address) with nonce:{nonce}
     * 
     * and `address` matches the `destination` account. The nonce must also match.
     * 
     * This will always execute with weight of [`Config::MaxClaimableCollectionsPerAccount`]
     * and it will reimburse weight for collections under that number.
     * 
     * ### Parameters:
     * - `destination`: The account that will receive ownership of the collections
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address` : The Ethereum address from which the message is signed.
     */
    get asV106(): {destination: Uint8Array, ethereumSignature: Uint8Array, ethereumAddress: Uint8Array} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfers ownership of collections to `destination` if the signature and
     * `collection_count` matches.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)
     * 
     * and `address` matches the `destination` account.
     * 
     * This will always execute with weight of [`Config::MaxClaimableCollectionsPerAccount`]
     * and it will reimburse weight for collections under that number.
     * 
     * ### Parameters:
     * - `destination`: The account that will receive ownership of the collections
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address`: The Ethereum address from which the message is signed.
     * - `collection_count`: The number of collections that will be claimed. It can also be
     *   higher than the actual number, but if it's lower it will fail.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('MultiTokens.claim_collections') === '1bb643643b1ec60049721f86e49d9cb8b2a620ba60b14cdc22f7dcf5b0746b99'
    }

    /**
     * Transfers ownership of collections to `destination` if the signature and
     * `collection_count` matches.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)
     * 
     * and `address` matches the `destination` account.
     * 
     * This will always execute with weight of [`Config::MaxClaimableCollectionsPerAccount`]
     * and it will reimburse weight for collections under that number.
     * 
     * ### Parameters:
     * - `destination`: The account that will receive ownership of the collections
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address`: The Ethereum address from which the message is signed.
     * - `collection_count`: The number of collections that will be claimed. It can also be
     *   higher than the actual number, but if it's lower it will fail.
     */
    get asV1021(): {destination: Uint8Array, ethereumSignature: Uint8Array, ethereumAddress: Uint8Array, collectionCount: number} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensClaimTokensCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.claim_tokens')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfers balances of tokens to `destination` if the signature matches. Mints tokens if
     * needed.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address) with nonce:{nonce}
     * 
     * and `address` matches the `destination` account. The nonce must also match.
     * 
     * This will always execute with weight of [`Config::MaxClaimableTokensPerCall`]
     * and it will reimburse weight for tokens under that number.
     * 
     * ### Parameters:
     * - `destination`: The account that will receive token balances
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address` : The Ethereum address from which the message is signed.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.claim_tokens') === 'c2c9b14cf1920e63e88bb0ed4e4d7d24b7214a83d084075fadcc9df9fa04f151'
    }

    /**
     * Transfers balances of tokens to `destination` if the signature matches. Mints tokens if
     * needed.
     * 
     * The dispatch origin for this call must be _None_.
     * 
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     * 
     * > Ethereum Signed Message:
     * > (configured prefix string)(address) with nonce:{nonce}
     * 
     * and `address` matches the `destination` account. The nonce must also match.
     * 
     * This will always execute with weight of [`Config::MaxClaimableTokensPerCall`]
     * and it will reimburse weight for tokens under that number.
     * 
     * ### Parameters:
     * - `destination`: The account that will receive token balances
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     *   described above.
     * - `ethereum_address` : The Ethereum address from which the message is signed.
     */
    get asMatrixEnjinV603(): {destination: Uint8Array, ethereumSignature: Uint8Array, ethereumAddress: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensCreateCollectionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.create_collection')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Creates a new [`Collection`](ep_multi_tokens::Collection) from `descriptor`
     * 
     * # Errors
     * 
     * - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.create_collection') === '2c5ffb5fc94633dce91583fb29da64fdda08ce309e89734aab20a62a8cbb3250'
    }

    /**
     * Creates a new [`Collection`](ep_multi_tokens::Collection) from `descriptor`
     * 
     * # Errors
     * 
     * - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
     */
    get asMatrixEnjinV603(): {descriptor: matrixEnjinV603.DefaultCollectionDescriptor} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensDestroyCollectionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.destroy_collection')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Destroys [`Collection`](ep_multi_tokens::Collection) with `id`. `origin` must be the
     * owner of the [`Collection`](ep_multi_tokens::Collection).
     * 
     * # Errors
     * 
     * - [`Error::NoPermission`] if `origin` is not the owner of the collection.
     * - [`Error::CollectionNotFound`] if `Collection` with `id` does not exist.
     * - [`Error::DestroyForbiddenByCollectionEvent`] if another pallet is blocking the
     *   collection's destruction
     * - [`Error::DestroyForbiddenByRemainingTokens`] if collection still has tokens when
     *   destroying
     * - [`Error::DestroyForbiddenByAttributeCount`] if collection still has attributes when
     *   destroying
     * current number of collection attributes.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.destroy_collection') === '5213672185bfcdfd14c0e7c97d6a1d1c6244ef0903db4317a9b0bd4a1ab10375'
    }

    /**
     * Destroys [`Collection`](ep_multi_tokens::Collection) with `id`. `origin` must be the
     * owner of the [`Collection`](ep_multi_tokens::Collection).
     * 
     * # Errors
     * 
     * - [`Error::NoPermission`] if `origin` is not the owner of the collection.
     * - [`Error::CollectionNotFound`] if `Collection` with `id` does not exist.
     * - [`Error::DestroyForbiddenByCollectionEvent`] if another pallet is blocking the
     *   collection's destruction
     * - [`Error::DestroyForbiddenByRemainingTokens`] if collection still has tokens when
     *   destroying
     * - [`Error::DestroyForbiddenByAttributeCount`] if collection still has attributes when
     *   destroying
     * current number of collection attributes.
     */
    get asMatrixEnjinV603(): {collectionId: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensFinishClaimTokensCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.finish_claim_tokens')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sends an event that signifies claiming the tokens was completed. Only callable by
     * [`Config::EthereumMigrationOrigin`].
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('MultiTokens.finish_claim_tokens') === 'e963b546ce52b3e105e5a29f2e7743ca6496e8a40e036e98f057e74fa36bca75'
    }

    /**
     * Sends an event that signifies claiming the tokens was completed. Only callable by
     * [`Config::EthereumMigrationOrigin`].
     */
    get asMatrixEnjinV1000(): {destination: Uint8Array, ethereumAddress: Uint8Array} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceApproveCollectionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_approve_collection')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Same as [`approve_collection`](Self::approve_collection), but it is callable by
     * [`Config::ForceOrigin`].
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_approve_collection') === 'f65c0957959ad4ec841c3b60acfb570fb88ffcd77dcd55ff3a2274029b09f9a1'
    }

    /**
     * Same as [`approve_collection`](Self::approve_collection), but it is callable by
     * [`Config::ForceOrigin`].
     */
    get asMatrixEnjinV603(): {caller: matrixEnjinV603.MultiAddress, collectionId: bigint, operator: Uint8Array, expiration: (number | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceBurnCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_burn')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Same as [`burn`](Self::burn), but it is only callable by
     * [`Config::ForceOrigin`]. Executes the burn by `caller`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_burn') === '7a5ae3200088a96708870831e59af4cf200480d821ce966c8b150a4623315305'
    }

    /**
     * Same as [`burn`](Self::burn), but it is only callable by
     * [`Config::ForceOrigin`]. Executes the burn by `caller`.
     */
    get asMatrixEnjinV603(): {caller: matrixEnjinV603.MultiAddress, collectionId: bigint, params: matrixEnjinV603.DefaultBurnParams} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceCreateCollectionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_create_collection')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Creates a new collection from `descriptor` at `collection_id`, origin must be root
     * 
     * # Errors
     * - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
     * - [`Error::CollectionIdAlreadyInUse`] if the collection id is already in use
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_create_collection') === '64f054ecc6931474221d23bfcfed0b8f345cfbdab3115fd062d513a374ecf698'
    }

    /**
     * Creates a new collection from `descriptor` at `collection_id`, origin must be root
     * 
     * # Errors
     * - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
     * - [`Error::CollectionIdAlreadyInUse`] if the collection id is already in use
     */
    get asMatrixEnjinV603(): {owner: Uint8Array, collectionId: bigint, descriptor: matrixEnjinV603.DefaultCollectionDescriptor} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceCreateEthereumCollectionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_create_ethereum_collection')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Creates a new collection from `descriptor` at `collection_id`, origin must be
     * [`Config::EthereumMigrationOrigin`]. It differs from `force_create_collection`
     * since it writes to `NativeCollectionIds` and `ClaimableCollectionIds`.
     * 
     * # Params
     * - `owner` - the account that will own the new collection
     * - `claimer` - the ethereum address that will be able to claim the collection
     * - `ethereum_collection_id` - the collection id on ethereum
     * 
     * # Errors
     * - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
     * - [`Error::CollectionIdAlreadyInUse`] if the collection id is already in use
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('MultiTokens.force_create_ethereum_collection') === 'e0b68803545526e7819b718982de46e39b26d56c26ea0debdb7b2d4189045018'
    }

    /**
     * Creates a new collection from `descriptor` at `collection_id`, origin must be
     * [`Config::EthereumMigrationOrigin`]. It differs from `force_create_collection`
     * since it writes to `NativeCollectionIds` and `ClaimableCollectionIds`.
     * 
     * # Params
     * - `owner` - the account that will own the new collection
     * - `claimer` - the ethereum address that will be able to claim the collection
     * - `ethereum_collection_id` - the collection id on ethereum
     * 
     * # Errors
     * - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
     * - [`Error::CollectionIdAlreadyInUse`] if the collection id is already in use
     */
    get asMatrixEnjinV1000(): {owner: Uint8Array, claimer: Uint8Array, ethereumCollectionId: bigint, descriptor: matrixEnjinV1000.DefaultCollectionDescriptor} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a new collection from `descriptor` at `collection_id`, origin must be root
     * It differes from `force_create_collection` since it writes to NativeCollectionId and
     * UnmintableTokenIds
     * 
     * # Errors
     * - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
     * - [`Error::CollectionIdAlreadyInUse`] if the collection id is already in use
     */
    get isV120(): boolean {
        return this._chain.getCallHash('MultiTokens.force_create_ethereum_collection') === '826f84c716db6184e8d2335e0663f4d8137f4072d69fbb6b8b79762c18ab1f36'
    }

    /**
     * Creates a new collection from `descriptor` at `collection_id`, origin must be root
     * It differes from `force_create_collection` since it writes to NativeCollectionId and
     * UnmintableTokenIds
     * 
     * # Errors
     * - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
     * - [`Error::CollectionIdAlreadyInUse`] if the collection id is already in use
     */
    get asV120(): {owner: Uint8Array, nativeCollectionId: bigint, ethereumCollectionId: bigint, tokenRange: v120.RangeInclusive, descriptor: v120.DefaultCollectionDescriptor} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Creates a new collection from `descriptor` at `collection_id`, origin must be
     * [`Config::EthereumMigrationOrigin`]. It differs from `force_create_collection`
     * since it writes to `NativeCollectionIds` and `ClaimableCollectionIds`.
     * 
     * # Params
     * - `owner` - the account that will own the new collection
     * - `claimer` - the ethereum address that will be able to claim the collection
     * - `ethereum_collection_id` - the collection id on ethereum
     * 
     * # Errors
     * - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
     * - [`Error::CollectionIdAlreadyInUse`] if the collection id is already in use
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('MultiTokens.force_create_ethereum_collection') === 'e0b68803545526e7819b718982de46e39b26d56c26ea0debdb7b2d4189045018'
    }

    /**
     * Creates a new collection from `descriptor` at `collection_id`, origin must be
     * [`Config::EthereumMigrationOrigin`]. It differs from `force_create_collection`
     * since it writes to `NativeCollectionIds` and `ClaimableCollectionIds`.
     * 
     * # Params
     * - `owner` - the account that will own the new collection
     * - `claimer` - the ethereum address that will be able to claim the collection
     * - `ethereum_collection_id` - the collection id on ethereum
     * 
     * # Errors
     * - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
     * - [`Error::CollectionIdAlreadyInUse`] if the collection id is already in use
     */
    get asV1021(): {owner: Uint8Array, claimer: Uint8Array, ethereumCollectionId: bigint, descriptor: v1021.DefaultCollectionDescriptor} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceFreezeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_freeze')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Same as [`freeze`](Self::freeze), but it is callable by [`Config::ForceOrigin`]
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_freeze') === '91882af67a1b185551af07d0e9518d72ab08e8c353579842070f87fc1e425820'
    }

    /**
     * Same as [`freeze`](Self::freeze), but it is callable by [`Config::ForceOrigin`]
     */
    get asMatrixEnjinV603(): {info: matrixEnjinV603.Freeze} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceMintCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_mint')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Same as [`mint`](Self::mint), but it is callable by
     * [`Config::ForceOrigin`].
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_mint') === '6cf5f25d480cadca047bd92075c889f51eadee05fb17808aab0dbf485d3bcd38'
    }

    /**
     * Same as [`mint`](Self::mint), but it is callable by
     * [`Config::ForceOrigin`].
     */
    get asMatrixEnjinV603(): {caller: matrixEnjinV603.MultiAddress, recipient: matrixEnjinV603.MultiAddress, collectionId: bigint, params: matrixEnjinV603.DefaultMintParams, depositBacker: (matrixEnjinV603.MultiAddress | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [`mint`](Self::mint), but it is callable by
     * [`Config::EthereumMigrationOrigin`]. If `caller` is None, it will use the collection
     * owner. If `depositor` is `Some`, they will pay the deposit for minting.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('MultiTokens.force_mint') === '2f7b04c898012e70b44c3bd6644576e341733b54a7d1c169fe60ae594e72ad1a'
    }

    /**
     * Same as [`mint`](Self::mint), but it is callable by
     * [`Config::EthereumMigrationOrigin`]. If `caller` is None, it will use the collection
     * owner. If `depositor` is `Some`, they will pay the deposit for minting.
     */
    get asMatrixEnjinV1003(): {caller: (matrixEnjinV1003.MultiAddress | undefined), recipient: matrixEnjinV1003.MultiAddress, collectionId: bigint, params: matrixEnjinV1003.FlexibleMintParams, depositor: (matrixEnjinV1003.MultiAddress | undefined)} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [`mint`](Self::mint), but it is callable by
     * [`Config::ForceOrigin`].
     */
    get isV105(): boolean {
        return this._chain.getCallHash('MultiTokens.force_mint') === '6cf5f25d480cadca047bd92075c889f51eadee05fb17808aab0dbf485d3bcd38'
    }

    /**
     * Same as [`mint`](Self::mint), but it is callable by
     * [`Config::ForceOrigin`].
     */
    get asV105(): {caller: v105.MultiAddress, recipient: v105.MultiAddress, collectionId: bigint, params: v105.DefaultMintParams, depositBacker: (v105.MultiAddress | undefined)} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as [`mint`](Self::mint), but it is callable by
     * [`Config::EthereumMigrationOrigin`]. If `caller` is None, it will use the collection
     * owner. If `depositor` is `Some`, they will pay the deposit for minting.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('MultiTokens.force_mint') === '2f7b04c898012e70b44c3bd6644576e341733b54a7d1c169fe60ae594e72ad1a'
    }

    /**
     * Same as [`mint`](Self::mint), but it is callable by
     * [`Config::EthereumMigrationOrigin`]. If `caller` is None, it will use the collection
     * owner. If `depositor` is `Some`, they will pay the deposit for minting.
     */
    get asV1023(): {caller: (v1023.MultiAddress | undefined), recipient: v1023.MultiAddress, collectionId: bigint, params: v1023.FlexibleMintParams, depositor: (v1023.MultiAddress | undefined)} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceMutateCollectionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_mutate_collection')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Exactly as [`mutate_collection`](Self::mutate_collection), except the origin must be
     * root and the `caller` account should be specified.
     * 
     * # Errors
     * 
     * Same as [`mutate_collection`](Self::mutate_collection)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_mutate_collection') === '14654b078d9899c1c298781a09e325690f44d4eb607d8c69ff2f94e1c6b31069'
    }

    /**
     * Exactly as [`mutate_collection`](Self::mutate_collection), except the origin must be
     * root and the `caller` account should be specified.
     * 
     * # Errors
     * 
     * Same as [`mutate_collection`](Self::mutate_collection)
     */
    get asMatrixEnjinV603(): {collectionId: bigint, mutation: matrixEnjinV603.DefaultCollectionMutation} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceSetAttributeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_set_attribute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the Tokens storage to the given `value`, origin must be root
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_attribute') === '0c376373bedc267e8526ef4acf5c6c81f9faf25c7d1d5e610d39748132d3507f'
    }

    /**
     * Set the Tokens storage to the given `value`, origin must be root
     */
    get asMatrixEnjinV603(): {collectionId: bigint, tokenId: (bigint | undefined), key: Uint8Array, value: (matrixEnjinV603.Attribute | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceSetCollectionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_set_collection')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the Collections storage to the given `value`, origin must be root
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_collection') === 'd75af3c3c47bd7f1909045c69b61ffb4bbd68459ef76923bcdbd9203caeb90d5'
    }

    /**
     * Set the Collections storage to the given `value`, origin must be root
     */
    get asMatrixEnjinV603(): {collectionId: bigint, value: (matrixEnjinV603.Collection | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceSetCollectionAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_set_collection_account')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the CollectionAccounts storage to the given `value`, origin must be root
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_collection_account') === '9d50ec94aed5d50147723e89e22a9b159311680f9492c74e81d60a9d8c141683'
    }

    /**
     * Set the CollectionAccounts storage to the given `value`, origin must be root
     */
    get asMatrixEnjinV603(): {collectionId: bigint, accountId: matrixEnjinV603.MultiAddress, value: (matrixEnjinV603.CollectionAccount | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceSetEthereumAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_set_ethereum_account')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets [`ClaimableCollectionIds`] to `value`. Only callable by [`Config::ForceOrigin`].
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_ethereum_account') === 'ff39e28724b48d3e7b31b93aab174ada0abe695b6ea73e0f94a52337f5829a1c'
    }

    /**
     * Sets [`ClaimableCollectionIds`] to `value`. Only callable by [`Config::ForceOrigin`].
     */
    get asMatrixEnjinV1000(): {address: Uint8Array, value: (bigint[] | undefined)} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceSetEthereumCollectionIdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_set_ethereum_collection_id')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets [`NativeCollectionIds`] to `native_collection_id`. Only callable by
     * [`Config::ForceOrigin`].
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_ethereum_collection_id') === 'f48ee641ff9ee90f113b54e9bf6a09acf4be545da1603777abbb8d2945397349'
    }

    /**
     * Sets [`NativeCollectionIds`] to `native_collection_id`. Only callable by
     * [`Config::ForceOrigin`].
     */
    get asMatrixEnjinV1000(): {ethereumCollectionId: bigint, nativeCollectionId: (bigint | undefined)} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceSetEthereumUnmintableTokenIdsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_set_ethereum_unmintable_token_ids')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets [`UnmintableTokenIds`] using ethereum_collection_id, the function will fail if the
     * ethereum_collection_id is invalid
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_ethereum_unmintable_token_ids') === 'd3533d64c4a0a399674b15f4d56c2085c48613cfb421afc25b3253751b764a0b'
    }

    /**
     * Sets [`UnmintableTokenIds`] using ethereum_collection_id, the function will fail if the
     * ethereum_collection_id is invalid
     */
    get asMatrixEnjinV1000(): {ethereumCollectionId: bigint, baseTokenId: bigint, tokenIndex: bigint} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceSetNextCollectionIdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_set_next_collection_id')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets [`NextCollectionId`] to `value`. Only callable by [`Config::ForceOrigin`].
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_next_collection_id') === 'd13cb91c3f61510beece366e7f7c2d0705f01d70f9bc28721d2437cd210a3372'
    }

    /**
     * Sets [`NextCollectionId`] to `value`. Only callable by [`Config::ForceOrigin`].
     */
    get asMatrixEnjinV603(): {value: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceSetTokenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_set_token')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the Tokens storage to the given `value`, origin must be root
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_token') === '6b0347ff9d005a8b25bcce6f0402078cf4f797f3978343bdd92c89b66bcd5dc9'
    }

    /**
     * Set the Tokens storage to the given `value`, origin must be root
     */
    get asMatrixEnjinV603(): {collectionId: bigint, tokenId: bigint, value: (matrixEnjinV603.Token | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the Tokens storage to the given `value`, origin must be root
     */
    get isV100(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_token') === '6e309a6623c66424fa2b051393f739db30a442cb48712f14fef0c24db32bf0bc'
    }

    /**
     * Set the Tokens storage to the given `value`, origin must be root
     */
    get asV100(): {collectionId: bigint, tokenId: bigint, value: (v100.Token | undefined)} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the Tokens storage to the given `value`, origin must be root
     */
    get isV102(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_token') === '6b0347ff9d005a8b25bcce6f0402078cf4f797f3978343bdd92c89b66bcd5dc9'
    }

    /**
     * Set the Tokens storage to the given `value`, origin must be root
     */
    get asV102(): {collectionId: bigint, tokenId: bigint, value: (v102.Token | undefined)} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceSetTokenAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_set_token_account')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the TokenAccounts storage to the given `value`, origin must be root
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_token_account') === 'bf35663d50dd3916b43afdc084f9827ad9764b0cd317f3ca102ce9251a909dad'
    }

    /**
     * Set the TokenAccounts storage to the given `value`, origin must be root
     */
    get asMatrixEnjinV603(): {collectionId: bigint, tokenId: bigint, accountId: matrixEnjinV603.MultiAddress, value: (matrixEnjinV603.TokenAccount | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceSetUnmintableTokenIdsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_set_unmintable_token_ids')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets [`UnmintableTokenIds`] storage. Only callable by
     * [`Config::ForceOrigin`].
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_unmintable_token_ids') === '95443d79e8d4c0d2b00a3cfc3b7df355b8bdc4ec3bf48bf00b18e2eea5609764'
    }

    /**
     * Sets [`UnmintableTokenIds`] storage. Only callable by
     * [`Config::ForceOrigin`].
     */
    get asMatrixEnjinV1000(): {collectionId: bigint, baseTokenId: bigint, tokenIndex: bigint} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Sets [`UnmintableTokenIds`] to `value`. Only callable by [`Config::ForceOrigin`].
     */
    get isV120(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_unmintable_token_ids') === '86379e10839ca2a6a47ee5b1ec74dd99b0e274da7bf97b3f0aa7659be48de934'
    }

    /**
     * Sets [`UnmintableTokenIds`] to `value`. Only callable by [`Config::ForceOrigin`].
     */
    get asV120(): {collectionId: bigint, value: (v120.RangeInclusive | undefined)} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Sets [`UnmintableTokenIds`] storage. Only callable by
     * [`Config::ForceOrigin`].
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('MultiTokens.force_set_unmintable_token_ids') === '95443d79e8d4c0d2b00a3cfc3b7df355b8bdc4ec3bf48bf00b18e2eea5609764'
    }

    /**
     * Sets [`UnmintableTokenIds`] storage. Only callable by
     * [`Config::ForceOrigin`].
     */
    get asV1021(): {collectionId: bigint, baseTokenId: bigint, tokenIndex: bigint} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensForceTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.force_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Exactly as [`transfer`](Self::transfer), except the origin must be root and the source
     * account should be specified.
     * 
     * # Errors
     * 
     * Same as [`transfer`](Self::transfer)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.force_transfer') === '7eb6f59738c54c66d88f77215603bab748b9d4ed2bc404e7a6627743e91b27f6'
    }

    /**
     * Exactly as [`transfer`](Self::transfer), except the origin must be root and the source
     * account should be specified.
     * 
     * # Errors
     * 
     * Same as [`transfer`](Self::transfer)
     */
    get asMatrixEnjinV603(): {source: matrixEnjinV603.MultiAddress, destination: matrixEnjinV603.MultiAddress, collectionId: bigint, params: matrixEnjinV603.DefaultTransferParams} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensFreezeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.freeze')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Freeze collection, token or account
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.freeze') === '91882af67a1b185551af07d0e9518d72ab08e8c353579842070f87fc1e425820'
    }

    /**
     * Freeze collection, token or account
     */
    get asMatrixEnjinV603(): {info: matrixEnjinV603.Freeze} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensMintCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.mint')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `origin` mints to `recipient` for `collection_id` with `params` using the pallet's
     * [`MintPolicy`](traits::CollectionPolicy::Mint).
     * 
     * # Errors
     * 
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `Collection` does not exist.
     * - [`Error::TokenNotFound`] if `Token` does not exist.
     * - [`Error::TokenAlreadyExists`] if attempting to create a token that already exists
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - `MaxTokenCountExceeded` if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficient balance for
     *   token deposit
     * - [`Error::ConflictingLocation`] if the token is foreign and the location is already
     *   mapped to another asset in `AssetIdsByLocation`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.mint') === '17e3c370d4720b5760710bed81f54d7f476ae6c39d3849de9837b9f718be4f32'
    }

    /**
     * `origin` mints to `recipient` for `collection_id` with `params` using the pallet's
     * [`MintPolicy`](traits::CollectionPolicy::Mint).
     * 
     * # Errors
     * 
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `Collection` does not exist.
     * - [`Error::TokenNotFound`] if `Token` does not exist.
     * - [`Error::TokenAlreadyExists`] if attempting to create a token that already exists
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - `MaxTokenCountExceeded` if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficient balance for
     *   token deposit
     * - [`Error::ConflictingLocation`] if the token is foreign and the location is already
     *   mapped to another asset in `AssetIdsByLocation`
     */
    get asMatrixEnjinV603(): {recipient: matrixEnjinV603.MultiAddress, collectionId: bigint, params: matrixEnjinV603.DefaultMintParams} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `origin` mints to `recipient` for `collection_id` with `params` using the pallet's
     * [`MintPolicy`](traits::CollectionPolicy::Mint).
     * 
     * # Errors
     * 
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `Collection` does not exist.
     * - [`Error::TokenNotFound`] if `Token` does not exist.
     * - [`Error::TokenAlreadyExists`] if attempting to create a token that already exists
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - `MaxTokenCountExceeded` if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficent balance for
     *   token deposit
     * - [`Error::ConflictingLocation`] if the token is foreign and the location is already
     *   mapped to another asset in `AssetIdsByLocation`
     */
    get isV100(): boolean {
        return this._chain.getCallHash('MultiTokens.mint') === '77fe7100fc7c7f01a60ba86298be60e67d2083b3b69c7b7178ef6e5c51c15ffc'
    }

    /**
     * `origin` mints to `recipient` for `collection_id` with `params` using the pallet's
     * [`MintPolicy`](traits::CollectionPolicy::Mint).
     * 
     * # Errors
     * 
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `Collection` does not exist.
     * - [`Error::TokenNotFound`] if `Token` does not exist.
     * - [`Error::TokenAlreadyExists`] if attempting to create a token that already exists
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - `MaxTokenCountExceeded` if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficent balance for
     *   token deposit
     * - [`Error::ConflictingLocation`] if the token is foreign and the location is already
     *   mapped to another asset in `AssetIdsByLocation`
     */
    get asV100(): {recipient: v100.MultiAddress, collectionId: bigint, params: v100.DefaultMintParams} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `origin` mints to `recipient` for `collection_id` with `params` using the pallet's
     * [`MintPolicy`](traits::CollectionPolicy::Mint).
     * 
     * # Errors
     * 
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `Collection` does not exist.
     * - [`Error::TokenNotFound`] if `Token` does not exist.
     * - [`Error::TokenAlreadyExists`] if attempting to create a token that already exists
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - `MaxTokenCountExceeded` if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficent balance for
     *   token deposit
     * - [`Error::ConflictingLocation`] if the token is foreign and the location is already
     *   mapped to another asset in `AssetIdsByLocation`
     */
    get isV102(): boolean {
        return this._chain.getCallHash('MultiTokens.mint') === '17e3c370d4720b5760710bed81f54d7f476ae6c39d3849de9837b9f718be4f32'
    }

    /**
     * `origin` mints to `recipient` for `collection_id` with `params` using the pallet's
     * [`MintPolicy`](traits::CollectionPolicy::Mint).
     * 
     * # Errors
     * 
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::CollectionNotFound`] if `Collection` does not exist.
     * - [`Error::TokenNotFound`] if `Token` does not exist.
     * - [`Error::TokenAlreadyExists`] if attempting to create a token that already exists
     * - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
     * - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
     * - `MaxTokenCountExceeded` if the mint policy max_token_count is exceeded
     * - [`Error::DepositReserveFailed`] if the issuer does not have sufficent balance for
     *   token deposit
     * - [`Error::ConflictingLocation`] if the token is foreign and the location is already
     *   mapped to another asset in `AssetIdsByLocation`
     */
    get asV102(): {recipient: v102.MultiAddress, collectionId: bigint, params: v102.DefaultMintParams} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensMutateCollectionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.mutate_collection')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Modify [`Collection`](ep_multi_tokens::Collection) with `id` by applying `mutation`
     * 
     * # Errors
     * 
     * - [`Error::CollectionNotFound`] if `collection_id` does not exist.
     * - [`Error::NoPermission`] if `origin` is not the owner of `collection`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.mutate_collection') === '14654b078d9899c1c298781a09e325690f44d4eb607d8c69ff2f94e1c6b31069'
    }

    /**
     * Modify [`Collection`](ep_multi_tokens::Collection) with `id` by applying `mutation`
     * 
     * # Errors
     * 
     * - [`Error::CollectionNotFound`] if `collection_id` does not exist.
     * - [`Error::NoPermission`] if `origin` is not the owner of `collection`.
     */
    get asMatrixEnjinV603(): {collectionId: bigint, mutation: matrixEnjinV603.DefaultCollectionMutation} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensMutateTokenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.mutate_token')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Modify [`Token`](ep_multi_tokens::Token) with `token_id`  from
     * [`Collection`](ep_multi_tokens::Collection) with `collection_id` by applying `mutation`
     * 
     * # Errors
     * 
     * - [`Error::CurrencyIncompatibleWithCollectionRoyalty`] if token has already been
     *   assigned a royalty
     * - [`Error::NoPermission`] if not the collection owner
     * - [`Error::TokenNotFound`] if Token does not exist
     * - [`Error::ConflictingLocation`] if the new location is already occupied
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.mutate_token') === 'b1df46e912bd6082a6796b61e3d5451b698e752c5aa782392bb97d3c78d81f3c'
    }

    /**
     * Modify [`Token`](ep_multi_tokens::Token) with `token_id`  from
     * [`Collection`](ep_multi_tokens::Collection) with `collection_id` by applying `mutation`
     * 
     * # Errors
     * 
     * - [`Error::CurrencyIncompatibleWithCollectionRoyalty`] if token has already been
     *   assigned a royalty
     * - [`Error::NoPermission`] if not the collection owner
     * - [`Error::TokenNotFound`] if Token does not exist
     * - [`Error::ConflictingLocation`] if the new location is already occupied
     */
    get asMatrixEnjinV603(): {collectionId: bigint, tokenId: bigint, mutation: matrixEnjinV603.DefaultTokenMutation} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensRemoveAllAttributesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.remove_all_attributes')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Removes all attributes from the given `collection_id` or `token_id`.
     * 
     * # Errors
     * - `InvalidAttributeCount` if `attribute_count` doesn't match the number of attributes
     * - [`Error::CollectionNotFound`] if Collection with `collection_id` does not exist.
     * - [`Error::TokenNotFound`] if Token with `token_id` does not exist.
     * - [`Error::NoPermission`] if `origin` account is not the owner of the Collection or
     *   Token
     * - other errors from `remove_attribute`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.remove_all_attributes') === '721a13a18dab7748d2990b3b2edd4c1c6fbca833c064e8ae31bb2cec0c3aed84'
    }

    /**
     * Removes all attributes from the given `collection_id` or `token_id`.
     * 
     * # Errors
     * - `InvalidAttributeCount` if `attribute_count` doesn't match the number of attributes
     * - [`Error::CollectionNotFound`] if Collection with `collection_id` does not exist.
     * - [`Error::TokenNotFound`] if Token with `token_id` does not exist.
     * - [`Error::NoPermission`] if `origin` account is not the owner of the Collection or
     *   Token
     * - other errors from `remove_attribute`
     */
    get asMatrixEnjinV603(): {collectionId: bigint, tokenId: (bigint | undefined), attributeCount: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensRemoveAttributeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.remove_attribute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Removes the `key` attribute from the given `collection_id` or `token_id`.
     * 
     * # Errors
     * - [`Error::InvalidAttributeKey`] if `key.len() == 0`
     * - [`Error::CollectionNotFound`] if `collection_id` does not exist.
     * - [`Error::TokenNotFound`] if `token_id` is `Some` and does not exist.
     * - [`Error::NoPermission`] if `caller` is not the owner of the collection.
     * - `Underflow` if an attribute counter underflows
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.remove_attribute') === '5e8dda41d19b04f7e051283b9b20aed0a83222ef4bc596239942a512d10e143c'
    }

    /**
     * Removes the `key` attribute from the given `collection_id` or `token_id`.
     * 
     * # Errors
     * - [`Error::InvalidAttributeKey`] if `key.len() == 0`
     * - [`Error::CollectionNotFound`] if `collection_id` does not exist.
     * - [`Error::TokenNotFound`] if `token_id` is `Some` and does not exist.
     * - [`Error::NoPermission`] if `caller` is not the owner of the collection.
     * - `Underflow` if an attribute counter underflows
     */
    get asMatrixEnjinV603(): {collectionId: bigint, tokenId: (bigint | undefined), key: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensSetAttributeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.set_attribute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the attribute `key` to `value` for `collection_id`.
     * If `token_id` is [`None`], the attribute is added to the collection. If it is [`Some`],
     * the attribute is added to the token.
     * 
     * # Errors
     * - [`Error::InvalidAttributeKey`] if `key.len() == 0`
     * - [`Error::CollectionNotFound`] if `collection_id` does not exist.
     * - [`Error::TokenNotFound`] if `token_id` is `Some` and does not exist.
     * - [`Error::NoPermission`] if `source` account is not the owner of the collection.
     * - [`Error::DepositReserveFailed`] if unable to reserve the deposit for the attribute
     *   storage.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.set_attribute') === '1442e960b51ef446ff50fc6d27284693378495f9905ed8fbc35811b81dcf7c7b'
    }

    /**
     * Sets the attribute `key` to `value` for `collection_id`.
     * If `token_id` is [`None`], the attribute is added to the collection. If it is [`Some`],
     * the attribute is added to the token.
     * 
     * # Errors
     * - [`Error::InvalidAttributeKey`] if `key.len() == 0`
     * - [`Error::CollectionNotFound`] if `collection_id` does not exist.
     * - [`Error::TokenNotFound`] if `token_id` is `Some` and does not exist.
     * - [`Error::NoPermission`] if `source` account is not the owner of the collection.
     * - [`Error::DepositReserveFailed`] if unable to reserve the deposit for the attribute
     *   storage.
     */
    get asMatrixEnjinV603(): {collectionId: bigint, tokenId: (bigint | undefined), key: Uint8Array, value: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensThawCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.thaw')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Thaw collection, token or account
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.thaw') === '91882af67a1b185551af07d0e9518d72ab08e8c353579842070f87fc1e425820'
    }

    /**
     * Thaw collection, token or account
     */
    get asMatrixEnjinV603(): {info: matrixEnjinV603.Freeze} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `operator` transfers to `recipient` for `collection_id` with `params`
     * 
     * # Errors
     * 
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::BalanceLow`] if `source` does not own enough amount of `collection`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.transfer') === '3a904597294b52262716ac476178f413a640c58c5df5fdee9d6a42b369dab12a'
    }

    /**
     * `operator` transfers to `recipient` for `collection_id` with `params`
     * 
     * # Errors
     * 
     * - [`Error::AmountZero`] if `amount == 0`.
     * - [`Error::BalanceLow`] if `source` does not own enough amount of `collection`.
     */
    get asMatrixEnjinV603(): {recipient: matrixEnjinV603.MultiAddress, collectionId: bigint, params: matrixEnjinV603.DefaultTransferParams} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensUnapproveCollectionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.unapprove_collection')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unapprove the `operator` to manage all of `origin`'s tokens belonging to `collection`
     * 
     * # Errors
     * 
     * - [`Error::CollectionAccountNotFound`] if the collection account cannot be found
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.unapprove_collection') === 'e5170bfdb3c4351aa216ff597896abe5ecc75ec89c47b522a97790870cc3b5ef'
    }

    /**
     * Unapprove the `operator` to manage all of `origin`'s tokens belonging to `collection`
     * 
     * # Errors
     * 
     * - [`Error::CollectionAccountNotFound`] if the collection account cannot be found
     */
    get asMatrixEnjinV603(): {collectionId: bigint, operator: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensUnapproveTokenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokens.unapprove_token')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unapprove `operator` to transfer `origin`'s `token_id` of `collection_id`
     * 
     * # Errors
     * 
     * - [`Error::TokenAccountNotFound`] if the token account does not exist
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokens.unapprove_token') === 'bf808826dcdafcc9b31e08b287969eda26c2a350dbd9b501129943a436ab8854'
    }

    /**
     * Unapprove `operator` to transfer `origin`'s `token_id` of `collection_id`
     * 
     * # Errors
     * 
     * - [`Error::TokenAccountNotFound`] if the token account does not exist
     */
    get asMatrixEnjinV603(): {collectionId: bigint, tokenId: bigint, operator: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensMigrationFinalizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokensMigration.finalize')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Finalizes the migration process by unpausing all related pallets, setting the next
     * collection ID, updating the migration status, and emitting a `MigrationFinished` event.
     * 
     * # Arguments
     * 
     * * `origin` - The origin of the transaction.
     * * `next_collection_id` - The ID of the next collection.
     * 
     * # Errors
     * - [`Error::OnlyFinalizeOngoing`] if auction is not ongoing.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokensMigration.finalize') === '137977a56f38380f8d4ccd77b98084830ccd66df180fbb23d13a738621ab87b8'
    }

    /**
     * Finalizes the migration process by unpausing all related pallets, setting the next
     * collection ID, updating the migration status, and emitting a `MigrationFinished` event.
     * 
     * # Arguments
     * 
     * * `origin` - The origin of the transaction.
     * * `next_collection_id` - The ID of the next collection.
     * 
     * # Errors
     * - [`Error::OnlyFinalizeOngoing`] if auction is not ongoing.
     */
    get asMatrixEnjinV603(): {nextCollectionId: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensMigrationMigrateAttributesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokensMigration.migrate_attributes')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Migrates [`Attributes`] by setting attribute values for the specified list of attributes
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokensMigration.migrate_attributes') === '38678b38b1093dceec6ad9eb431127466c58af938a8150a8c7ad7c37e5072de9'
    }

    /**
     * Migrates [`Attributes`] by setting attribute values for the specified list of attributes
     */
    get asMatrixEnjinV603(): {attributes: [bigint, (bigint | undefined), Uint8Array, matrixEnjinV603.Attribute][]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensMigrationMigrateCollectionAccountsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokensMigration.migrate_collection_accounts')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Migrates [`CollectionAccounts`] by setting values for the given accounts
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokensMigration.migrate_collection_accounts') === '813084e51cd54ab7bfef8bf7e5059f31e0d2b9c12322cf69ce76a95e9699cac1'
    }

    /**
     * Migrates [`CollectionAccounts`] by setting values for the given accounts
     */
    get asMatrixEnjinV603(): {accounts: [bigint, Uint8Array, matrixEnjinV603.CollectionAccount][]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensMigrationMigrateCollectionsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokensMigration.migrate_collections')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Migrates [`Collections`] by setting values for the given collections
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokensMigration.migrate_collections') === '37cd3868d6f3f9dbe259cd581888f07612dc8dd99faeda8210d75e8fac60889e'
    }

    /**
     * Migrates [`Collections`] by setting values for the given collections
     */
    get asMatrixEnjinV603(): {collections: [bigint, matrixEnjinV603.Collection][]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensMigrationMigrateTokenAccountsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokensMigration.migrate_token_accounts')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Migrates [`TokenAccounts`] by setting values for the given accounts
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokensMigration.migrate_token_accounts') === 'a8273c032ee74f21d24abe2440c005682abdfed982744ce56f3d7dbb682df9d1'
    }

    /**
     * Migrates [`TokenAccounts`] by setting values for the given accounts
     */
    get asMatrixEnjinV603(): {accounts: [bigint, bigint, Uint8Array, matrixEnjinV603.TokenAccount][]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultiTokensMigrationMigrateTokensCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MultiTokensMigration.migrate_tokens')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Migrates [`Tokens`] by setting values for the given tokens
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('MultiTokensMigration.migrate_tokens') === '5a462e1cc4608c0590c2a56f5ea8ac6910e1ace1b917bfe39df97eff05101008'
    }

    /**
     * Migrates [`Tokens`] by setting values for the given tokens
     */
    get asMatrixEnjinV603(): {tokens: [bigint, bigint, matrixEnjinV603.Token][]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigApproveAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.approve_as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     * 
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Multisig.approve_as_multi') === '88561668497d8fdee3be21d28e6e68bc1cd9568f418501a4b294fe2b9803acb4'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     * 
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get asMatrixEnjinV603(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (matrixEnjinV603.Timepoint | undefined), callHash: Uint8Array, maxWeight: matrixEnjinV603.Weight} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '753de76e027798fb10ef412018689caa169a5d49a8566d63b558955b6df0eb69'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get asMatrixEnjinV603(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (matrixEnjinV603.Timepoint | undefined), call: matrixEnjinV603.Call, maxWeight: matrixEnjinV603.Weight} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === 'd5d43d2ca8e7b61a07adf062e8a76be0ee7a4d980db5fb6472d262ccc53a38c4'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get asMatrixEnjinV1000(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (matrixEnjinV1000.Timepoint | undefined), call: matrixEnjinV1000.Call, maxWeight: matrixEnjinV1000.Weight} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '9343c637a3889667ccbf558238e261cd733cdb7ab6298b83d656366afdbc01b2'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get asMatrixEnjinV1003(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (matrixEnjinV1003.Timepoint | undefined), call: matrixEnjinV1003.Call, maxWeight: matrixEnjinV1003.Weight} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '3380a4947067d1b53a72cae070d7df3f35e09ab7a1acfedafe8ebde92da0ecea'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get asV105(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v105.Timepoint | undefined), call: v105.Call, maxWeight: v105.Weight} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '5e29d8276c8cd44b8477682e98398662e5c106f127624485da33b1574a534cd8'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get asV106(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v106.Timepoint | undefined), call: v106.Call, maxWeight: v106.Weight} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === 'cfe6a224170ad43c1e6e16ebe146ed90821237e989c37a40c4f54bf019fbdbe4'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get asV110(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v110.Timepoint | undefined), call: v110.Call, maxWeight: v110.Weight} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === 'e8433ecdeb5ae10669c8797c498b9e1e55d7db2b981eb4f90e3830180a405ff4'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get asV120(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v120.Timepoint | undefined), call: v120.Call, maxWeight: v120.Weight} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === 'd345ccdd93d48b5be96dd0b17b5b0ff565e765e0eb9f335abbf036ffda85aa59'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get asV1021(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1021.Timepoint | undefined), call: v1021.Call, maxWeight: v1021.Weight} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === 'ab68be7271836adfd4c587cfc69e66ac626e7cb5d52c46ebaa8c074a9782e7f5'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get asV1022(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1022.Timepoint | undefined), call: v1022.Call, maxWeight: v1022.Weight} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '027d7aabd7f91c9e3d59afdf9f704cacb37771c939b8d23ef7cfae11a6746e32'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    get asV1023(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1023.Timepoint | undefined), call: v1023.Call, maxWeight: v1023.Weight} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigAsMultiThreshold1Call {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.as_multi_threshold_1')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '2272d53de8645af097228f5c68da02f4c6eb7cfbbd2865623e12152ca56b023c'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get asMatrixEnjinV603(): {otherSignatories: Uint8Array[], call: matrixEnjinV603.Call} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'c3b6d9437c60856a9842e05d38dd4e8fdd95b2d7604ea35401a95956b50f90cf'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get asMatrixEnjinV1000(): {otherSignatories: Uint8Array[], call: matrixEnjinV1000.Call} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '3cc1715f4f1185cd2d87bb033c331287195799ed30e78489a170032d305a9521'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get asMatrixEnjinV1003(): {otherSignatories: Uint8Array[], call: matrixEnjinV1003.Call} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'dea30a33ea579f758745b7dbf3af59754b28b685e07de723ae94296ea9fdff2e'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get asV105(): {otherSignatories: Uint8Array[], call: v105.Call} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '801f1a7eab5e2bd432cf51f53492672a0edff4c20a695414340a6567331657cd'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get asV106(): {otherSignatories: Uint8Array[], call: v106.Call} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'e4b50c417920cf8625726cd14703c93b49be701aba694a100ed22475126d4362'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get asV110(): {otherSignatories: Uint8Array[], call: v110.Call} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'fe6670fd708842bc22a67532e74f3dac8f34043d3540659b31a98252940cb4b5'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get asV120(): {otherSignatories: Uint8Array[], call: v120.Call} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '127414063c828b7358fe4ca932e38d7be87d6f58b8c2b8c59ca14a55a8e2bfb3'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get asV1021(): {otherSignatories: Uint8Array[], call: v1021.Call} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '40b1a4ba223db511663e8b13a9410bf4dd4768392a1017722d3bc3a83ea6136b'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get asV1022(): {otherSignatories: Uint8Array[], call: v1022.Call} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'e01f382b910f87c5734544594575d2e56515879b601c3e8570c57da706db99cf'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    get asV1023(): {otherSignatories: Uint8Array[], call: v1023.Call} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigCancelAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.cancel_as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     * 
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Multisig.cancel_as_multi') === '4ccc75a4f739c659f177e3df98fba2ea59ddade74c4ebccd51b2fc4c52e923af'
    }

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     * 
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     */
    get asMatrixEnjinV603(): {threshold: number, otherSignatories: Uint8Array[], timepoint: matrixEnjinV603.Timepoint, callHash: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsBondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.bond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Stake funds with a pool. The amount to bond is transferred from the member to the
     * pools account and immediately increases the pools bond.
     * 
     * # Parameters
     * - `origin`: the caller
     * - `amount`: the amount of tokens deposited into the pool
     * - `pool_id`: the pool id to bond
     * - `reduce_amount_to_fill`: if true, and `amount` will cause the pool to go over
     *   capacity, it will reduce `amount` to precisely fill the pool
     * 
     * # Note
     * 
     * * An account can only be a member of a single pool.
     * * An account cannot join the same pool multiple times.
     * * This call will *not* dust the member account, so the member must have at least
     *   `existential deposit + amount` in their account.
     * * Only a pool with [`PoolState::Open`] can be joined
     */
    get isV104(): boolean {
        return this._chain.getCallHash('NominationPools.bond') === '753cc196a17a5f7bfebe4b1bab665a23cd4fc96e24a731af4bde84b9f9029193'
    }

    /**
     * Stake funds with a pool. The amount to bond is transferred from the member to the
     * pools account and immediately increases the pools bond.
     * 
     * # Parameters
     * - `origin`: the caller
     * - `amount`: the amount of tokens deposited into the pool
     * - `pool_id`: the pool id to bond
     * - `reduce_amount_to_fill`: if true, and `amount` will cause the pool to go over
     *   capacity, it will reduce `amount` to precisely fill the pool
     * 
     * # Note
     * 
     * * An account can only be a member of a single pool.
     * * An account cannot join the same pool multiple times.
     * * This call will *not* dust the member account, so the member must have at least
     *   `existential deposit + amount` in their account.
     * * Only a pool with [`PoolState::Open`] can be joined
     */
    get asV104(): {poolId: number, amount: v104.BondValue} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsBondExtraCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.bond_extra')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Bond `extra` more funds from `origin` into the pool to which they already belong.
     * 
     * Additional funds can come from either the free balance of the account, of from the
     * accumulated rewards, see [`BondExtra`].
     * 
     * Bonding extra funds implies an automatic payout of all pending rewards as well.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.bond_extra') === 'a9b5a60efa83657f9001e42033288daf763c4fbb493ca27e2fdda6dc58a424de'
    }

    /**
     * Bond `extra` more funds from `origin` into the pool to which they already belong.
     * 
     * Additional funds can come from either the free balance of the account, of from the
     * accumulated rewards, see [`BondExtra`].
     * 
     * Bonding extra funds implies an automatic payout of all pending rewards as well.
     */
    get asV100(): {poolId: number, extra: v100.BondExtra} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Bond `extra` more funds from `origin` into the pool to which they already belong.
     * 
     * Additional funds can come from either the free balance of the account, of from the
     * accumulated rewards.
     * 
     * Bonding extra funds implies an automatic payout of all pending rewards as well.
     */
    get isV103(): boolean {
        return this._chain.getCallHash('NominationPools.bond_extra') === '753cc196a17a5f7bfebe4b1bab665a23cd4fc96e24a731af4bde84b9f9029193'
    }

    /**
     * Bond `extra` more funds from `origin` into the pool to which they already belong.
     * 
     * Additional funds can come from either the free balance of the account, of from the
     * accumulated rewards.
     * 
     * Bonding extra funds implies an automatic payout of all pending rewards as well.
     */
    get asV103(): {poolId: number, amount: v103.BondValue} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsCalculateEarlyBirdBonusCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.calculate_early_bird_bonus')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Calculate and prepare early bird bonus if it is ready to be queued.
     * 
     * Callable by any signed origin after [`Config::EarlyBirdBonusDistributionBlock`].
     * 
     * ## Details
     * 
     * 1. Calculates the normalized weights for each pool by calling
     *    [`Pallet::early_bird_normalized_weight`]. Factors for the weight are each pool's
     *    total points and the creation date.
     * 2. Each pool's weight is multiplied by the total reward to determine each pool's reward.
     * 3. The rewards are stored in [`PoolBonusInfos`] and can be distributed by calling
     *    [`Self::distribute_early_bird_bonus`].
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('NominationPools.calculate_early_bird_bonus') === '42f1b48e9aea81bc205a1f08cfea41c3c6570661bf0cdf8f1171d9f79d2ca359'
    }

    /**
     * Calculate and prepare early bird bonus if it is ready to be queued.
     * 
     * Callable by any signed origin after [`Config::EarlyBirdBonusDistributionBlock`].
     * 
     * ## Details
     * 
     * 1. Calculates the normalized weights for each pool by calling
     *    [`Pallet::early_bird_normalized_weight`]. Factors for the weight are each pool's
     *    total points and the creation date.
     * 2. Each pool's weight is multiplied by the total reward to determine each pool's reward.
     * 3. The rewards are stored in [`PoolBonusInfos`] and can be distributed by calling
     *    [`Self::distribute_early_bird_bonus`].
     */
    get asV1021(): {poolCount: number} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsCaptureEarlyBirdBonusSharesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.capture_early_bird_bonus_shares')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Stores the share of sENJ balance for each account staked in `pool_id`.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('NominationPools.capture_early_bird_bonus_shares') === 'f1eafe3ea622e4f5d37cc6d2bf5e28ced987cf1dc33297fcaaf3dbd61865680f'
    }

    /**
     * Stores the share of sENJ balance for each account staked in `pool_id`.
     */
    get asV1022(): {poolId: number, accountCount: number} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsChillCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.chill')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Chill on behalf of the pool.
     * 
     * The dispatch origin of this call must be signed by the pool nominator or the pool
     * root role, same as [`Pallet::nominate`].
     * 
     * This directly forward the call to the staking pallet, on behalf of the pool bonded
     * account.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.chill') === 'a662258b1bdb045a915972ea29e9ec0b46cdd5598b0da37b0e70ac766e3735a0'
    }

    /**
     * Chill on behalf of the pool.
     * 
     * The dispatch origin of this call must be signed by the pool nominator or the pool
     * root role, same as [`Pallet::nominate`].
     * 
     * This directly forward the call to the staking pallet, on behalf of the pool bonded
     * account.
     */
    get asV100(): {poolId: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsCreateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.create')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a new delegation pool.
     * 
     * # Arguments
     * 
     * * `token_id` - Token that that will control the pool.
     * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
     *   deposit since the pools creator cannot fully unbond funds until the pool is being
     *   destroyed.
     * * `capacity` - The maximum total balance allowed in the pool
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     *   creating multiple pools in the same extrinsic.
     * * `root` - The account to set as [`PoolRoles::root`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * * `state_toggler` - The account to set as the [`PoolRoles::state_toggler`].
     * 
     * # Note
     * 
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferrable.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.create') === '7efe2bf8d07fe511d9581b6649541a517e9b438d3c76a2bb31dd2e78d8d452ca'
    }

    /**
     * Create a new delegation pool.
     * 
     * # Arguments
     * 
     * * `token_id` - Token that that will control the pool.
     * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
     *   deposit since the pools creator cannot fully unbond funds until the pool is being
     *   destroyed.
     * * `capacity` - The maximum total balance allowed in the pool
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     *   creating multiple pools in the same extrinsic.
     * * `root` - The account to set as [`PoolRoles::root`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * * `state_toggler` - The account to set as the [`PoolRoles::state_toggler`].
     * 
     * # Note
     * 
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferrable.
     */
    get asV100(): {tokenId: bigint, amount: bigint, capacity: bigint, duration: number, root: v100.MultiAddress, nominator: v100.MultiAddress} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a new delegation pool.
     * 
     * # Arguments
     * 
     * * `token_id` - Token that that will control the pool.
     * * `deposit` - The amount of funds to delegate to the pool. This also acts of a sort of
     *   deposit since the pools creator cannot fully unbond funds until the pool is being
     *   destroyed.
     * * `capacity` - The maximum total balance allowed in the pool
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     *   creating multiple pools in the same extrinsic.
     * * `root` - The account to set as [`PoolRoles::root`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * * `state_toggler` - The account to set as the [`PoolRoles::state_toggler`].
     * 
     * # Note
     * 
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferrable.
     */
    get isV101(): boolean {
        return this._chain.getCallHash('NominationPools.create') === '6e6d5fa804e07126e4150fd9d2fd0b0be84d82073f465c0230bf17fd698579cf'
    }

    /**
     * Create a new delegation pool.
     * 
     * # Arguments
     * 
     * * `token_id` - Token that that will control the pool.
     * * `deposit` - The amount of funds to delegate to the pool. This also acts of a sort of
     *   deposit since the pools creator cannot fully unbond funds until the pool is being
     *   destroyed.
     * * `capacity` - The maximum total balance allowed in the pool
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     *   creating multiple pools in the same extrinsic.
     * * `root` - The account to set as [`PoolRoles::root`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * * `state_toggler` - The account to set as the [`PoolRoles::state_toggler`].
     * 
     * # Note
     * 
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferrable.
     */
    get asV101(): {tokenId: bigint, deposit: bigint, capacity: bigint, duration: number, root: v101.MultiAddress, nominator: v101.MultiAddress} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a new delegation pool.
     * 
     * # Arguments
     * 
     * * `token_id` - Token that that will control the pool.
     * * `deposit` - The amount of funds to delegate to the pool. This also acts of a sort of
     *   deposit since the pools creator cannot fully unbond funds until the pool is being
     *   destroyed.
     * * `capacity` - The maximum total balance allowed in the pool
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     *   creating multiple pools in the same extrinsic.
     * * `admin` - The account to set as [`PoolRoles::admin`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * 
     * # Note
     * 
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferrable.
     */
    get isV102(): boolean {
        return this._chain.getCallHash('NominationPools.create') === '9a3d59ec7df182ed01246cf427e744f292f6bc1ae70bda283df5b48491a7733b'
    }

    /**
     * Create a new delegation pool.
     * 
     * # Arguments
     * 
     * * `token_id` - Token that that will control the pool.
     * * `deposit` - The amount of funds to delegate to the pool. This also acts of a sort of
     *   deposit since the pools creator cannot fully unbond funds until the pool is being
     *   destroyed.
     * * `capacity` - The maximum total balance allowed in the pool
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     *   creating multiple pools in the same extrinsic.
     * * `admin` - The account to set as [`PoolRoles::admin`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * 
     * # Note
     * 
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferrable.
     */
    get asV102(): {tokenId: bigint, deposit: bigint, capacity: bigint, duration: number, admin: v102.MultiAddress, nominator: v102.MultiAddress} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a new nomination pool.
     * 
     * # Arguments
     * 
     * * `token_id` - Token that that will control the pool. This token must be from the
     *   [`Config::PoolCollectionId`] collection and it must be held by the caller.
     * * `deposit` - The amount of funds to delegate to the pool. This also acts as a deposit
     *   because the pool's creator cannot fully unbond funds until the pool is destroyed.
     * * `capacity` - The maximum total balance allowed in the pool. This is measured in sENJ.
     * * `duration` - The duration in blocks of the pool's bonus cycle
     * 
     * # Note
     * 
     * In addition to `deposit`, the caller will transfer the existential deposit for the
     * pool's accounts; so the caller needs at have at least `deposit + existential_deposit *
     * 2` transferable.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('NominationPools.create') === '9433ce86962b79dafa83cf0349d08dbd385efad223b263fcc1cbfff16f9108cf'
    }

    /**
     * Create a new nomination pool.
     * 
     * # Arguments
     * 
     * * `token_id` - Token that that will control the pool. This token must be from the
     *   [`Config::PoolCollectionId`] collection and it must be held by the caller.
     * * `deposit` - The amount of funds to delegate to the pool. This also acts as a deposit
     *   because the pool's creator cannot fully unbond funds until the pool is destroyed.
     * * `capacity` - The maximum total balance allowed in the pool. This is measured in sENJ.
     * * `duration` - The duration in blocks of the pool's bonus cycle
     * 
     * # Note
     * 
     * In addition to `deposit`, the caller will transfer the existential deposit for the
     * pool's accounts; so the caller needs at have at least `deposit + existential_deposit *
     * 2` transferable.
     */
    get asV110(): {tokenId: bigint, deposit: bigint, capacity: bigint, duration: number} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a new nomination pool.
     * 
     * # Arguments
     * 
     * * `token_id` - Token that that will control the pool. This token must be from the
     *   [`Config::PoolCollectionId`] collection and it must be held by the caller.
     * * `deposit` - The amount of funds to delegate to the pool. This also acts as a deposit
     *   because the pool's creator cannot fully unbond funds until the pool is destroyed.
     * * `capacity` - The maximum total balance allowed in the pool. This is measured in sENJ.
     *   It must be below the pool's capacity. See `Capacity` section in crate level docs.
     * * `duration` - The duration in blocks of the pool's bonus cycle
     * 
     * # Note
     * 
     * In addition to `deposit`, the caller will transfer the existential deposit for the
     * pool's accounts; so the caller needs at have at least `deposit + existential_deposit *
     * 2` transferable.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('NominationPools.create') === '1adad4da9b98b8de87c25154bd4aba755b885eb0d94339342e257b3b7da6e9dd'
    }

    /**
     * Create a new nomination pool.
     * 
     * # Arguments
     * 
     * * `token_id` - Token that that will control the pool. This token must be from the
     *   [`Config::PoolCollectionId`] collection and it must be held by the caller.
     * * `deposit` - The amount of funds to delegate to the pool. This also acts as a deposit
     *   because the pool's creator cannot fully unbond funds until the pool is destroyed.
     * * `capacity` - The maximum total balance allowed in the pool. This is measured in sENJ.
     *   It must be below the pool's capacity. See `Capacity` section in crate level docs.
     * * `duration` - The duration in blocks of the pool's bonus cycle
     * 
     * # Note
     * 
     * In addition to `deposit`, the caller will transfer the existential deposit for the
     * pool's accounts; so the caller needs at have at least `deposit + existential_deposit *
     * 2` transferable.
     */
    get asV1023(): {tokenId: bigint, deposit: bigint, capacity: bigint, duration: number, name: Uint8Array} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsDestroyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.destroy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Destroy the pool.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.destroy') === 'a662258b1bdb045a915972ea29e9ec0b46cdd5598b0da37b0e70ac766e3735a0'
    }

    /**
     * Destroy the pool.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get asV100(): {poolId: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsDistributeEarlyBirdBonusCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.distribute_early_bird_bonus')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Distribute early bird bonus to pools. The `transfer_count` parameter is the max number
     * of transfers to be made in this call. If there are less items in the queue, it will end
     * early.
     * 
     * Callable by any signed origin
     */
    get isV106(): boolean {
        return this._chain.getCallHash('NominationPools.distribute_early_bird_bonus') === '79bc83bd8f53449c5df8dbaf5ddcbc31df81048d91ad6f805511a4a76dbf2e75'
    }

    /**
     * Distribute early bird bonus to pools. The `transfer_count` parameter is the max number
     * of transfers to be made in this call. If there are less items in the queue, it will end
     * early.
     * 
     * Callable by any signed origin
     */
    get asV106(): {transferCount: number} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Distribute early bird bonus to pools. The `transfer_count` parameter is the max number
     * of transfers to be made in this call. If there are less items in the queue, it will end
     * early.
     * 
     * Callable by any signed origin after the bonus has been queued.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('NominationPools.distribute_early_bird_bonus') === '1cd8d6c675f44410d58fcbd9ce66c66650e15ec967d6d49a758354e20cc6a693'
    }

    /**
     * Distribute early bird bonus to pools. The `transfer_count` parameter is the max number
     * of transfers to be made in this call. If there are less items in the queue, it will end
     * early.
     * 
     * Callable by any signed origin after the bonus has been queued.
     */
    get asV1021(): {poolId: number, transferCount: number} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsJoinCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.join')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Stake funds with a pool. The amount to bond is transferred from the member to the
     * pools account and immediately increases the pools bond.
     * 
     * # Parameters
     * - `origin`: the caller
     * - `amount`: the amount of tokens deposited into the pool
     * - `pool_id`: the pool id to join
     * - `reduce_amount_to_fill`: if true, and `amount` will cause the pool to go over
     *   capacity, it will reduce `amount` to precisely fill the pool
     * # Note
     * 
     * * An account can only be a member of a single pool.
     * * An account cannot join the same pool multiple times.
     * * This call will *not* dust the member account, so the member must have at least
     *   `existential deposit + amount` in their account.
     * * Only a pool with [`PoolState::Open`] can be joined
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.join') === 'ed5f14393451f5d5cec1ee959eed8bc3cc18a7eb3b8f7a2d1d3945aa0e8131da'
    }

    /**
     * Stake funds with a pool. The amount to bond is transferred from the member to the
     * pools account and immediately increases the pools bond.
     * 
     * # Parameters
     * - `origin`: the caller
     * - `amount`: the amount of tokens deposited into the pool
     * - `pool_id`: the pool id to join
     * - `reduce_amount_to_fill`: if true, and `amount` will cause the pool to go over
     *   capacity, it will reduce `amount` to precisely fill the pool
     * # Note
     * 
     * * An account can only be a member of a single pool.
     * * An account cannot join the same pool multiple times.
     * * This call will *not* dust the member account, so the member must have at least
     *   `existential deposit + amount` in their account.
     * * Only a pool with [`PoolState::Open`] can be joined
     */
    get asV100(): {amount: bigint, poolId: number, reduceAmountToFill: boolean} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Stake funds with a pool. The amount to bond is transferred from the member to the
     * pools account and immediately increases the pools bond.
     * 
     * # Parameters
     * - `origin`: the caller
     * - `amount`: the amount of tokens deposited into the pool
     * - `pool_id`: the pool id to join
     * - `reduce_amount_to_fill`: if true, and `amount` will cause the pool to go over
     *   capacity, it will reduce `amount` to precisely fill the pool
     * # Note
     * 
     * * An account can only be a member of a single pool.
     * * An account cannot join the same pool multiple times.
     * * This call will *not* dust the member account, so the member must have at least
     *   `existential deposit + amount` in their account.
     * * Only a pool with [`PoolState::Open`] can be joined
     */
    get isV103(): boolean {
        return this._chain.getCallHash('NominationPools.join') === '753cc196a17a5f7bfebe4b1bab665a23cd4fc96e24a731af4bde84b9f9029193'
    }

    /**
     * Stake funds with a pool. The amount to bond is transferred from the member to the
     * pools account and immediately increases the pools bond.
     * 
     * # Parameters
     * - `origin`: the caller
     * - `amount`: the amount of tokens deposited into the pool
     * - `pool_id`: the pool id to join
     * - `reduce_amount_to_fill`: if true, and `amount` will cause the pool to go over
     *   capacity, it will reduce `amount` to precisely fill the pool
     * # Note
     * 
     * * An account can only be a member of a single pool.
     * * An account cannot join the same pool multiple times.
     * * This call will *not* dust the member account, so the member must have at least
     *   `existential deposit + amount` in their account.
     * * Only a pool with [`PoolState::Open`] can be joined
     */
    get asV103(): {poolId: number, amount: v103.BondValue} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsMutateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.mutate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Mutate the nomination pool data.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get isV102(): boolean {
        return this._chain.getCallHash('NominationPools.mutate') === 'a76d499e5225549a6a4824e431d80e59ecbe7c2f264324e65e97f5664218c12d'
    }

    /**
     * Mutate the nomination pool data.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get asV102(): {poolId: number, mutation: v102.PoolMutation} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Mutate the nomination pool data.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('NominationPools.mutate') === '526feb3ae06a68bd2b4314313fe167142b0160edd985ec9286574606d6a925c9'
    }

    /**
     * Mutate the nomination pool data.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get asV104(): {poolId: number, mutation: v104.PoolMutation} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Mutate the nomination pool data.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('NominationPools.mutate') === '70c40c8d0c496e6eae44c61bc40005a08639afef2e3e492c1200579b819a965f'
    }

    /**
     * Mutate the nomination pool data.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get asV110(): {poolId: number, mutation: v110.PoolMutation} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Mutate the nomination pool data.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('NominationPools.mutate') === 'acace76c54c031c6f38eca3ec63cc60e103318291ffd9b79155eddd2ecc4df9e'
    }

    /**
     * Mutate the nomination pool data.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get asV1023(): {poolId: number, mutation: v1023.PoolMutation} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsMutatePoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.mutate_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Mutate the nomination pool data.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get isV101(): boolean {
        return this._chain.getCallHash('NominationPools.mutate_pool') === '458b0ab8fe5b72d832a75c91c8b8a5f8edc75e37ba19627164cc44c51b7f3175'
    }

    /**
     * Mutate the nomination pool data.
     * 
     * The dispatch origin of this call must be signed by the account holding the pool token
     * of the given pool_id.
     */
    get asV101(): {poolId: number, mutation: v101.PoolMutation} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsNominateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.nominate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Nominate on behalf of the pool.
     * 
     * The dispatch origin of this call must be signed by the pool nominator or the pool
     * root role.
     * 
     * This directly forward the call to the staking pallet, on behalf of the pool bonded
     * account.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.nominate') === 'ea4465a57461881e03894b11ac5f7192136bacd8d01d54206bdb61e16cc8abfc'
    }

    /**
     * Nominate on behalf of the pool.
     * 
     * The dispatch origin of this call must be signed by the pool nominator or the pool
     * root role.
     * 
     * This directly forward the call to the staking pallet, on behalf of the pool bonded
     * account.
     */
    get asV100(): {poolId: number, validators: Uint8Array[]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsPayEarlyBirdBonusCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.pay_early_bird_bonus')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Pay early bird bonus to pools. The `account_count` parameter is the max number
     * of pool user accounts to be paid in this call.
     * 
     * Callable by any signed origin after the bonus has been unlocked
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('NominationPools.pay_early_bird_bonus') === '80de4c0099c79189447e23c2cd313e4c5ab4d6353aab63977a56a693165fe497'
    }

    /**
     * Pay early bird bonus to pools. The `account_count` parameter is the max number
     * of pool user accounts to be paid in this call.
     * 
     * Callable by any signed origin after the bonus has been unlocked
     */
    get asV1023(): {poolId: number, paymentId: number, accountCount: number} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsPayoutRewardsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.payout_rewards')
        this._chain = ctx._chain
        this.call = call
    }

    get isV101(): boolean {
        return this._chain.getCallHash('NominationPools.payout_rewards') === '1a09dc413ed4b8ce5cbcdc282b798636ca24268cca001e43fc92d892de3b6a5f'
    }

    get asV101(): {validatorStash: Uint8Array, era: number} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsPoolWithdrawUnbondedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.pool_withdraw_unbonded')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
     * 
     * This is useful if their are too many unlocking chunks to call `unbond`, and some
     * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
     * would probably see an error like `NoMoreChunks` emitted from the staking system when
     * they attempt to unbond.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.pool_withdraw_unbonded') === 'b6653f1dc9abfe17deb7a0622d88108ba58931838aa5b5b27bcf79870b10c0bc'
    }

    /**
     * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
     * 
     * This is useful if their are too many unlocking chunks to call `unbond`, and some
     * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
     * would probably see an error like `NoMoreChunks` emitted from the staking system when
     * they attempt to unbond.
     */
    get asV100(): {poolId: number, numSlashingSpans: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsProcessPayoutsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.process_payouts')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Processes the rewards for all pools that were distributed in [`Self::payout_rewards`].
     * It will only succeed if it is called on the same era that payouts were made. It uses the
     * [`EraPayoutInfo`] storage to verify this. This extrinsic is permissionless.
     * 
     * The following is done for each pool:
     * 1. If the pool has reached the end of its cycle, it cycles the pool.
     * 2. Sends bonus for the current era from the bonus account to the rewards account.
     * 3. Sends reward commission to the depositor.
     * 4. It bonds the pool's reward balance.
     * 
     * It is not required to call this extrinsic. If it is not called, the rewards will be
     * processed when `payout_rewards` is called in the next era.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('NominationPools.process_payouts') === '42f1b48e9aea81bc205a1f08cfea41c3c6570661bf0cdf8f1171d9f79d2ca359'
    }

    /**
     * Processes the rewards for all pools that were distributed in [`Self::payout_rewards`].
     * It will only succeed if it is called on the same era that payouts were made. It uses the
     * [`EraPayoutInfo`] storage to verify this. This extrinsic is permissionless.
     * 
     * The following is done for each pool:
     * 1. If the pool has reached the end of its cycle, it cycles the pool.
     * 2. Sends bonus for the current era from the bonus account to the rewards account.
     * 3. Sends reward commission to the depositor.
     * 4. It bonds the pool's reward balance.
     * 
     * It is not required to call this extrinsic. If it is not called, the rewards will be
     * processed when `payout_rewards` is called in the next era.
     */
    get asV110(): {poolCount: number} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsQueueEarlyBirdBonusCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.queue_early_bird_bonus')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Calculate and prepare early bird bonus if it is ready to be queued.
     * 
     * Callable by any signed origin
     */
    get isV106(): boolean {
        return this._chain.getCallHash('NominationPools.queue_early_bird_bonus') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Calculate and prepare early bird bonus if it is ready to be queued.
     * 
     * Callable by any signed origin
     */
    get asV106(): null {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Calculate and prepare early bird bonus if it is ready to be queued.
     * 
     * Callable by any signed origin after [`Config::EarlyBirdBonusDistributionBlock`].
     * 
     * ## Details
     * 
     * 1. Calculates the normalized weights for each pool by calling
     *    [`Pallet::early_bird_normalized_weight`]. Factors for the weight are each pool's
     *    total points and the creation date.
     * 2. Each pool's weight is multiplied by the total reward to determine each pool's reward.
     * 3. The rewards are stored in [`EarlyBirdBonusInfo`] and can be distributed by calling
     *    [`Self::distribute_early_bird_bonus`].
     */
    get isV110(): boolean {
        return this._chain.getCallHash('NominationPools.queue_early_bird_bonus') === '42f1b48e9aea81bc205a1f08cfea41c3c6570661bf0cdf8f1171d9f79d2ca359'
    }

    /**
     * Calculate and prepare early bird bonus if it is ready to be queued.
     * 
     * Callable by any signed origin after [`Config::EarlyBirdBonusDistributionBlock`].
     * 
     * ## Details
     * 
     * 1. Calculates the normalized weights for each pool by calling
     *    [`Pallet::early_bird_normalized_weight`]. Factors for the weight are each pool's
     *    total points and the creation date.
     * 2. Each pool's weight is multiplied by the total reward to determine each pool's reward.
     * 3. The rewards are stored in [`EarlyBirdBonusInfo`] and can be distributed by calling
     *    [`Self::distribute_early_bird_bonus`].
     */
    get asV110(): {poolCount: number} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsSetCommissionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.set_commission')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the commission of a pool.
     * Both a commission percentage and a commission payee must be provided in the `current`
     * tuple. Where a `current` of `None` is provided, any current commission will be removed.
     * 
     * - If a `None` is supplied to `new_commission`, existing commission will be removed.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.set_commission') === 'c2429f4194f36dda4ecdb7c4fb1f8dd1bd10b0c452d0261492e47eb1f03251dc'
    }

    /**
     * Set the commission of a pool.
     * Both a commission percentage and a commission payee must be provided in the `current`
     * tuple. Where a `current` of `None` is provided, any current commission will be removed.
     * 
     * - If a `None` is supplied to `new_commission`, existing commission will be removed.
     */
    get asV100(): {poolId: number, newCommission: ([number, Uint8Array] | undefined)} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the commission of a pool.
     * Both a commission percentage and a commission payee must be provided in the `current`
     * tuple. Where a `current` of `None` is provided, any current commission will be removed.
     * 
     * - If a `None` is supplied to `new_commission`, existing commission will be removed.
     */
    get isV101(): boolean {
        return this._chain.getCallHash('NominationPools.set_commission') === '825adf35526b139bbc581712800062d1cc266892ed4b3b710dc83df9ba85a2aa'
    }

    /**
     * Set the commission of a pool.
     * Both a commission percentage and a commission payee must be provided in the `current`
     * tuple. Where a `current` of `None` is provided, any current commission will be removed.
     * 
     * - If a `None` is supplied to `new_commission`, existing commission will be removed.
     */
    get asV101(): {poolId: number, newCommission: (number | undefined)} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsSetCommissionChangeRateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.set_commission_change_rate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the commission change rate for a pool.
     * 
     * Initial change rate is not bounded, whereas subsequent updates can only be more
     * restrictive than the current.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.set_commission_change_rate') === 'e77d8f06ff6d59a91d329a7cdbc1ac5a27a6a72eb4ee24df4753545b86c9cd85'
    }

    /**
     * Set the commission change rate for a pool.
     * 
     * Initial change rate is not bounded, whereas subsequent updates can only be more
     * restrictive than the current.
     */
    get asV100(): {poolId: number, changeRate: v100.CommissionChangeRate} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsSetCommissionMaxCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.set_commission_max')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the maximum commission of a pool.
     * 
     * - Initial max can be set to any `Perbill`, and only smaller values thereafter.
     * - Current commission will be lowered in the event it is higher than a new max
     *   commission.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.set_commission_max') === '6eb4d2709f88d8a2ee11fbbeaecd1987716bd1b2323a23339e00d70cb343b35b'
    }

    /**
     * Set the maximum commission of a pool.
     * 
     * - Initial max can be set to any `Perbill`, and only smaller values thereafter.
     * - Current commission will be lowered in the event it is higher than a new max
     *   commission.
     */
    get asV100(): {poolId: number, maxCommission: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsSetConfigsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.set_configs')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update configurations for the nomination pools. The origin for this call must be
     * Root.
     * 
     * # Arguments
     * 
     * * `min_join_bond` - Set [`MinJoinBond`].
     * * `min_create_bond` - Set [`MinCreateBond`].
     * * `max_pools` - Set [`MaxPools`].
     * * `max_members` - Set [`MaxPoolMembers`].
     * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.set_configs') === 'ceacec76774b5a08dec5a3b51f18f0ffee64e5eb25040ddf4a5dfa35acacee3f'
    }

    /**
     * Update configurations for the nomination pools. The origin for this call must be
     * Root.
     * 
     * # Arguments
     * 
     * * `min_join_bond` - Set [`MinJoinBond`].
     * * `min_create_bond` - Set [`MinCreateBond`].
     * * `max_pools` - Set [`MaxPools`].
     * * `max_members` - Set [`MaxPoolMembers`].
     * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
     */
    get asV100(): {minJoinBond: v100.ConfigOp, minCreateBond: v100.ConfigOp, globalMaxCommission: v100.Type_359} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update configurations for the nomination pools. Callable only by
     * [`Config::ForceOrigin`].
     * 
     * # Arguments
     * 
     * * `min_join_bond` - Set [`MinJoinBond`].
     * * `min_create_bond` - Set [`MinCreateBond`].
     * * `global_max_commission` - Set [`GlobalMaxCommission`].
     */
    get isV120(): boolean {
        return this._chain.getCallHash('NominationPools.set_configs') === 'f86075711227014dc0748a63de75ce128f211cf40c3b8b40d51a386dd4ed292e'
    }

    /**
     * Update configurations for the nomination pools. Callable only by
     * [`Config::ForceOrigin`].
     * 
     * # Arguments
     * 
     * * `min_join_bond` - Set [`MinJoinBond`].
     * * `min_create_bond` - Set [`MinCreateBond`].
     * * `global_max_commission` - Set [`GlobalMaxCommission`].
     */
    get asV120(): {minJoinBond: v120.ConfigOp, minCreateBond: v120.ConfigOp, globalMaxCommission: v120.Type_409, requiredPayoutCount: v120.Type_409} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsSetStakingInfoCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.set_staking_info')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the annual inflation rate and collator payout cut
     * 
     * Callable only by [`Config::ForceOrigin`]
     */
    get isV105(): boolean {
        return this._chain.getCallHash('NominationPools.set_staking_info') === 'f07f4c21920a1aad9c9e5cb1394241863d7b021cd9d00a185a09bd6342c42fa4'
    }

    /**
     * Set the annual inflation rate and collator payout cut
     * 
     * Callable only by [`Config::ForceOrigin`]
     */
    get asV105(): {info: v105.StakingInfo} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsUnbondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.unbond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
     * implicitly collects the rewards one last time, since not doing so would mean some
     * rewards would be forfeited.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch.
     * 
     * * The pool is blocked and the caller is either the root or state-toggler. This is
     *   refereed to as a kick.
     * * The pool is destroying and the member is not the depositor.
     * * The pool is destroying, the member is the depositor and no other members are in the
     *   pool.
     * 
     * ## Conditions for permissioned dispatch (i.e. the caller is also the
     * `member_account`):
     * 
     * * The caller is not the depositor.
     * * The caller is the depositor, the pool is destroying and no other members are in the
     *   pool.
     * 
     * # Note
     * 
     * If there are too many unlocking chunks to unbond with the pool account,
     * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
     * The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
     * to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
     * are available). However, it may not be possible to release the current unlocking chunks,
     * in which case, the result of this call will likely be the `NoMoreChunks` error from the
     * staking system.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.unbond') === '1bfa8fecb2dccf029b31c8d97441939d345ecd65bf7b4577cdf50b6061139176'
    }

    /**
     * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
     * implicitly collects the rewards one last time, since not doing so would mean some
     * rewards would be forfeited.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch.
     * 
     * * The pool is blocked and the caller is either the root or state-toggler. This is
     *   refereed to as a kick.
     * * The pool is destroying and the member is not the depositor.
     * * The pool is destroying, the member is the depositor and no other members are in the
     *   pool.
     * 
     * ## Conditions for permissioned dispatch (i.e. the caller is also the
     * `member_account`):
     * 
     * * The caller is not the depositor.
     * * The caller is the depositor, the pool is destroying and no other members are in the
     *   pool.
     * 
     * # Note
     * 
     * If there are too many unlocking chunks to unbond with the pool account,
     * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
     * The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
     * to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
     * are available). However, it may not be possible to release the current unlocking chunks,
     * in which case, the result of this call will likely be the `NoMoreChunks` error from the
     * staking system.
     */
    get asV100(): {poolId: number, memberAccount: v100.MultiAddress, unbondingPoints: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsUnbondDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.unbond_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unbonds the deposit
     * 
     * This call is permissionless but certain conditions must be met before the deposit can
     * be unbonded:
     * 
     * - Pool must be in [`PoolState::Destroying`] mode
     * - Deposit points must be the only points in the pool
     * 
     * This will unbond the deposit from the pool.
     */
    get isV101(): boolean {
        return this._chain.getCallHash('NominationPools.unbond_deposit') === 'a662258b1bdb045a915972ea29e9ec0b46cdd5598b0da37b0e70ac766e3735a0'
    }

    /**
     * Unbonds the deposit
     * 
     * This call is permissionless but certain conditions must be met before the deposit can
     * be unbonded:
     * 
     * - Pool must be in [`PoolState::Destroying`] mode
     * - Deposit points must be the only points in the pool
     * 
     * This will unbond the deposit from the pool.
     */
    get asV101(): {poolId: number} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsUnlockEarlyBirdBonusCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.unlock_early_bird_bonus')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unlock early bird bonus to pools. This extrinsic will ensure the
     * EarlyBirdBonusDistributionBlock has passed before the bonus is unlocked.
     * Callable by any signed origin after the bonus has been queued.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('NominationPools.unlock_early_bird_bonus') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Unlock early bird bonus to pools. This extrinsic will ensure the
     * EarlyBirdBonusDistributionBlock has passed before the bonus is unlocked.
     * Callable by any signed origin after the bonus has been queued.
     */
    get asV1022(): null {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsUpdateRolesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.update_roles')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update the roles of the pool.
     * 
     * This function can only be called by the account that holds the pool token
     * 
     * It emits an event, notifying UIs of the role change. This event is quite relevant to
     * most pool members and they should be informed of changes to pool roles.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.update_roles') === 'e95af2c6d635adda7a71c4429f4e3c7b8c113246fa2288c5c5c75c9baf92b319'
    }

    /**
     * Update the roles of the pool.
     * 
     * This function can only be called by the account that holds the pool token
     * 
     * It emits an event, notifying UIs of the role change. This event is quite relevant to
     * most pool members and they should be informed of changes to pool roles.
     */
    get asV100(): {poolId: number, newRoot: v100.Type_360, newNominator: v100.Type_360} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsWithdrawDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.withdraw_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Withdraws the deposit
     * 
     * This call is permissionless and should be called after the deposit has been unbonded
     * 
     * This should be called after the deposit has been unbonded
     */
    get isV101(): boolean {
        return this._chain.getCallHash('NominationPools.withdraw_deposit') === 'a662258b1bdb045a915972ea29e9ec0b46cdd5598b0da37b0e70ac766e3735a0'
    }

    /**
     * Withdraws the deposit
     * 
     * This call is permissionless and should be called after the deposit has been unbonded
     * 
     * This should be called after the deposit has been unbonded
     */
    get asV101(): {poolId: number} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsWithdrawFreeBalanceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.withdraw_free_balance')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfers `amount` from the pool's free balance to `destination`. Only callable by
     * [`Config::ForceOrigin`].
     */
    get isV120(): boolean {
        return this._chain.getCallHash('NominationPools.withdraw_free_balance') === '09c49e7fa270697e91e71c960c03f110426923e49c5b3d7a10a016f94826972f'
    }

    /**
     * Transfers `amount` from the pool's free balance to `destination`. Only callable by
     * [`Config::ForceOrigin`].
     */
    get asV120(): {poolId: number, destination: v120.MultiAddress, amount: bigint} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsWithdrawUnbondedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.withdraw_unbonded')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
     * error is returned.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch
     * 
     * * The pool is in destroy mode and the target is not the depositor.
     * * The target is the depositor and they are the only member in the sub pools.
     * * The pool is blocked and the caller is either the root or state-toggler.
     * 
     * # Conditions for permissioned dispatch
     * 
     * * The caller is the target and they are not the depositor.
     * 
     * # Note
     * 
     * If the target is the depositor, the pool will be destroyed.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('NominationPools.withdraw_unbonded') === 'd3c3feb452d3302bc2d65a2f6382e13262a88ccec3555b84e1834a45cefe7171'
    }

    /**
     * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
     * error is returned.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch
     * 
     * * The pool is in destroy mode and the target is not the depositor.
     * * The target is the depositor and they are the only member in the sub pools.
     * * The pool is blocked and the caller is either the root or state-toggler.
     * 
     * # Conditions for permissioned dispatch
     * 
     * * The caller is the target and they are not the depositor.
     * 
     * # Note
     * 
     * If the target is the depositor, the pool will be destroyed.
     */
    get asV100(): {poolId: number, memberAccount: v100.MultiAddress, numSlashingSpans: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class OrmlXcmSendAsSovereignCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'OrmlXcm.send_as_sovereign')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('OrmlXcm.send_as_sovereign') === '9c814457e6c06e355f17d8e2e59924a734ef38dfc7852490ba89fd5b845b6f48'
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get asMatrixEnjinV603(): {dest: matrixEnjinV603.VersionedMultiLocation, message: matrixEnjinV603.VersionedXcm} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class ParaInherentEnterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParaInherent.enter')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Enter the paras inherent. This will process bitfields and backed candidates.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ParaInherent.enter') === 'a9d507be3ededfc111412179310cc428ca61464dbaf93e10505bd1d8f6af4d8e'
    }

    /**
     * Enter the paras inherent. This will process bitfields and backed candidates.
     */
    get asV100(): {data: v100.V2InherentData} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainSystemAuthorizeUpgradeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainSystem.authorize_upgrade')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     * 
     * The `check_version` parameter sets a boolean flag for whether or not the runtime's spec
     * version and name should be verified on upgrade. Since the authorization only has a hash,
     * it cannot actually perform the verification.
     * 
     * This call requires Root origin.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('ParachainSystem.authorize_upgrade') === '5c55d10848d503323d2e442c7afe37bb9673cbd625584442853911cb797f840c'
    }

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     * 
     * The `check_version` parameter sets a boolean flag for whether or not the runtime's spec
     * version and name should be verified on upgrade. Since the authorization only has a hash,
     * it cannot actually perform the verification.
     * 
     * This call requires Root origin.
     */
    get asMatrixEnjinV603(): {codeHash: Uint8Array, checkVersion: boolean} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainSystemEnactAuthorizedUpgradeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainSystem.enact_authorized_upgrade')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     * 
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     * 
     * Note that this function will not apply the new `code`, but only attempt to schedule the
     * upgrade with the Relay Chain.
     * 
     * All origins are allowed.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('ParachainSystem.enact_authorized_upgrade') === '7bf3d4785d9be7a4872f39cbd3702a66e16f7ee01e4446fb4a05624dc0ec4c93'
    }

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     * 
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     * 
     * Note that this function will not apply the new `code`, but only attempt to schedule the
     * upgrade with the Relay Chain.
     * 
     * All origins are allowed.
     */
    get asMatrixEnjinV603(): {code: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainSystemSetValidationDataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainSystem.set_validation_data')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the current validation data.
     * 
     * This should be invoked exactly once per block. It will panic at the finalization
     * phase if the call was not invoked.
     * 
     * The dispatch origin for this call must be `Inherent`
     * 
     * As a side effect, this function upgrades the current validation function
     * if the appropriate time has come.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('ParachainSystem.set_validation_data') === 'df843f97e4c625e033541d5f205c5889f3131bdb4549570310e924d96769c1cd'
    }

    /**
     * Set the current validation data.
     * 
     * This should be invoked exactly once per block. It will panic at the finalization
     * phase if the call was not invoked.
     * 
     * The dispatch origin for this call must be `Inherent`
     * 
     * As a side effect, this function upgrades the current validation function
     * if the appropriate time has come.
     */
    get asMatrixEnjinV603(): {data: matrixEnjinV603.ParachainInherentData} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainSystemSudoSendUpwardMessageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainSystem.sudo_send_upward_message')
        this._chain = ctx._chain
        this.call = call
    }

    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('ParachainSystem.sudo_send_upward_message') === '34457b6daded32ddc4ec3a5a21e34b9af8dcd7d190a5a7833fa8a7ed53b31206'
    }

    get asMatrixEnjinV603(): {message: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasAddTrustedValidationCodeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.add_trusted_validation_code')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Adds the validation code to the storage.
     * 
     * The code will not be added if it is already present. Additionally, if PVF pre-checking
     * is running for that code, it will be instantly accepted.
     * 
     * Otherwise, the code will be added into the storage. Note that the code will be added
     * into storage with reference count 0. This is to account the fact that there are no users
     * for this code yet. The caller will have to make sure that this code eventually gets
     * used by some parachain or removed from the storage to avoid storage leaks. For the latter
     * prefer to use the `poke_unused_validation_code` dispatchable to raw storage manipulation.
     * 
     * This function is mainly meant to be used for upgrading parachains that do not follow
     * the go-ahead signal while the PVF pre-checking feature is enabled.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Paras.add_trusted_validation_code') === '0ad78b20451a91789302238ce78bb346eb02be5596707efead661c7e083ab212'
    }

    /**
     * Adds the validation code to the storage.
     * 
     * The code will not be added if it is already present. Additionally, if PVF pre-checking
     * is running for that code, it will be instantly accepted.
     * 
     * Otherwise, the code will be added into the storage. Note that the code will be added
     * into storage with reference count 0. This is to account the fact that there are no users
     * for this code yet. The caller will have to make sure that this code eventually gets
     * used by some parachain or removed from the storage to avoid storage leaks. For the latter
     * prefer to use the `poke_unused_validation_code` dispatchable to raw storage manipulation.
     * 
     * This function is mainly meant to be used for upgrading parachains that do not follow
     * the go-ahead signal while the PVF pre-checking feature is enabled.
     */
    get asV100(): {validationCode: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasForceNoteNewHeadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.force_note_new_head')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Note a new block head for para within the context of the current block.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Paras.force_note_new_head') === '630e70696dbb809d3a272dfc9da9bfd0656f82541be24c57ee1c634d2645017c'
    }

    /**
     * Note a new block head for para within the context of the current block.
     */
    get asV100(): {para: number, newHead: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasForceQueueActionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.force_queue_action')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Put a parachain directly into the next session's action queue.
     * We can't queue it any sooner than this without going into the
     * initializer...
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Paras.force_queue_action') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     * Put a parachain directly into the next session's action queue.
     * We can't queue it any sooner than this without going into the
     * initializer...
     */
    get asV100(): {para: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasForceScheduleCodeUpgradeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.force_schedule_code_upgrade')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule an upgrade as if it was scheduled in the given relay parent block.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Paras.force_schedule_code_upgrade') === 'a8977843dd9b948a1a0495c6070fe0b2e8b1b4aa07d85a8f196863ca04a03a6b'
    }

    /**
     * Schedule an upgrade as if it was scheduled in the given relay parent block.
     */
    get asV100(): {para: number, newCode: Uint8Array, relayParentNumber: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasForceSetCurrentCodeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.force_set_current_code')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the storage for the parachain validation code immediately.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Paras.force_set_current_code') === '0b5bbf1b361dddb4826c2c1c0065a52b490f97f282bfc036e9cfc8d1934f8139'
    }

    /**
     * Set the storage for the parachain validation code immediately.
     */
    get asV100(): {para: number, newCode: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasForceSetCurrentHeadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.force_set_current_head')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the storage for the current parachain head data immediately.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Paras.force_set_current_head') === '630e70696dbb809d3a272dfc9da9bfd0656f82541be24c57ee1c634d2645017c'
    }

    /**
     * Set the storage for the current parachain head data immediately.
     */
    get asV100(): {para: number, newHead: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasIncludePvfCheckStatementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.include_pvf_check_statement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Includes a statement for a PVF pre-checking vote. Potentially, finalizes the vote and
     * enacts the results if that was the last vote before achieving the supermajority.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Paras.include_pvf_check_statement') === 'ba297981fae49e9a7feef6b5c5946ef2256fa44b2bbba936e20f4e5a433b9b3f'
    }

    /**
     * Includes a statement for a PVF pre-checking vote. Potentially, finalizes the vote and
     * enacts the results if that was the last vote before achieving the supermajority.
     */
    get asV100(): {stmt: v100.V2PvfCheckStatement, signature: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasPokeUnusedValidationCodeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.poke_unused_validation_code')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the validation code from the storage iff the reference count is 0.
     * 
     * This is better than removing the storage directly, because it will not remove the code
     * that was suddenly got used by some parachain while this dispatchable was pending
     * dispatching.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Paras.poke_unused_validation_code') === '6a0ee0e91dfac4ad12f1a7c0b407204956c918eeb7dbd4d37d9c4c210e9558de'
    }

    /**
     * Remove the validation code from the storage iff the reference count is 0.
     * 
     * This is better than removing the storage directly, because it will not remove the code
     * that was suddenly got used by some parachain while this dispatchable was pending
     * dispatching.
     */
    get asV100(): {validationCodeHash: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasDisputesForceUnfreezeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasDisputes.force_unfreeze')
        this._chain = ctx._chain
        this.call = call
    }

    get isV100(): boolean {
        return this._chain.getCallHash('ParasDisputes.force_unfreeze') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    get asV100(): null {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasSlashingReportDisputeLostUnsignedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasSlashing.report_dispute_lost_unsigned')
        this._chain = ctx._chain
        this.call = call
    }

    get isV100(): boolean {
        return this._chain.getCallHash('ParasSlashing.report_dispute_lost_unsigned') === '7ba6f97498e62b4b0aee53d530cb8e51018087d48a0c03cd5bfefe0897be15b6'
    }

    get asV100(): {disputeProof: v100.DisputeProof, keyOwnerProof: v100.MembershipProof} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasSudoWrapperSudoEstablishHrmpChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasSudoWrapper.sudo_establish_hrmp_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Forcefully establish a channel from the sender to the recipient.
     * 
     * This is equivalent to sending an `Hrmp::hrmp_init_open_channel` extrinsic followed by
     * `Hrmp::hrmp_accept_open_channel`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ParasSudoWrapper.sudo_establish_hrmp_channel') === '1d371021acfdf0ba68e1334173a7b34a1c083269c2b7e3f6024692dbd7118650'
    }

    /**
     * Forcefully establish a channel from the sender to the recipient.
     * 
     * This is equivalent to sending an `Hrmp::hrmp_init_open_channel` extrinsic followed by
     * `Hrmp::hrmp_accept_open_channel`.
     */
    get asV100(): {sender: number, recipient: number, maxCapacity: number, maxMessageSize: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasSudoWrapperSudoQueueDownwardXcmCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasSudoWrapper.sudo_queue_downward_xcm')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Send a downward XCM to the given para.
     * 
     * The given parachain should exist and the payload should not exceed the preconfigured size
     * `config.max_downward_message_size`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ParasSudoWrapper.sudo_queue_downward_xcm') === 'a0fa50f01304d00ba373312fe8c89c409929960d11ceb913fc74509f05723868'
    }

    /**
     * Send a downward XCM to the given para.
     * 
     * The given parachain should exist and the payload should not exceed the preconfigured size
     * `config.max_downward_message_size`.
     */
    get asV100(): {id: number, xcm: v100.VersionedXcm} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasSudoWrapperSudoScheduleParaCleanupCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasSudoWrapper.sudo_schedule_para_cleanup')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule a para to be cleaned up at the start of the next session.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ParasSudoWrapper.sudo_schedule_para_cleanup') === '0fb20b5afc6a2830162f8daea8abc92a50d6411d977d5e83e205bdeb2dcd6598'
    }

    /**
     * Schedule a para to be cleaned up at the start of the next session.
     */
    get asV100(): {id: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasSudoWrapperSudoScheduleParaInitializeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasSudoWrapper.sudo_schedule_para_initialize')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule a para to be initialized at the start of the next session.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ParasSudoWrapper.sudo_schedule_para_initialize') === '7b2d9894d41d92d0c418dc3846e7aae5a4724e2963509885c2b8c3c555d748a2'
    }

    /**
     * Schedule a para to be initialized at the start of the next session.
     */
    get asV100(): {id: number, genesis: v100.ParaGenesisArgs} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasSudoWrapperSudoScheduleParachainDowngradeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasSudoWrapper.sudo_schedule_parachain_downgrade')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Downgrade a parachain to a parathread
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ParasSudoWrapper.sudo_schedule_parachain_downgrade') === '0fb20b5afc6a2830162f8daea8abc92a50d6411d977d5e83e205bdeb2dcd6598'
    }

    /**
     * Downgrade a parachain to a parathread
     */
    get asV100(): {id: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasSudoWrapperSudoScheduleParathreadUpgradeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasSudoWrapper.sudo_schedule_parathread_upgrade')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Upgrade a parathread to a parachain
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ParasSudoWrapper.sudo_schedule_parathread_upgrade') === '0fb20b5afc6a2830162f8daea8abc92a50d6411d977d5e83e205bdeb2dcd6598'
    }

    /**
     * Upgrade a parathread to a parachain
     */
    get asV100(): {id: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmExecuteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.execute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('PolkadotXcm.execute') === 'a1da862b5d9db8fd6f3072da00ea4e66052f97b5dcfb87e58d49ca1fd1f1ef90'
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get asMatrixEnjinV603(): {message: matrixEnjinV603.Type_353, maxWeight: matrixEnjinV603.Weight} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmForceDefaultXcmVersionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.force_default_xcm_version')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_default_xcm_version') === 'd4bcd64cc4c940eafd14296ec6cbfb7d27e4ca42a4c7dab4c0b89f6c8102257e'
    }

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     */
    get asMatrixEnjinV603(): {maybeXcmVersion: (number | undefined)} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmForceSubscribeVersionNotifyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.force_subscribe_version_notify')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_subscribe_version_notify') === '0448b7eed1a6d9cd0a489ea792df94cc3ce5a37e203f19b1a5a0c4516a8d696c'
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get asMatrixEnjinV603(): {location: matrixEnjinV603.VersionedMultiLocation} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmForceSuspensionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.force_suspension')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set or unset the global suspension state of the XCM executor.
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_suspension') === '8ed7e51efeeeccee1e0e2e2dca71da38a9e5bdab470452a56d790711652babc1'
    }

    /**
     * Set or unset the global suspension state of the XCM executor.
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     */
    get asMatrixEnjinV603(): {suspended: boolean} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmForceUnsubscribeVersionNotifyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.force_unsubscribe_version_notify')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_unsubscribe_version_notify') === '0448b7eed1a6d9cd0a489ea792df94cc3ce5a37e203f19b1a5a0c4516a8d696c'
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get asMatrixEnjinV603(): {location: matrixEnjinV603.VersionedMultiLocation} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmForceXcmVersionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.force_xcm_version')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_xcm_version') === '998b5a56e7662d76955b41c2526c2219fe8304fec6501afa115db1bd705e7ff6'
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get asMatrixEnjinV603(): {location: matrixEnjinV603.V3MultiLocation, xcmVersion: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmLimitedReserveTransferAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.limited_reserve_transfer_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('PolkadotXcm.limited_reserve_transfer_assets') === 'c5f45c1775bd92c7b425f46c92a6891334f7df5ae2518cd2c0a106447da3bbd9'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asMatrixEnjinV603(): {dest: matrixEnjinV603.VersionedMultiLocation, beneficiary: matrixEnjinV603.VersionedMultiLocation, assets: matrixEnjinV603.VersionedMultiAssets, feeAssetItem: number, weightLimit: matrixEnjinV603.V3WeightLimit} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmLimitedTeleportAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.limited_teleport_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('PolkadotXcm.limited_teleport_assets') === 'c5f45c1775bd92c7b425f46c92a6891334f7df5ae2518cd2c0a106447da3bbd9'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asMatrixEnjinV603(): {dest: matrixEnjinV603.VersionedMultiLocation, beneficiary: matrixEnjinV603.VersionedMultiLocation, assets: matrixEnjinV603.VersionedMultiAssets, feeAssetItem: number, weightLimit: matrixEnjinV603.V3WeightLimit} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmReserveTransferAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.reserve_transfer_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('PolkadotXcm.reserve_transfer_assets') === 'ebd99cece75c1b0fc48830527bc513cf672b8d0c6c0c505498bba5c8c5e1617c'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asMatrixEnjinV603(): {dest: matrixEnjinV603.VersionedMultiLocation, beneficiary: matrixEnjinV603.VersionedMultiLocation, assets: matrixEnjinV603.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmSendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.send')
        this._chain = ctx._chain
        this.call = call
    }

    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('PolkadotXcm.send') === '9c814457e6c06e355f17d8e2e59924a734ef38dfc7852490ba89fd5b845b6f48'
    }

    get asMatrixEnjinV603(): {dest: matrixEnjinV603.VersionedMultiLocation, message: matrixEnjinV603.VersionedXcm} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmTeleportAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.teleport_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('PolkadotXcm.teleport_assets') === 'ebd99cece75c1b0fc48830527bc513cf672b8d0c6c0c505498bba5c8c5e1617c'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asMatrixEnjinV603(): {dest: matrixEnjinV603.VersionedMultiLocation, beneficiary: matrixEnjinV603.VersionedMultiLocation, assets: matrixEnjinV603.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PoolsMutatePoolsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Pools.mutate_pools')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Mutate the pools. Can only be called by root.
     * 
     * # Errors
     * 
     * - [`Error::InvalidFeeShares`] if the fee shares do not add up to 100%
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Pools.mutate_pools') === '59397bde495bc4bf6e9ce90d9d117f187d090806cb3f83eb4b3669141aabffed'
    }

    /**
     * Mutate the pools. Can only be called by root.
     * 
     * # Errors
     * 
     * - [`Error::InvalidFeeShares`] if the fee shares do not add up to 100%
     */
    get asMatrixEnjinV603(): {mutation: matrixEnjinV603.PoolsMutation} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageNotePreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.note_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Register a preimage on-chain.
     * 
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Preimage.note_preimage') === 'fb6f9f7fd683160ab20dcde42ca8f757bc13845dc544f497e534fcf19c270a46'
    }

    /**
     * Register a preimage on-chain.
     * 
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     */
    get asMatrixEnjinV603(): {bytes: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageRequestPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.request_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     * 
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Preimage.request_preimage') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     * 
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     */
    get asMatrixEnjinV603(): {hash: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageUnnotePreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.unnote_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Clear an unrequested preimage from the runtime storage.
     * 
     * If `len` is provided, then it will be a much cheaper operation.
     * 
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Preimage.unnote_preimage') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     * Clear an unrequested preimage from the runtime storage.
     * 
     * If `len` is provided, then it will be a much cheaper operation.
     * 
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     */
    get asMatrixEnjinV603(): {hash: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageUnrequestPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.unrequest_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Clear a previously made request for a preimage.
     * 
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Preimage.unrequest_preimage') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     * Clear a previously made request for a preimage.
     * 
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     */
    get asMatrixEnjinV603(): {hash: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaCancelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.cancel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel an ongoing referendum.
     * 
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Cancelled`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Referenda.cancel') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Cancel an ongoing referendum.
     * 
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Cancelled`.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaKillCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.kill')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel an ongoing referendum and slash the deposits.
     * 
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Killed` and `DepositSlashed`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Referenda.kill') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Cancel an ongoing referendum and slash the deposits.
     * 
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Killed` and `DepositSlashed`.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaNudgeReferendumCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.nudge_referendum')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Referenda.nudge_referendum') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaOneFewerDecidingCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.one_fewer_deciding')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Advance a track onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     * 
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Referenda.one_fewer_deciding') === '75d849d1c0275ad91cee68e888f612b619530fe1a9f1955df3cd6d91e4d4ed1d'
    }

    /**
     * Advance a track onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     * 
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    get asV100(): {track: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaPlaceDecisionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.place_decision_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Post the Decision Deposit for a referendum.
     * 
     * - `origin`: must be `Signed` and the account must have funds available for the
     *   referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     *   posted.
     * 
     * Emits `DecisionDepositPlaced`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Referenda.place_decision_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Post the Decision Deposit for a referendum.
     * 
     * - `origin`: must be `Signed` and the account must have funds available for the
     *   referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     *   posted.
     * 
     * Emits `DecisionDepositPlaced`.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaRefundDecisionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.refund_decision_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     *   refunded.
     * 
     * Emits `DecisionDepositRefunded`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Referenda.refund_decision_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     *   refunded.
     * 
     * Emits `DecisionDepositRefunded`.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaRefundSubmissionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.refund_submission_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     *   refunded.
     * 
     * Emits `SubmissionDepositRefunded`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Referenda.refund_submission_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     *   refunded.
     * 
     * Emits `SubmissionDepositRefunded`.
     */
    get asV100(): {index: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaSetMetadataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.set_metadata')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set or clear metadata of a referendum.
     * 
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     *   metadata of a finished referendum.
     * - `index`:  The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Referenda.set_metadata') === '3130106e44cfd70dbb871159c7a9caa9e760fbb1b51fd56f1cc4d461eeca38c2'
    }

    /**
     * Set or clear metadata of a referendum.
     * 
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     *   metadata of a finished referendum.
     * - `index`:  The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     */
    get asV104(): {index: number, maybeHash: (Uint8Array | undefined)} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaSubmitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.submit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Referenda.submit') === 'c6b1866b08bcf6b99803902eeac819703f700657631221410ba67d5facc7a2f1'
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get asV100(): {proposalOrigin: v100.OriginCaller, proposal: v100.Bounded, enactmentMoment: v100.DispatchTime} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Referenda.submit') === '5b0326c13e12b7d51945c5a2ce3b43a61b1185e72b4e7d43b5d12c3e8d214b34'
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get asV105(): {proposalOrigin: v105.OriginCaller, proposal: v105.Bounded, enactmentMoment: v105.DispatchTime} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarAddLockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.add_lock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add a manager lock from a para. This will prevent the manager of a
     * para to deregister or swap a para.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Registrar.add_lock') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     * Add a manager lock from a para. This will prevent the manager of a
     * para to deregister or swap a para.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get asV100(): {para: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarDeregisterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.deregister')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Deregister a Para Id, freeing all data and returning any deposit.
     * 
     * The caller must be Root, the `para` owner, or the `para` itself. The para must be a parathread.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Registrar.deregister') === '0fb20b5afc6a2830162f8daea8abc92a50d6411d977d5e83e205bdeb2dcd6598'
    }

    /**
     * Deregister a Para Id, freeing all data and returning any deposit.
     * 
     * The caller must be Root, the `para` owner, or the `para` itself. The para must be a parathread.
     */
    get asV100(): {id: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarForceRegisterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.force_register')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force the registration of a Para Id on the relay chain.
     * 
     * This function must be called by a Root origin.
     * 
     * The deposit taken can be specified for this registration. Any `ParaId`
     * can be registered, including sub-1000 IDs which are System Parachains.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Registrar.force_register') === 'a5b6a45ddb0597c424abb7f3f416971b6f9078847fb58371773188cc269b135b'
    }

    /**
     * Force the registration of a Para Id on the relay chain.
     * 
     * This function must be called by a Root origin.
     * 
     * The deposit taken can be specified for this registration. Any `ParaId`
     * can be registered, including sub-1000 IDs which are System Parachains.
     */
    get asV100(): {who: Uint8Array, deposit: bigint, id: number, genesisHead: Uint8Array, validationCode: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarRegisterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.register')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Register head data and validation code for a reserved Para Id.
     * 
     * ## Arguments
     * - `origin`: Must be called by a `Signed` origin.
     * - `id`: The para ID. Must be owned/managed by the `origin` signing account.
     * - `genesis_head`: The genesis head data of the parachain/thread.
     * - `validation_code`: The initial validation code of the parachain/thread.
     * 
     * ## Deposits/Fees
     * The origin signed account must reserve a corresponding deposit for the registration. Anything already
     * reserved previously for this para ID is accounted for.
     * 
     * ## Events
     * The `Registered` event is emitted in case of success.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Registrar.register') === '3a4cf817f8bb406cb7985618b2fb45aaf0a9fffe415f2a1be091d56bb241889b'
    }

    /**
     * Register head data and validation code for a reserved Para Id.
     * 
     * ## Arguments
     * - `origin`: Must be called by a `Signed` origin.
     * - `id`: The para ID. Must be owned/managed by the `origin` signing account.
     * - `genesis_head`: The genesis head data of the parachain/thread.
     * - `validation_code`: The initial validation code of the parachain/thread.
     * 
     * ## Deposits/Fees
     * The origin signed account must reserve a corresponding deposit for the registration. Anything already
     * reserved previously for this para ID is accounted for.
     * 
     * ## Events
     * The `Registered` event is emitted in case of success.
     */
    get asV100(): {id: number, genesisHead: Uint8Array, validationCode: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarRemoveLockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.remove_lock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a manager lock from a para. This will allow the manager of a
     * previously locked para to deregister or swap a para without using governance.
     * 
     * Can only be called by the Root origin or the parachain.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Registrar.remove_lock') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     * Remove a manager lock from a para. This will allow the manager of a
     * previously locked para to deregister or swap a para without using governance.
     * 
     * Can only be called by the Root origin or the parachain.
     */
    get asV100(): {para: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarReserveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.reserve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Reserve a Para Id on the relay chain.
     * 
     * This function will reserve a new Para Id to be owned/managed by the origin account.
     * The origin account is able to register head data and validation code using `register` to create
     * a parathread. Using the Slots pallet, a parathread can then be upgraded to get a parachain slot.
     * 
     * ## Arguments
     * - `origin`: Must be called by a `Signed` origin. Becomes the manager/owner of the new para ID.
     * 
     * ## Deposits/Fees
     * The origin must reserve a deposit of `ParaDeposit` for the registration.
     * 
     * ## Events
     * The `Reserved` event is emitted in case of success, which provides the ID reserved for use.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Registrar.reserve') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Reserve a Para Id on the relay chain.
     * 
     * This function will reserve a new Para Id to be owned/managed by the origin account.
     * The origin account is able to register head data and validation code using `register` to create
     * a parathread. Using the Slots pallet, a parathread can then be upgraded to get a parachain slot.
     * 
     * ## Arguments
     * - `origin`: Must be called by a `Signed` origin. Becomes the manager/owner of the new para ID.
     * 
     * ## Deposits/Fees
     * The origin must reserve a deposit of `ParaDeposit` for the registration.
     * 
     * ## Events
     * The `Reserved` event is emitted in case of success, which provides the ID reserved for use.
     */
    get asV100(): null {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarScheduleCodeUpgradeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.schedule_code_upgrade')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule a parachain upgrade.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Registrar.schedule_code_upgrade') === '0b5bbf1b361dddb4826c2c1c0065a52b490f97f282bfc036e9cfc8d1934f8139'
    }

    /**
     * Schedule a parachain upgrade.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get asV100(): {para: number, newCode: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarSetCurrentHeadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.set_current_head')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the parachain's current head.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Registrar.set_current_head') === '630e70696dbb809d3a272dfc9da9bfd0656f82541be24c57ee1c634d2645017c'
    }

    /**
     * Set the parachain's current head.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get asV100(): {para: number, newHead: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarSwapCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.swap')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Swap a parachain with another parachain or parathread.
     * 
     * The origin must be Root, the `para` owner, or the `para` itself.
     * 
     * The swap will happen only if there is already an opposite swap pending. If there is not,
     * the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
     * 
     * The `ParaId`s remain mapped to the same head data and code so external code can rely on
     * `ParaId` to be a long-term identifier of a notional "parachain". However, their
     * scheduling info (i.e. whether they're a parathread or parachain), auction information
     * and the auction deposit are switched.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Registrar.swap') === '6feebc54e6390627dc0adcf3db1cd4a5b837a30257a2bb93cd4268cad6b4957e'
    }

    /**
     * Swap a parachain with another parachain or parathread.
     * 
     * The origin must be Root, the `para` owner, or the `para` itself.
     * 
     * The swap will happen only if there is already an opposite swap pending. If there is not,
     * the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
     * 
     * The `ParaId`s remain mapped to the same head data and code so external code can rely on
     * `ParaId` to be a long-term identifier of a notional "parachain". However, their
     * scheduling info (i.e. whether they're a parathread or parachain), auction information
     * and the auction deposit are switched.
     */
    get asV100(): {id: number, other: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerCancelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.cancel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel an anonymously scheduled task.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Scheduler.cancel') === '4186e24556a58b04e04d6d697a530eedf78f255da1ba9d84df6511dd6d6465f7'
    }

    /**
     * Cancel an anonymously scheduled task.
     */
    get asMatrixEnjinV603(): {when: number, index: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerCancelNamedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.cancel_named')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel a named scheduled task.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Scheduler.cancel_named') === '2a01c4c05d6bf45e0dc267bd7f6e27df3b3e4b23af7982734357c4de87ef690c'
    }

    /**
     * Cancel a named scheduled task.
     */
    get asMatrixEnjinV603(): {id: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Anonymously schedule a task.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '9ead51e8789a3137eb65ffd312030d985839acb65959af94d041ddb3641c275e'
    }

    /**
     * Anonymously schedule a task.
     */
    get asMatrixEnjinV603(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV603.Call} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '7f329625ae623fd003651acd6bf08e3d31050b1cecbf2408f0d4433724f9a9d1'
    }

    /**
     * Anonymously schedule a task.
     */
    get asMatrixEnjinV1000(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV1000.Call} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'fc09eddb6d91c7b8bad72f7a6375412a4e833c2ad298540e721a84c11d3ef09e'
    }

    /**
     * Anonymously schedule a task.
     */
    get asMatrixEnjinV1003(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV1003.Call} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'b30392fbb46a904df23b7df8b7b10bc77f2c897c21468651f89b294a53dd1a79'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV100(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v100.Call} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '8bb410b8c7598775926ea937a1f00a97a11e6257819c63e35509893c40410f3e'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV101(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v101.Call} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '2023c36e6053f4fa00657d0ddff91550f25ec196735b6e0c876e26852eac9f0e'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV102(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v102.Call} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '0b0641f52d38920bc3b8c6597211cdc6ce50a51447be0d321501c41a1a7b5bfc'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV103(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v103.Call} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '24b24237185e043d8fb8b30be10c36376a174d6ac67a135387183e792d768e3f'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV104(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v104.Call} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'f2493ad0d11576a8110efbf7007351335993a1f9dddc4571d5974041fec80039'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV105(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v105.Call} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'ccff99056f47effc653522457fc40d3699c9840e4891314f0efd801402ca9162'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV106(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v106.Call} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '7ed91632d0870d7529b1a7f69cbb8f5e8c53ca0face35beb4316a0fb26cf441b'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV110(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v110.Call} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '03666c967006130958e67c1e7c48d69f60d6be8aee388e8f75af8bb582518df9'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV120(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v120.Call} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '0be1a3c5498c1591486b3d817e25f52d6ddbd1b0bcf9d71e969c2309a6357197'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV1021(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1021.Call} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'f70083b1a18a9942cf7413b04786821ef71cb7ac294b83985a85671941022e1d'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV1022(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1022.Call} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '1f363b91a60c420dd516036cea920b6aed1be6a9735d46e2284e6ab3025d4826'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV1023(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1023.Call} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleAfterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule_after')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'db1dd1a974333e3537ef8a7e9be7a7b3dff3645ba0fa5fec6f24a4abb9fb13d2'
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get asMatrixEnjinV603(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV603.Call} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'e527e6948e1df4546798e8df19338e0b5ad5ee39729c2030b0770a7e1a457a98'
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get asMatrixEnjinV1000(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV1000.Call} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'cf6f15e7b1ad9ca1aaabd41aab7e4a9ba187b98441ebcf6803ecd6542f5de498'
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get asMatrixEnjinV1003(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV1003.Call} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '7d053f283e6cfec504c59428f86f0925ca81376c86f0fd8ad0e4028bde00b7ff'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV100(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v100.Call} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'f5744eef6f617ad076695fdd876ee7a97910e0b54a3f93a861c04521fe0dff8f'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV101(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v101.Call} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'feacbd91fdfcc77bf733012b980c7c4001eec8915e66d15b18e8f9164952479c'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV102(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v102.Call} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '144bb513895b89ca8667a7c45942225c84ccddd573b4b9c31f1cbed43aa9e6dd'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV103(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v103.Call} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '5170aef5cb560c69297a4a6e5557202b5b8a64da08a40f86994751a65f6ecc09'
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get asV104(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v104.Call} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'f5d629efa0c803eb6d9c38f017fb7a2ea1be3672543eb9b6cc67f76831a937ea'
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get asV105(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v105.Call} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '91d27c396e0efc4321ec6c6da8c93646b98a28873efc519a2a9d4f182d9398d5'
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get asV106(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v106.Call} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'c0cc6e30ef5e0fc2383aafd7e3b3d45b31252c23d3e615e41f2d5b731aab1c4d'
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get asV110(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v110.Call} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '68131bcb0da0a49bc92871b965ee0ed2cec46eb1c9d2088ca18763edd638d3c6'
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get asV120(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v120.Call} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '5c37f5b2e4ee6142d020a9f33f72caa9dca6fdf968e453597e55cc3cd3267240'
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get asV1021(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1021.Call} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'f95caa100fca227ce368df111218eb2647632581e4c8fdd69e9d3f7518065f8d'
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get asV1022(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1022.Call} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '8314a21905102bbd8d5af69e2d6f8e568ddc3128c11b3f3fae45578b913f0514'
    }

    /**
     * Anonymously schedule a task after a delay.
     */
    get asV1023(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1023.Call} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleNamedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule_named')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule a named task.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'ff2f6192f36378a16f209b59270981bff1b4af822548f815e44f8059cf8d13cf'
    }

    /**
     * Schedule a named task.
     */
    get asMatrixEnjinV603(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV603.Call} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'beddeee68109fc77fb091809eaa3317ca0ca597596687065c3da1f76eca3becb'
    }

    /**
     * Schedule a named task.
     */
    get asMatrixEnjinV1000(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV1000.Call} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '58cb9ac696f6224c3105520f25368eababad88f8e30a2b3dffdc34f276480446'
    }

    /**
     * Schedule a named task.
     */
    get asMatrixEnjinV1003(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV1003.Call} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '9d49e86aba9ed25f0d348d8984ce543169eb065db9733f48d07fafb7eb574815'
    }

    /**
     * Schedule a named task.
     */
    get asV100(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v100.Call} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '5e96f98a727829d54618b31123930a67ab6b26fefeef5f64129c80594dec411f'
    }

    /**
     * Schedule a named task.
     */
    get asV101(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v101.Call} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '937f454ff5a3d1b97aa8969dcac4fd7a83e3d496e96d5fed2ac4e94425016b09'
    }

    /**
     * Schedule a named task.
     */
    get asV102(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v102.Call} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'eea11958e47e3cc6310fc98a841bde0ba6889ab2cd343183184cccb43e42b150'
    }

    /**
     * Schedule a named task.
     */
    get asV103(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v103.Call} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'e5dbb516347ebc58ae355b8fd346b754cc7d099caef87296b96cac757b232176'
    }

    /**
     * Schedule a named task.
     */
    get asV104(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v104.Call} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'a5544b1e5b0b24249515887081450be66056a2bcab6c6a99fee766f26e5effb4'
    }

    /**
     * Schedule a named task.
     */
    get asV105(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v105.Call} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '5019d9457e40aa102030c67396cb186d43658e33788706e95ec51e696fb6047c'
    }

    /**
     * Schedule a named task.
     */
    get asV106(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v106.Call} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'f47949223db0b5998fcafbd56ec90eeed0bc2b87fb9da8e2553034edadf5f156'
    }

    /**
     * Schedule a named task.
     */
    get asV110(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v110.Call} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '4ebcf970d0cc61cfa078119810d9ce7514852b38de13e305dbf7950a680b1046'
    }

    /**
     * Schedule a named task.
     */
    get asV120(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v120.Call} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'a7875ece9d1aaf99dee32859adba95584e89e3797a80e42509589efe8907957d'
    }

    /**
     * Schedule a named task.
     */
    get asV1021(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1021.Call} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'b4c164688531373d404a1c822a31b4927aa00b90704336fe8d8926f03926a4d9'
    }

    /**
     * Schedule a named task.
     */
    get asV1022(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1022.Call} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '300def6182e7d9249de8f85b6139b8fa9e4b98817251ffa73adc2a606af5aa33'
    }

    /**
     * Schedule a named task.
     */
    get asV1023(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1023.Call} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleNamedAfterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule_named_after')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule a named task after a delay.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'e23744413dedb66d248707e0bb955cda96bc3ce3724aaaf5270aa6ee579c2cca'
    }

    /**
     * Schedule a named task after a delay.
     */
    get asMatrixEnjinV603(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV603.Call} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '1c40a76f1d411f5e9af26ecc978d89eb1e5ab76c848f75ef69d272a2ed2c4c72'
    }

    /**
     * Schedule a named task after a delay.
     */
    get asMatrixEnjinV1000(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV1000.Call} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '587e593dc28540a462370349b9b8ce58c19fbe122202f60b635f7caba1fc6c99'
    }

    /**
     * Schedule a named task after a delay.
     */
    get asMatrixEnjinV1003(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: matrixEnjinV1003.Call} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'a810dbe66018d91e40e1be10942cbf53b10060781a91c54d651cfff6d5b4c6a8'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV100(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v100.Call} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'f03a239d61cfefd67d9348ffec7b12739e1dbbfc731904a0cf6b916b3fb1baf9'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV101(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v101.Call} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '6b93f7c27a47cad8dd7d6a4eb919434645faec7a917bd857451b8c5fa060f53c'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV102(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v102.Call} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '3017c53ff6a1a9cfa6f95d42429ec8d0eab2b5b7410b76893d29efd876707e56'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV103(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v103.Call} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '034e3eee3b3e14d9d85aa5e676b78583f5ca4a175133e7a9208e794a092030c3'
    }

    /**
     * Schedule a named task after a delay.
     */
    get asV104(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v104.Call} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '21d26c2297ce358be43384bce1284eaf80c79884b78f7a4aee1931db50b7848a'
    }

    /**
     * Schedule a named task after a delay.
     */
    get asV105(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v105.Call} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '2b2c81f072a7e8aeadc5ca33a1f8d65b114ed69cf78ec9b4424d2a1300a5dee8'
    }

    /**
     * Schedule a named task after a delay.
     */
    get asV106(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v106.Call} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '106c55559614e9187d9b3f9ed3d56756562396bb6bec0abcb8f95f831b0057fe'
    }

    /**
     * Schedule a named task after a delay.
     */
    get asV110(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v110.Call} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'fcca814a52e57df9d0d52d96edc2f6b25e6b1b39a320a912aa9f442ba1edded3'
    }

    /**
     * Schedule a named task after a delay.
     */
    get asV120(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v120.Call} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'e28d03b00dc6ed5d474fa2a9fcc8e559e1ce3408f191a372271c881f45ed9370'
    }

    /**
     * Schedule a named task after a delay.
     */
    get asV1021(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1021.Call} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'd9fff084dfb7816c268a43af36b018df1f66d1c3f08cb388f69b723d80f60d93'
    }

    /**
     * Schedule a named task after a delay.
     */
    get asV1022(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1022.Call} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '97d132d126df3cbd6e0e7af194c4f269f8cc6db6702294d12d70adeb756000d6'
    }

    /**
     * Schedule a named task after a delay.
     */
    get asV1023(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1023.Call} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class SessionPurgeKeysCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Session.purge_keys')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Removes any session key(s) of the function caller.
     * 
     * This doesn't take effect until the next session.
     * 
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     * 
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     *   `T::Keys::key_ids()` which is fixed.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Session.purge_keys') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Removes any session key(s) of the function caller.
     * 
     * This doesn't take effect until the next session.
     * 
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     * 
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     *   `T::Keys::key_ids()` which is fixed.
     */
    get asMatrixEnjinV603(): null {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class SessionSetKeysCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Session.set_keys')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     * 
     * The dispatch origin of this function must be signed.
     * 
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     *   fixed.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Session.set_keys') === 'addd7c626f9aa937cd1834dc66bd024e3ceb303e43e64ebf3d8d267053cff2b5'
    }

    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     * 
     * The dispatch origin of this function must be signed.
     * 
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     *   fixed.
     */
    get asMatrixEnjinV603(): {keys: matrixEnjinV603.SessionKeys, proof: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     * 
     * The dispatch origin of this function must be signed.
     * 
     * # <weight>
     * - Complexity: `O(1)`. Actual cost depends on the number of length of
     *   `T::Keys::key_ids()` which is fixed.
     * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
     * - DbWrites: `origin account`, `NextKeys`
     * - DbReads per key id: `KeyOwner`
     * - DbWrites per key id: `KeyOwner`
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Session.set_keys') === '4604d1399268a7696192252f14d8cb6323ded610dca210e5e585de92eec430d5'
    }

    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     * 
     * The dispatch origin of this function must be signed.
     * 
     * # <weight>
     * - Complexity: `O(1)`. Actual cost depends on the number of length of
     *   `T::Keys::key_ids()` which is fixed.
     * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
     * - DbWrites: `origin account`, `NextKeys`
     * - DbReads per key id: `KeyOwner`
     * - DbWrites per key id: `KeyOwner`
     * # </weight>
     */
    get asV100(): {keys: v100.SessionKeys, proof: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsClearAllLeasesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.clear_all_leases')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Clear all leases for a Para Id, refunding any deposits back to the original owners.
     * 
     * The dispatch origin for this call must match `T::ForceOrigin`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Slots.clear_all_leases') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     * Clear all leases for a Para Id, refunding any deposits back to the original owners.
     * 
     * The dispatch origin for this call must match `T::ForceOrigin`.
     */
    get asV100(): {para: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsForceLeaseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.force_lease')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Just a connect into the `lease_out` call, in case Root wants to force some lease to happen
     * independently of any other on-chain mechanism to use it.
     * 
     * The dispatch origin for this call must match `T::ForceOrigin`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Slots.force_lease') === '7a85a97c4d9a6ea8aaf207f4760fceb3366bcc7fbfd7836192a4b01aebb9a461'
    }

    /**
     * Just a connect into the `lease_out` call, in case Root wants to force some lease to happen
     * independently of any other on-chain mechanism to use it.
     * 
     * The dispatch origin for this call must match `T::ForceOrigin`.
     */
    get asV100(): {para: number, leaser: Uint8Array, amount: bigint, periodBegin: number, periodCount: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsTriggerOnboardCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.trigger_onboard')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Try to onboard a parachain that has a lease for the current lease period.
     * 
     * This function can be useful if there was some state issue with a para that should
     * have onboarded, but was unable to. As long as they have a lease period, we can
     * let them onboard from here.
     * 
     * Origin must be signed, but can be called by anyone.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Slots.trigger_onboard') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     * Try to onboard a parachain that has a lease for the current lease period.
     * 
     * This function can be useful if there was some state issue with a para that should
     * have onboarded, but was unable to. As long as they have a lease period, we can
     * let them onboard from here.
     * 
     * Origin must be signed, but can be called by anyone.
     */
    get asV100(): {para: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakeExchangeAddLiquidityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'StakeExchange.add_liquidity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add liquidity to a current active offer
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match bidding account.
     * - [`Error::OfferNotFound`] if the offerId does not exist
     */
    get isV100(): boolean {
        return this._chain.getCallHash('StakeExchange.add_liquidity') === 'd93a6380c9b9181feb8b04538e588fe98d9e300c94a75c4232ae59cc3f2186bd'
    }

    /**
     * Add liquidity to a current active offer
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match bidding account.
     * - [`Error::OfferNotFound`] if the offerId does not exist
     */
    get asV100(): {offerId: bigint, amount: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add liquidity to a current active offer
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match bidding account.
     * - [`Error::OfferNotFound`] if the offerId does not exist
     */
    get isV120(): boolean {
        return this._chain.getCallHash('StakeExchange.add_liquidity') === '2ed595a4b8f54b7f41943c394ce7da42ef6011ec694a211df34188fe3ac07bca'
    }

    /**
     * Add liquidity to a current active offer
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match bidding account.
     * - [`Error::OfferNotFound`] if the offerId does not exist
     */
    get asV120(): {offerId: bigint, amount: bigint} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }
}

export class StakeExchangeBuyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'StakeExchange.buy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Buy from a current active offer, returning the native currency by exchanging the staked
     * tokens
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match bidding account.
     * - [`Error::TokenRestriction`] if the tokenId is restricted by the LP
     * - [`Error::NotEnoughLiquidity`] if the offer cannot cover the amount requested
     * - [`Error::TransferParamCreationFailed`] if the multitokens transfer failed
     */
    get isV100(): boolean {
        return this._chain.getCallHash('StakeExchange.buy') === 'd1555f54babb9ecf84a4a3c10970c23bd85dc664473add6efbcd0122df1c5ab4'
    }

    /**
     * Buy from a current active offer, returning the native currency by exchanging the staked
     * tokens
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match bidding account.
     * - [`Error::TokenRestriction`] if the tokenId is restricted by the LP
     * - [`Error::NotEnoughLiquidity`] if the offer cannot cover the amount requested
     * - [`Error::TransferParamCreationFailed`] if the multitokens transfer failed
     */
    get asV100(): {offerId: bigint, amount: bigint, tokenId: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Buy from a current active offer, returning the native currency by exchanging the staked
     * tokens
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match bidding account.
     * - [`Error::TokenRestriction`] if the tokenId is restricted by the LP
     * - [`Error::NotEnoughLiquidity`] if the offer cannot cover the amount requested
     * - [`Error::TransferParamCreationFailed`] if the multitokens transfer failed
     */
    get isV120(): boolean {
        return this._chain.getCallHash('StakeExchange.buy') === '7bed0942fd52a1091a490171bae3c1cbf4da7c9ba526688998f0707b2e7ed1de'
    }

    /**
     * Buy from a current active offer, returning the native currency by exchanging the staked
     * tokens
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match bidding account.
     * - [`Error::TokenRestriction`] if the tokenId is restricted by the LP
     * - [`Error::NotEnoughLiquidity`] if the offer cannot cover the amount requested
     * - [`Error::TransferParamCreationFailed`] if the multitokens transfer failed
     */
    get asV120(): {offerId: bigint, amount: bigint, tokenId: bigint} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }
}

export class StakeExchangeCancelOfferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'StakeExchange.cancel_offer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel an existing offer with `offer_id`
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::OfferNotFound`] if the `offer_id` does not exist
     */
    get isV100(): boolean {
        return this._chain.getCallHash('StakeExchange.cancel_offer') === 'a31df34b423037e305dbc2946d691428051e98fb362268dc0e78aff52ab30840'
    }

    /**
     * Cancel an existing offer with `offer_id`
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::OfferNotFound`] if the `offer_id` does not exist
     */
    get asV100(): {offerId: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Cancel an existing offer with `offer_id`
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::OfferNotFound`] if the `offer_id` does not exist
     */
    get isV120(): boolean {
        return this._chain.getCallHash('StakeExchange.cancel_offer') === '02204bf0fdf42e12ca975264b6a30953721d166330740e815173383226d7d262'
    }

    /**
     * Cancel an existing offer with `offer_id`
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::OfferNotFound`] if the `offer_id` does not exist
     */
    get asV120(): {offerId: bigint} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }
}

export class StakeExchangeConfigureLiquidityAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'StakeExchange.configure_liquidity_account')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the liquidity config for the caller account
     */
    get isV100(): boolean {
        return this._chain.getCallHash('StakeExchange.configure_liquidity_account') === '88285f5a31fad4d9887e32cff1c402fc1ff2543ac5e3f3440e5373bce1e6272d'
    }

    /**
     * Set the liquidity config for the caller account
     */
    get asV100(): {config: v100.LiquidityAccountConfig} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakeExchangeCreateOfferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'StakeExchange.create_offer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Place a new offer with the given parameters
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::ZeroOffer`] if offer amount is zero.
     * - [`Error::ZeroRate`] if rate amount is zero.
     * - [`Error::Overflow`] if arithmetic overflow occurs
     */
    get isV100(): boolean {
        return this._chain.getCallHash('StakeExchange.create_offer') === '30b8b7f9d6ec80030759f61277d7e74ee08f9c472eb0142102d7a49f3b4ab119'
    }

    /**
     * Place a new offer with the given parameters
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::ZeroOffer`] if offer amount is zero.
     * - [`Error::ZeroRate`] if rate amount is zero.
     * - [`Error::Overflow`] if arithmetic overflow occurs
     */
    get asV100(): {offer: v100.Offer} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Place a new offer with the given parameters
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::ZeroOffer`] if offer amount is zero.
     * - [`Error::ZeroRate`] if rate amount is zero.
     * - [`Error::Overflow`] if arithmetic overflow occurs
     */
    get isV101(): boolean {
        return this._chain.getCallHash('StakeExchange.create_offer') === '2144f02d1fc4fba1abb5578ddc2f50f23218ffe6bb27da54ff0b3f6baa72f976'
    }

    /**
     * Place a new offer with the given parameters
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::ZeroOffer`] if offer amount is zero.
     * - [`Error::ZeroRate`] if rate amount is zero.
     * - [`Error::Overflow`] if arithmetic overflow occurs
     */
    get asV101(): {offer: v101.Offer} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Place a new offer with the given parameters
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::ZeroOffer`] if offer amount is zero.
     * - [`Error::ZeroRate`] if rate amount is zero.
     * - [`Error::Overflow`] if arithmetic overflow occurs
     */
    get isV120(): boolean {
        return this._chain.getCallHash('StakeExchange.create_offer') === '4d548fa95856890026028533bc02439f0d95fb81da9bb4e11c62868e42267678'
    }

    /**
     * Place a new offer with the given parameters
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::ZeroOffer`] if offer amount is zero.
     * - [`Error::ZeroRate`] if rate amount is zero.
     * - [`Error::Overflow`] if arithmetic overflow occurs
     */
    get asV120(): {offer: v120.CreateOffer} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Place a new offer with the given parameters
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::ZeroOffer`] if offer amount is zero.
     * - [`Error::ZeroRate`] if rate amount is zero.
     * - [`Error::Overflow`] if arithmetic overflow occurs
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('StakeExchange.create_offer') === '632d10759f4789657479f2ea4f30e0a0ab90718682462bbaadb8e7414789eafa'
    }

    /**
     * Place a new offer with the given parameters
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::ZeroOffer`] if offer amount is zero.
     * - [`Error::ZeroRate`] if rate amount is zero.
     * - [`Error::Overflow`] if arithmetic overflow occurs
     */
    get asV1021(): {offer: v1021.CreateOffer} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Place a new offer with the given parameters
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::ZeroOffer`] if offer amount is zero.
     * - [`Error::ZeroRate`] if rate amount is zero.
     * - [`Error::Overflow`] if arithmetic overflow occurs
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('StakeExchange.create_offer') === '9fc5d94103af4ed0b31f369cc50aa830b837ab10084f7d7a5f8736436f6293d3'
    }

    /**
     * Place a new offer with the given parameters
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::ZeroOffer`] if offer amount is zero.
     * - [`Error::ZeroRate`] if rate amount is zero.
     * - [`Error::Overflow`] if arithmetic overflow occurs
     */
    get asV1023(): {offer: v1023.CreateOffer} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class StakeExchangeWithdrawLiquidityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'StakeExchange.withdraw_liquidity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Withdraw liquidity from a current active offer
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::OfferNotFound`] if the offerId does not exist
     */
    get isV100(): boolean {
        return this._chain.getCallHash('StakeExchange.withdraw_liquidity') === 'd93a6380c9b9181feb8b04538e588fe98d9e300c94a75c4232ae59cc3f2186bd'
    }

    /**
     * Withdraw liquidity from a current active offer
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::OfferNotFound`] if the offerId does not exist
     */
    get asV100(): {offerId: bigint, amount: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Withdraw liquidity from a current active offer
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::OfferNotFound`] if the offerId does not exist
     */
    get isV120(): boolean {
        return this._chain.getCallHash('StakeExchange.withdraw_liquidity') === '2ed595a4b8f54b7f41943c394ce7da42ef6011ec694a211df34188fe3ac07bca'
    }

    /**
     * Withdraw liquidity from a current active offer
     * 
     * # Errors
     * - [`Error::CallerNotOfferCreator`] if the caller account does not match offer account.
     * - [`Error::OfferNotFound`] if the offerId does not exist
     */
    get asV120(): {offerId: bigint, amount: bigint} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingBondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.bond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Take the origin account as a stash and lock up `value` of its balance. `controller` will
     * be the account that controls it.
     * 
     * `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     * The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     * Emits `Bonded`.
     * # <weight>
     * - Independent of the arguments. Moderate complexity.
     * - O(1).
     * - Three extra DB entries.
     * 
     * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
     * unless the `origin` falls below _existential deposit_ and gets removed as dust.
     * ------------------
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.bond') === 'c0b607a5cbdc40ee9aed26b3c86cfe3159aeccd5ac4e9005210dd39d0317ba48'
    }

    /**
     * Take the origin account as a stash and lock up `value` of its balance. `controller` will
     * be the account that controls it.
     * 
     * `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     * The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     * Emits `Bonded`.
     * # <weight>
     * - Independent of the arguments. Moderate complexity.
     * - O(1).
     * - Three extra DB entries.
     * 
     * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
     * unless the `origin` falls below _existential deposit_ and gets removed as dust.
     * ------------------
     * # </weight>
     */
    get asV100(): {controller: v100.MultiAddress, value: bigint, payee: v100.RewardDestination} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Take the origin account as a stash and lock up `value` of its balance. `controller` will
     * be the account that controls it.
     * 
     * `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     * The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     * Emits `Bonded`.
     * ## Complexity
     * - Independent of the arguments. Moderate complexity.
     * - O(1).
     * - Three extra DB entries.
     * 
     * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
     * unless the `origin` falls below _existential deposit_ and gets removed as dust.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Staking.bond') === 'd97e1d2a9763cae29f7bbb9e429e3692a97bbb00fff8f74190b36013ec990f11'
    }

    /**
     * Take the origin account as a stash and lock up `value` of its balance. `controller` will
     * be the account that controls it.
     * 
     * `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     * The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     * Emits `Bonded`.
     * ## Complexity
     * - Independent of the arguments. Moderate complexity.
     * - O(1).
     * - Three extra DB entries.
     * 
     * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
     * unless the `origin` falls below _existential deposit_ and gets removed as dust.
     */
    get asV105(): {value: bigint, payee: v105.RewardDestination} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingBondExtraCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.bond_extra')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add some extra amount that have appeared in the stash `free_balance` into the balance up
     * for staking.
     * 
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     * Use this if there are additional funds in your stash account that you wish to bond.
     * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
     * any limitation on the amount that can be added.
     * 
     * Emits `Bonded`.
     * 
     * # <weight>
     * - Independent of the arguments. Insignificant complexity.
     * - O(1).
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.bond_extra') === 'f92c56c980d6a55c468653fc3149548edcf2481e5da53835a201cafa7dc02fd8'
    }

    /**
     * Add some extra amount that have appeared in the stash `free_balance` into the balance up
     * for staking.
     * 
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     * Use this if there are additional funds in your stash account that you wish to bond.
     * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
     * any limitation on the amount that can be added.
     * 
     * Emits `Bonded`.
     * 
     * # <weight>
     * - Independent of the arguments. Insignificant complexity.
     * - O(1).
     * # </weight>
     */
    get asV100(): {maxAdditional: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingCancelDeferredSlashCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.cancel_deferred_slash')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel enactment of a deferred slash.
     * 
     * Can be called by the `T::AdminOrigin`.
     * 
     * Parameters: era and indices of the slashes for that era to kill.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.cancel_deferred_slash') === 'fab176436ff709189f441a9c591b1e715361b4db2636055c0154e452e116feb0'
    }

    /**
     * Cancel enactment of a deferred slash.
     * 
     * Can be called by the `T::AdminOrigin`.
     * 
     * Parameters: era and indices of the slashes for that era to kill.
     */
    get asV100(): {era: number, slashIndices: number[]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingChillCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.chill')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Declare no desire to either validate or nominate.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * # <weight>
     * - Independent of the arguments. Insignificant complexity.
     * - Contains one read.
     * - Writes are limited to the `origin` account key.
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.chill') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Declare no desire to either validate or nominate.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * # <weight>
     * - Independent of the arguments. Insignificant complexity.
     * - Contains one read.
     * - Writes are limited to the `origin` account key.
     * # </weight>
     */
    get asV100(): null {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingChillOtherCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.chill_other')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Declare a `controller` to stop participating as either a validator or nominator.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_, but can be called by anyone.
     * 
     * If the caller is the same as the controller being targeted, then no further checks are
     * enforced, and this function behaves just like `chill`.
     * 
     * If the caller is different than the controller being targeted, the following conditions
     * must be met:
     * 
     * * `controller` must belong to a nominator who has become non-decodable,
     * 
     * Or:
     * 
     * * A `ChillThreshold` must be set and checked which defines how close to the max
     *   nominators or validators we must reach before users can start chilling one-another.
     * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
     *   how close we are to the threshold.
     * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
     *   if this is a person that should be chilled because they have not met the threshold
     *   bond required.
     * 
     * This can be helpful if bond requirements are updated, and we need to remove old users
     * who do not satisfy these requirements.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.chill_other') === 'bbdd03dc244a9d87deceeb91d015d7ef52746b99580b1474586c8699a77574e1'
    }

    /**
     * Declare a `controller` to stop participating as either a validator or nominator.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_, but can be called by anyone.
     * 
     * If the caller is the same as the controller being targeted, then no further checks are
     * enforced, and this function behaves just like `chill`.
     * 
     * If the caller is different than the controller being targeted, the following conditions
     * must be met:
     * 
     * * `controller` must belong to a nominator who has become non-decodable,
     * 
     * Or:
     * 
     * * A `ChillThreshold` must be set and checked which defines how close to the max
     *   nominators or validators we must reach before users can start chilling one-another.
     * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
     *   how close we are to the threshold.
     * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
     *   if this is a person that should be chilled because they have not met the threshold
     *   bond required.
     * 
     * This can be helpful if bond requirements are updated, and we need to remove old users
     * who do not satisfy these requirements.
     */
    get asV100(): {controller: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingForceApplyMinCommissionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.force_apply_min_commission')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force a validator to have at least the minimum commission. This will not affect a
     * validator who already has a commission greater than or equal to the minimum. Any account
     * can call this.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.force_apply_min_commission') === 'ee412bb909d2500627205d4c5b741967883fb1ed7f64bdc95edae3852f63750e'
    }

    /**
     * Force a validator to have at least the minimum commission. This will not affect a
     * validator who already has a commission greater than or equal to the minimum. Any account
     * can call this.
     */
    get asV100(): {validatorStash: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingForceNewEraCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.force_new_era')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force there to be a new era at the end of the next session. After this, it will be
     * reset to normal (non-forced) behaviour.
     * 
     * The dispatch origin must be Root.
     * 
     * # Warning
     * 
     * The election process starts multiple blocks before the end of the era.
     * If this is called just before a new era is triggered, the election process may not
     * have enough blocks to get a result.
     * 
     * # <weight>
     * - No arguments.
     * - Weight: O(1)
     * - Write ForceEra
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.force_new_era') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Force there to be a new era at the end of the next session. After this, it will be
     * reset to normal (non-forced) behaviour.
     * 
     * The dispatch origin must be Root.
     * 
     * # Warning
     * 
     * The election process starts multiple blocks before the end of the era.
     * If this is called just before a new era is triggered, the election process may not
     * have enough blocks to get a result.
     * 
     * # <weight>
     * - No arguments.
     * - Weight: O(1)
     * - Write ForceEra
     * # </weight>
     */
    get asV100(): null {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingForceNewEraAlwaysCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.force_new_era_always')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force there to be a new era at the end of sessions indefinitely.
     * 
     * The dispatch origin must be Root.
     * 
     * # Warning
     * 
     * The election process starts multiple blocks before the end of the era.
     * If this is called just before a new era is triggered, the election process may not
     * have enough blocks to get a result.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.force_new_era_always') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Force there to be a new era at the end of sessions indefinitely.
     * 
     * The dispatch origin must be Root.
     * 
     * # Warning
     * 
     * The election process starts multiple blocks before the end of the era.
     * If this is called just before a new era is triggered, the election process may not
     * have enough blocks to get a result.
     */
    get asV100(): null {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingForceNoErasCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.force_no_eras')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force there to be no new eras indefinitely.
     * 
     * The dispatch origin must be Root.
     * 
     * # Warning
     * 
     * The election process starts multiple blocks before the end of the era.
     * Thus the election process may be ongoing when this is called. In this case the
     * election will continue until the next era is triggered.
     * 
     * # <weight>
     * - No arguments.
     * - Weight: O(1)
     * - Write: ForceEra
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.force_no_eras') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Force there to be no new eras indefinitely.
     * 
     * The dispatch origin must be Root.
     * 
     * # Warning
     * 
     * The election process starts multiple blocks before the end of the era.
     * Thus the election process may be ongoing when this is called. In this case the
     * election will continue until the next era is triggered.
     * 
     * # <weight>
     * - No arguments.
     * - Weight: O(1)
     * - Write: ForceEra
     * # </weight>
     */
    get asV100(): null {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingForceUnstakeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.force_unstake')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force a current staker to become completely unstaked, immediately.
     * 
     * The dispatch origin must be Root.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.force_unstake') === '9d6e1257b3e6113f6cc99a4193f2fef8c6513a3d2a99ee686af751b5931f583b'
    }

    /**
     * Force a current staker to become completely unstaked, immediately.
     * 
     * The dispatch origin must be Root.
     */
    get asV100(): {stash: Uint8Array, numSlashingSpans: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingIncreaseValidatorCountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.increase_validator_count')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Increments the ideal number of validators upto maximum of
     * `ElectionProviderBase::MaxWinners`.
     * 
     * The dispatch origin must be Root.
     * 
     * # <weight>
     * Same as [`Self::set_validator_count`].
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.increase_validator_count') === '1b5e15eec25101f7a4e4a63e4c35b1120c3147dac0ca34ddcab4e7e3bb6ef150'
    }

    /**
     * Increments the ideal number of validators upto maximum of
     * `ElectionProviderBase::MaxWinners`.
     * 
     * The dispatch origin must be Root.
     * 
     * # <weight>
     * Same as [`Self::set_validator_count`].
     * # </weight>
     */
    get asV100(): {additional: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingKickCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.kick')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the given nominations from the calling validator.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * - `who`: A list of nominator stash accounts who are nominating this validator which
     *   should no longer be nominating this validator.
     * 
     * Note: Making this call only makes sense if you first set the validator preferences to
     * block any further nominations.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.kick') === 'e538d9391f8376022db5c010fa7390c92954267b2d5ebc13e621f87adebe57b9'
    }

    /**
     * Remove the given nominations from the calling validator.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * - `who`: A list of nominator stash accounts who are nominating this validator which
     *   should no longer be nominating this validator.
     * 
     * Note: Making this call only makes sense if you first set the validator preferences to
     * block any further nominations.
     */
    get asV100(): {who: v100.MultiAddress[]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingNominateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.nominate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Declare the desire to nominate `targets` for the origin controller.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * # <weight>
     * - The transaction's complexity is proportional to the size of `targets` (N)
     * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
     * - Both the reads and writes follow a similar pattern.
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.nominate') === '4b7eca27044655bd9da5cc614a4bf774babc00decbed9ca59d95298b300d72de'
    }

    /**
     * Declare the desire to nominate `targets` for the origin controller.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * # <weight>
     * - The transaction's complexity is proportional to the size of `targets` (N)
     * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
     * - Both the reads and writes follow a similar pattern.
     * # </weight>
     */
    get asV100(): {targets: v100.MultiAddress[]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingPayoutStakersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.payout_stakers')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Pay out all the stakers behind a single validator for a single era.
     * 
     * - `validator_stash` is the stash account of the validator. Their nominators, up to
     *   `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
     * - `era` may be any era between `[current_era - history_depth; current_era]`.
     * 
     * The origin of this call must be _Signed_. Any account can call this function, even if
     * it is not one of the stakers.
     * 
     * # <weight>
     * - Time complexity: at most O(MaxNominatorRewardedPerValidator).
     * - Contains a limited number of reads and writes.
     * -----------
     * N is the Number of payouts for the validator (including the validator)
     * Weight:
     * - Reward Destination Staked: O(N)
     * - Reward Destination Controller (Creating): O(N)
     * 
     *   NOTE: weights are assuming that payouts are made to alive stash account (Staked).
     *   Paying even a dead controller is cheaper weight-wise. We don't do any refunds here.
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.payout_stakers') === '1a09dc413ed4b8ce5cbcdc282b798636ca24268cca001e43fc92d892de3b6a5f'
    }

    /**
     * Pay out all the stakers behind a single validator for a single era.
     * 
     * - `validator_stash` is the stash account of the validator. Their nominators, up to
     *   `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
     * - `era` may be any era between `[current_era - history_depth; current_era]`.
     * 
     * The origin of this call must be _Signed_. Any account can call this function, even if
     * it is not one of the stakers.
     * 
     * # <weight>
     * - Time complexity: at most O(MaxNominatorRewardedPerValidator).
     * - Contains a limited number of reads and writes.
     * -----------
     * N is the Number of payouts for the validator (including the validator)
     * Weight:
     * - Reward Destination Staked: O(N)
     * - Reward Destination Controller (Creating): O(N)
     * 
     *   NOTE: weights are assuming that payouts are made to alive stash account (Staked).
     *   Paying even a dead controller is cheaper weight-wise. We don't do any refunds here.
     * # </weight>
     */
    get asV100(): {validatorStash: Uint8Array, era: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingReapStashCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.reap_stash')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove all data structures concerning a staker/stash once it is at a state where it can
     * be considered `dust` in the staking system. The requirements are:
     * 
     * 1. the `total_balance` of the stash is below existential deposit.
     * 2. or, the `ledger.total` of the stash is below existential deposit.
     * 
     * The former can happen in cases like a slash; the latter when a fully unbonded account
     * is still receiving staking rewards in `RewardDestination::Staked`.
     * 
     * It can be called by anyone, as long as `stash` meets the above requirements.
     * 
     * Refunds the transaction fees upon successful execution.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.reap_stash') === '9d6e1257b3e6113f6cc99a4193f2fef8c6513a3d2a99ee686af751b5931f583b'
    }

    /**
     * Remove all data structures concerning a staker/stash once it is at a state where it can
     * be considered `dust` in the staking system. The requirements are:
     * 
     * 1. the `total_balance` of the stash is below existential deposit.
     * 2. or, the `ledger.total` of the stash is below existential deposit.
     * 
     * The former can happen in cases like a slash; the latter when a fully unbonded account
     * is still receiving staking rewards in `RewardDestination::Staked`.
     * 
     * It can be called by anyone, as long as `stash` meets the above requirements.
     * 
     * Refunds the transaction fees upon successful execution.
     */
    get asV100(): {stash: Uint8Array, numSlashingSpans: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingRebondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.rebond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Rebond a portion of the stash scheduled to be unlocked.
     * 
     * The dispatch origin must be signed by the controller.
     * 
     * # <weight>
     * - Time complexity: O(L), where L is unlocking chunks
     * - Bounded by `MaxUnlockingChunks`.
     * - Storage changes: Can't increase storage, only decrease it.
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.rebond') === 'd13cb91c3f61510beece366e7f7c2d0705f01d70f9bc28721d2437cd210a3372'
    }

    /**
     * Rebond a portion of the stash scheduled to be unlocked.
     * 
     * The dispatch origin must be signed by the controller.
     * 
     * # <weight>
     * - Time complexity: O(L), where L is unlocking chunks
     * - Bounded by `MaxUnlockingChunks`.
     * - Storage changes: Can't increase storage, only decrease it.
     * # </weight>
     */
    get asV100(): {value: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingScaleValidatorCountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.scale_validator_count')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Scale up the ideal number of validators by a factor upto maximum of
     * `ElectionProviderBase::MaxWinners`.
     * 
     * The dispatch origin must be Root.
     * 
     * # <weight>
     * Same as [`Self::set_validator_count`].
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.scale_validator_count') === 'd5f5b0d2128c7dec0e2681f604f51d1657af9bf5eb7c704432075cb4655e0065'
    }

    /**
     * Scale up the ideal number of validators by a factor upto maximum of
     * `ElectionProviderBase::MaxWinners`.
     * 
     * The dispatch origin must be Root.
     * 
     * # <weight>
     * Same as [`Self::set_validator_count`].
     * # </weight>
     */
    get asV100(): {factor: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetControllerCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_controller')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * (Re-)set the controller of a stash.
     * 
     * Effects will be felt instantly (as soon as this function is completed successfully).
     * 
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     * # <weight>
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     * ----------
     * Weight: O(1)
     * DB Weight:
     * - Read: Bonded, Ledger New Controller, Ledger Old Controller
     * - Write: Bonded, Ledger New Controller, Ledger Old Controller
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.set_controller') === '81dc3a18eb19c7f258654686fb92e5bf48185191f2c59179a5b4626965fc66cd'
    }

    /**
     * (Re-)set the controller of a stash.
     * 
     * Effects will be felt instantly (as soon as this function is completed successfully).
     * 
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     * # <weight>
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     * ----------
     * Weight: O(1)
     * DB Weight:
     * - Read: Bonded, Ledger New Controller, Ledger Old Controller
     * - Write: Bonded, Ledger New Controller, Ledger Old Controller
     * # </weight>
     */
    get asV100(): {controller: v100.MultiAddress} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * (Re-)sets the controller of a stash to the stash itself. This function previously
     * accepted a `controller` argument to set the controller to an account other than the
     * stash itself. This functionality has now been removed, now only setting the controller
     * to the stash, if it is not already.
     * 
     * Effects will be felt instantly (as soon as this function is completed successfully).
     * 
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     * ## Complexity
     * O(1)
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Staking.set_controller') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * (Re-)sets the controller of a stash to the stash itself. This function previously
     * accepted a `controller` argument to set the controller to an account other than the
     * stash itself. This functionality has now been removed, now only setting the controller
     * to the stash, if it is not already.
     * 
     * Effects will be felt instantly (as soon as this function is completed successfully).
     * 
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     * ## Complexity
     * O(1)
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     */
    get asV105(): null {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetInvulnerablesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_invulnerables')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the validators who cannot be slashed (if any).
     * 
     * The dispatch origin must be Root.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.set_invulnerables') === '994c18897efc6a5b0e11aeb337b6c718ad03cb0eb182a442fc74b9c80dd56313'
    }

    /**
     * Set the validators who cannot be slashed (if any).
     * 
     * The dispatch origin must be Root.
     */
    get asV100(): {invulnerables: Uint8Array[]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetMinCommissionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_min_commission')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the minimum amount of commission that each validators must maintain.
     * 
     * This call has lower privilege requirements than `set_staking_config` and can be called
     * by the `T::AdminOrigin`. Root can always call this.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.set_min_commission') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the minimum amount of commission that each validators must maintain.
     * 
     * This call has lower privilege requirements than `set_staking_config` and can be called
     * by the `T::AdminOrigin`. Root can always call this.
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetPayeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_payee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * (Re-)set the payment target for a controller.
     * 
     * Effects will be felt instantly (as soon as this function is completed successfully).
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * # <weight>
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     * ---------
     * - Weight: O(1)
     * - DB Weight:
     *     - Read: Ledger
     *     - Write: Payee
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.set_payee') === 'e882138b8d0371da862d058ac00f1def3ca0f71ab72eda3fbfb7d75b5fa16515'
    }

    /**
     * (Re-)set the payment target for a controller.
     * 
     * Effects will be felt instantly (as soon as this function is completed successfully).
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * # <weight>
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     * ---------
     * - Weight: O(1)
     * - DB Weight:
     *     - Read: Ledger
     *     - Write: Payee
     * # </weight>
     */
    get asV100(): {payee: v100.RewardDestination} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetStakingConfigsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_staking_configs')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update the various staking configurations .
     * 
     * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     * * `min_validator_bond`: The minimum active bond needed to be a validator.
     * * `max_nominator_count`: The max number of users who can be a nominator at once. When
     *   set to `None`, no limit is enforced.
     * * `max_validator_count`: The max number of users who can be a validator at once. When
     *   set to `None`, no limit is enforced.
     * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
     *   should be filled in order for the `chill_other` transaction to work.
     * * `min_commission`: The minimum amount of commission that each validators must maintain.
     *   This is checked only upon calling `validate`. Existing validators are not affected.
     * 
     * RuntimeOrigin must be Root to call this function.
     * 
     * NOTE: Existing nominators and validators will not be affected by this update.
     * to kick people under the new limits, `chill_other` should be called.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.set_staking_configs') === '67189d3ca60a3305c1159ea1c7b2cfcbc749ef2c16f16b4c876daab793efdf86'
    }

    /**
     * Update the various staking configurations .
     * 
     * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     * * `min_validator_bond`: The minimum active bond needed to be a validator.
     * * `max_nominator_count`: The max number of users who can be a nominator at once. When
     *   set to `None`, no limit is enforced.
     * * `max_validator_count`: The max number of users who can be a validator at once. When
     *   set to `None`, no limit is enforced.
     * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
     *   should be filled in order for the `chill_other` transaction to work.
     * * `min_commission`: The minimum amount of commission that each validators must maintain.
     *   This is checked only upon calling `validate`. Existing validators are not affected.
     * 
     * RuntimeOrigin must be Root to call this function.
     * 
     * NOTE: Existing nominators and validators will not be affected by this update.
     * to kick people under the new limits, `chill_other` should be called.
     */
    get asV100(): {minNominatorBond: v100.ConfigOp, minValidatorBond: v100.ConfigOp, maxNominatorCount: v100.Type_326, maxValidatorCount: v100.Type_326, chillThreshold: v100.Type_327, minCommission: v100.Type_328} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetValidatorCountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_validator_count')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the ideal number of validators.
     * 
     * The dispatch origin must be Root.
     * 
     * # <weight>
     * Weight: O(1)
     * Write: Validator Count
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.set_validator_count') === 'e648274eb741b1a8ab74c4583589c621e8391cd9122c0f7063e1e18c4af71912'
    }

    /**
     * Sets the ideal number of validators.
     * 
     * The dispatch origin must be Root.
     * 
     * # <weight>
     * Weight: O(1)
     * Write: Validator Count
     * # </weight>
     */
    get asV100(): {new: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingUnbondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.unbond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
     * period ends. If this leaves an amount actively bonded less than
     * T::Currency::minimum_balance(), then it is increased to the full amount.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
     * the funds out of management ready for transfer.
     * 
     * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
     * can co-exists at the same time. If there are no unlocking chunks slots available
     * [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
     * 
     * If a user encounters the `InsufficientBond` error when calling this extrinsic,
     * they should call `chill` first in order to free up their bonded funds.
     * 
     * Emits `Unbonded`.
     * 
     * See also [`Call::withdraw_unbonded`].
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.unbond') === 'd13cb91c3f61510beece366e7f7c2d0705f01d70f9bc28721d2437cd210a3372'
    }

    /**
     * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
     * period ends. If this leaves an amount actively bonded less than
     * T::Currency::minimum_balance(), then it is increased to the full amount.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
     * the funds out of management ready for transfer.
     * 
     * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
     * can co-exists at the same time. If there are no unlocking chunks slots available
     * [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
     * 
     * If a user encounters the `InsufficientBond` error when calling this extrinsic,
     * they should call `chill` first in order to free up their bonded funds.
     * 
     * Emits `Unbonded`.
     * 
     * See also [`Call::withdraw_unbonded`].
     */
    get asV100(): {value: bigint} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingValidateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.validate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Declare the desire to validate for the origin controller.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.validate') === '2a662df491d449985438edd4d2e6899fd06beebbaa59e759713811ade38308bf'
    }

    /**
     * Declare the desire to validate for the origin controller.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     */
    get asV100(): {prefs: v100.ValidatorPrefs} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingWithdrawUnbondedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.withdraw_unbonded')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove any unlocked chunks from the `unlocking` queue from our management.
     * 
     * This essentially frees up that balance to be used by the stash account to do
     * whatever it wants.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller.
     * 
     * Emits `Withdrawn`.
     * 
     * See also [`Call::unbond`].
     * 
     * # <weight>
     * Complexity O(S) where S is the number of slashing spans to remove
     * NOTE: Weight annotation is the kill scenario, we refund otherwise.
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Staking.withdraw_unbonded') === '6a7f80eeb74b237a907212a84c7fbc3bbfc8155b3decc30afb4c65c3bcb3f317'
    }

    /**
     * Remove any unlocked chunks from the `unlocking` queue from our management.
     * 
     * This essentially frees up that balance to be used by the stash account to do
     * whatever it wants.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller.
     * 
     * Emits `Withdrawn`.
     * 
     * See also [`Call::unbond`].
     * 
     * # <weight>
     * Complexity O(S) where S is the number of slashing spans to remove
     * NOTE: Weight annotation is the kill scenario, we refund otherwise.
     * # </weight>
     */
    get asV100(): {numSlashingSpans: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class SudoSetKeyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Sudo.set_key')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
     * key.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB change.
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Sudo.set_key') === 'e634aac3331d47a56ff572c52ad90a648769dfbf2c00d7bd44498b4ee41f6ac7'
    }

    /**
     * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
     * key.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB change.
     * # </weight>
     */
    get asV100(): {new: v100.MultiAddress} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class SudoSudoCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Sudo.sudo')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === '7e7ca4a51a27b75adcd5cc3fac290cea1b75ac762c8fda7f2b1677104875dfbc'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get asV100(): {call: v100.Call} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === '54ea42f59e55ccc6a1395e61c5bdefb9b3e72e18b75663994461b7565fdea0ec'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get asV101(): {call: v101.Call} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === '0e1dd39cb361e50e1183aa4ac2baa5542de774621d2f85cc7067b6076f208958'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get asV102(): {call: v102.Call} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === 'b4af785b304541a5c22646c7efd0dba344eac099e9c0e80839b665a1e07f2e41'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get asV103(): {call: v103.Call} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === '3f59f17ab6406c8eb2c339ee5a640f47efb5b0e9c84096f26017f337bea08b60'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV104(): {call: v104.Call} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === 'f6b0799f5685a02dc8c8a14b5067d055152e5c1f25dd50c18030380965b11d55'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV105(): {call: v105.Call} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === 'd435f1baa5f2dbfdda145f5adff46e9448bd416dc9f062fa1e12dc0c8a02c924'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV106(): {call: v106.Call} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === 'ebf55311d7e853f8586deeaa0b6e540ab2013c7561a373e6e7955f78ab73deb1'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV110(): {call: v110.Call} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === '56edfc3de7c89b3ed1d8cfc5400e6a3c37eeb47533810cb7a0e23e62d833f460'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV120(): {call: v120.Call} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === 'fc358269cdcf12faf350eb6eda7e7c3d0c61c61285d54b10b6e5ab88abb9089d'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1021(): {call: v1021.Call} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === 'e2166d7b602d573395d001e91fdae8f710fd9d126d5864b18e7ce0f1dba5f09b'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1022(): {call: v1022.Call} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === '95bdab3bb6548e000ba2cf1fa20d486cbb856d04cc91966145545f76c479dada'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1023(): {call: v1023.Call} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class SudoSudoAsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Sudo.sudo_as')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '47805f3251395068a3bf9adf65f800b7bb063f42a3472ff783f469f1ab1a3c88'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get asV100(): {who: v100.MultiAddress, call: v100.Call} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '6bf24315c2efbdea18f99c2485cf5ac3710dde8074cc1211571ea90e80462e7f'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get asV101(): {who: v101.MultiAddress, call: v101.Call} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '4be30e19a41589fe6bc9726ba41592a2738e4436945c397923da894d9f96020b'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get asV102(): {who: v102.MultiAddress, call: v102.Call} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '3b0fcda63fdf243043021e15e5c8895614207b210a10cd611a9b246b7fbd409b'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + 10,000.
     * # </weight>
     */
    get asV103(): {who: v103.MultiAddress, call: v103.Call} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === 'e93dc80e05840daa8dfc7a761b280515bf929d9461d2f55796f7fe4457c04825'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV104(): {who: v104.MultiAddress, call: v104.Call} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === 'b70af8ea73c792e9796374549ac38ba55e82a7b2a5b95981232964b44c153a7c'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV105(): {who: v105.MultiAddress, call: v105.Call} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '266d3b22d71c0be70ee8d7ab404c077ddf801dd6adfcb86683f944e25b0fccf0'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV106(): {who: v106.MultiAddress, call: v106.Call} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === 'a5faf67386cbb4a7a1f5b0f9ffa5b5b4782119f0700f72d7d056efd85f938c35'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV110(): {who: v110.MultiAddress, call: v110.Call} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '78b0c415d293f15fe1eebb4c63124b2ff49128fac84cb5bb07c475540eff14f0'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV120(): {who: v120.MultiAddress, call: v120.Call} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === 'e0578c4d243e4c8db8a5c8b2976302051829c8619e6452e918884a9e9f4c066e'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1021(): {who: v1021.MultiAddress, call: v1021.Call} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '9cf53a95b721e8d3c6b59a699b246026644091f49c09c65150e0bf7b78770df3'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1022(): {who: v1022.MultiAddress, call: v1022.Call} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '691c5f3dc7796ecd0b6fe75f3910d6710d2c17ec2663b203206c9fc1f4904463'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1023(): {who: v1023.MultiAddress, call: v1023.Call} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class SudoSudoUncheckedWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Sudo.sudo_unchecked_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - The weight of this call is defined by the caller.
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === 'f63d2c51b53005b2250bfd91aeb29b04e5229d45283f49f04c2c19dacbbae49f'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - The weight of this call is defined by the caller.
     * # </weight>
     */
    get asV100(): {call: v100.Call, weight: v100.Weight} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - The weight of this call is defined by the caller.
     * # </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '709c2f9dcd69b7f7becea84e08955c3c1aa644d838b8ddeb21af6b1f5fcb7112'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - The weight of this call is defined by the caller.
     * # </weight>
     */
    get asV101(): {call: v101.Call, weight: v101.Weight} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - The weight of this call is defined by the caller.
     * # </weight>
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '2afdd84dc329b8ece7e7a085c43373a1c04cf181641b82584da75c7b809e0378'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - The weight of this call is defined by the caller.
     * # </weight>
     */
    get asV102(): {call: v102.Call, weight: v102.Weight} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - The weight of this call is defined by the caller.
     * # </weight>
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '4228622862b650ac972efe9daae57d9a0f8f6607c8951ccbb9603a6099c75182'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * # <weight>
     * - O(1).
     * - The weight of this call is defined by the caller.
     * # </weight>
     */
    get asV103(): {call: v103.Call, weight: v103.Weight} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '0f5ca8098a0de6d2359055195bcf7da26f16e6290e0dba0ce6aed434d9ffd3b5'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV104(): {call: v104.Call, weight: v104.Weight} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '68b05038ca47bf9eecbc926b66a2c5d92716b6072343998c6b1c007c1e66683f'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV105(): {call: v105.Call, weight: v105.Weight} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '45dc4333de9729dca05fea2f3b761cf425ed079a6ab9846806d226be8b96c475'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV106(): {call: v106.Call, weight: v106.Weight} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === 'aaf9d7148ba3e93e5ad731ce273c531c9b89065fb41b04ccdf297900e76b7da6'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV110(): {call: v110.Call, weight: v110.Weight} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '4d3599e0b8fa0dd841470850d5f5f4ea469e0c7b81fbd9a6c309707ff047a6f3'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV120(): {call: v120.Call, weight: v120.Weight} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === 'cbf453c1be5cc44fd79d2ade82b8ae1f4efa1b5669d5014bd4fa0ab49245f122'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1021(): {call: v1021.Call, weight: v1021.Weight} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '57db7818a8d5e9dec1cd0013f2489b4dbd58c05e3604bf2e7cb8e45790ea4bae'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1022(): {call: v1022.Call, weight: v1022.Weight} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === 'f08cbe0b82a724c7f62cf81b46bc1894d8b9dba0ffcee4294ba126e16c9960e0'
    }

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1023(): {call: v1023.Call, weight: v1023.Weight} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemKillPrefixCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.kill_prefix')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Kill all storage items with a key that starts with the given prefix.
     * 
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('System.kill_prefix') === 'dfbadd42bee8b18fc81cf78683511061181cffbf7a8ebfd3e5719c389b373d93'
    }

    /**
     * Kill all storage items with a key that starts with the given prefix.
     * 
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     */
    get asMatrixEnjinV603(): {prefix: Uint8Array, subkeys: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemKillStorageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.kill_storage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Kill some items from storage.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('System.kill_storage') === 'eac21dc14e927c003d9c634fb019d04128f71f8529d2914b10a56b85289c2c11'
    }

    /**
     * Kill some items from storage.
     */
    get asMatrixEnjinV603(): {keys: Uint8Array[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemRemarkCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.remark')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Make some on-chain remark.
     * 
     * - `O(1)`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('System.remark') === 'f4e9b5b7572eeae92978087ece9b4f57cb5cab4f16baf5625bb9ec4a432bad63'
    }

    /**
     * Make some on-chain remark.
     * 
     * - `O(1)`
     */
    get asMatrixEnjinV603(): {remark: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemRemarkWithEventCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.remark_with_event')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Make some on-chain remark and emit event.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('System.remark_with_event') === 'f4e9b5b7572eeae92978087ece9b4f57cb5cab4f16baf5625bb9ec4a432bad63'
    }

    /**
     * Make some on-chain remark and emit event.
     */
    get asMatrixEnjinV603(): {remark: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetCodeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_code')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the new runtime code.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('System.set_code') === '7bf3d4785d9be7a4872f39cbd3702a66e16f7ee01e4446fb4a05624dc0ec4c93'
    }

    /**
     * Set the new runtime code.
     */
    get asMatrixEnjinV603(): {code: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetCodeWithoutChecksCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_code_without_checks')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('System.set_code_without_checks') === '7bf3d4785d9be7a4872f39cbd3702a66e16f7ee01e4446fb4a05624dc0ec4c93'
    }

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     */
    get asMatrixEnjinV603(): {code: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetHeapPagesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_heap_pages')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('System.set_heap_pages') === '130172e47c5e517627712b4d084768b98489d920284223ea8ef9c462339b5808'
    }

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     */
    get asMatrixEnjinV603(): {pages: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetStorageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_storage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set some items of storage.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('System.set_storage') === 'a4fb507615d69849afb1b2ee654006f9be48bb6e960a4674624d6e46e4382083'
    }

    /**
     * Set some items of storage.
     */
    get asMatrixEnjinV603(): {items: [Uint8Array, Uint8Array][]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeCloseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.close')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.close') === 'a88911953f51bddf0f0aeafa7caa7ca904d30cdb24f940ff177d2acf7088d3bd'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     */
    get asMatrixEnjinV603(): {proposalHash: Uint8Array, index: number, proposalWeightBound: matrixEnjinV603.Weight, lengthBound: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeDisapproveProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.disapprove_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     * 
     * Must be called by the Root origin.
     * 
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     * ## Complexity
     * O(P) where P is the number of max proposals
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.disapprove_proposal') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     * 
     * Must be called by the Root origin.
     * 
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     * ## Complexity
     * O(P) where P is the number of max proposals
     */
    get asMatrixEnjinV603(): {proposalHash: Uint8Array} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeExecuteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.execute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '42e02516da5b061d1088373ba15312fb75350b4c460c86553b77632c49a1bfff'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get asMatrixEnjinV603(): {proposal: matrixEnjinV603.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '0528eb882b25dbc861bdb3dd23bf719192247ea0286b4ba762894271e9b24340'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get asMatrixEnjinV1000(): {proposal: matrixEnjinV1000.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '8436778e072de5fd031e538ef23b88424ea15c5d94208a400f13f01159fbfb00'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    get asMatrixEnjinV1003(): {proposal: matrixEnjinV1003.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'ad8e807bb31ab0d0a1cc9796c09abc6d953cde11f68353038cb230910f45f5a9'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get asMatrixEnjinV603(): {threshold: number, proposal: matrixEnjinV603.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '23bce148208de1a3e941cab0a9183111169beffd2c4b17fa55c77063a17ed2db'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get asMatrixEnjinV1000(): {threshold: number, proposal: matrixEnjinV1000.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '0318441ab0a9bd4ab2b6e923b6c88985852689b516a4d2084ccf14caa5f03be6'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    get asMatrixEnjinV1003(): {threshold: number, proposal: matrixEnjinV1003.Call, lengthBound: number} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeSetMembersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.set_members')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the collective's membership.
     * 
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     *   weight estimation.
     * 
     * The dispatch of this call must be `SetMembersOrigin`.
     * 
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     *       the weight estimations rely on it to estimate dispatchable weight.
     * 
     * # WARNING:
     * 
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     * 
     * ## Complexity:
     * - `O(MP + N)` where:
     *   - `M` old-members-count (code- and governance-bounded)
     *   - `N` new-members-count (code- and governance-bounded)
     *   - `P` proposals-count (code-bounded)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.set_members') === '71b7fcb1d8a62eff96a9ef006517578ce9189e6d931948a256a04ca75ff68d4a'
    }

    /**
     * Set the collective's membership.
     * 
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     *   weight estimation.
     * 
     * The dispatch of this call must be `SetMembersOrigin`.
     * 
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     *       the weight estimations rely on it to estimate dispatchable weight.
     * 
     * # WARNING:
     * 
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     * 
     * ## Complexity:
     * - `O(MP + N)` where:
     *   - `M` old-members-count (code- and governance-bounded)
     *   - `N` new-members-count (code- and governance-bounded)
     *   - `P` proposals-count (code-bounded)
     */
    get asMatrixEnjinV603(): {newMembers: Uint8Array[], prime: (Uint8Array | undefined), oldCount: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     * 
     * Requires the sender to be a member.
     * 
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.vote') === 'f8a1069a57f7b721f47c086d08b6838ae1a0c08f58caddb82428ba5f1407540f'
    }

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     * 
     * Requires the sender to be a member.
     * 
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     */
    get asMatrixEnjinV603(): {proposal: Uint8Array, index: number, approve: boolean} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipAddMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.add_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add a member `who` to the set.
     * 
     * May only be called from `T::AddOrigin`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalMembership.add_member') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Add a member `who` to the set.
     * 
     * May only be called from `T::AddOrigin`.
     */
    get asMatrixEnjinV603(): {who: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipChangeKeyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.change_key')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Swap out the sending member for some other key `new`.
     * 
     * May only be called from `Signed` origin of a current member.
     * 
     * Prime membership is passed from the origin account to `new`, if extant.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalMembership.change_key') === 'e634aac3331d47a56ff572c52ad90a648769dfbf2c00d7bd44498b4ee41f6ac7'
    }

    /**
     * Swap out the sending member for some other key `new`.
     * 
     * May only be called from `Signed` origin of a current member.
     * 
     * Prime membership is passed from the origin account to `new`, if extant.
     */
    get asMatrixEnjinV603(): {new: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipClearPrimeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.clear_prime')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the prime member if it exists.
     * 
     * May only be called from `T::PrimeOrigin`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalMembership.clear_prime') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Remove the prime member if it exists.
     * 
     * May only be called from `T::PrimeOrigin`.
     */
    get asMatrixEnjinV603(): null {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipRemoveMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.remove_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a member `who` from the set.
     * 
     * May only be called from `T::RemoveOrigin`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalMembership.remove_member') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Remove a member `who` from the set.
     * 
     * May only be called from `T::RemoveOrigin`.
     */
    get asMatrixEnjinV603(): {who: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipResetMembersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.reset_members')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Change the membership to a new set, disregarding the existing membership. Be nice and
     * pass `members` pre-sorted.
     * 
     * May only be called from `T::ResetOrigin`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalMembership.reset_members') === 'd8adca14f9b9cadeaf2b2e6dd47991d05cb423ce3a00dccbb9efa35e36f5a65a'
    }

    /**
     * Change the membership to a new set, disregarding the existing membership. Be nice and
     * pass `members` pre-sorted.
     * 
     * May only be called from `T::ResetOrigin`.
     */
    get asMatrixEnjinV603(): {members: Uint8Array[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipSetPrimeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.set_prime')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the prime member. Must be a current member.
     * 
     * May only be called from `T::PrimeOrigin`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalMembership.set_prime') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Set the prime member. Must be a current member.
     * 
     * May only be called from `T::PrimeOrigin`.
     */
    get asMatrixEnjinV603(): {who: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipSwapMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.swap_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Swap out one member `remove` for another `add`.
     * 
     * May only be called from `T::SwapOrigin`.
     * 
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('TechnicalMembership.swap_member') === '5efd724fae29eef6393e039bf2dbfd2d5a3081770cc9cc8a80a1475fd6b40cf4'
    }

    /**
     * Swap out one member `remove` for another `add`.
     * 
     * May only be called from `T::SwapOrigin`.
     * 
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get asMatrixEnjinV603(): {remove: matrixEnjinV603.MultiAddress, add: matrixEnjinV603.MultiAddress} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TimestampSetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Timestamp.set')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the current time.
     * 
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     * 
     * The timestamp should be greater than the previous one by the amount specified by
     * `MinimumPeriod`.
     * 
     * The dispatch origin for this call must be `Inherent`.
     * 
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in
     *   `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Timestamp.set') === '6a8b8ba2be107f0853b674eec0026cc440b314db44d0e2c59b36e353355aed14'
    }

    /**
     * Set the current time.
     * 
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     * 
     * The timestamp should be greater than the previous one by the amount specified by
     * `MinimumPeriod`.
     * 
     * The dispatch origin for this call must be `Inherent`.
     * 
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in
     *   `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     */
    get asMatrixEnjinV603(): {now: bigint} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryApproveProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.approve_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
     * and the original deposit will be returned.
     * 
     * May only be called from `T::ApproveOrigin`.
     * 
     * # <weight>
     * - Complexity: O(1).
     * - DbReads: `Proposals`, `Approvals`
     * - DbWrite: `Approvals`
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Treasury.approve_proposal') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     * Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
     * and the original deposit will be returned.
     * 
     * May only be called from `T::ApproveOrigin`.
     * 
     * # <weight>
     * - Complexity: O(1).
     * - DbReads: `Proposals`, `Approvals`
     * - DbWrite: `Approvals`
     * # </weight>
     */
    get asV100(): {proposalId: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryProposeSpendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.propose_spend')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Put forward a suggestion for spending. A deposit proportional to the value
     * is reserved and slashed if the proposal is rejected. It is returned once the
     * proposal is awarded.
     * 
     * # <weight>
     * - Complexity: O(1)
     * - DbReads: `ProposalCount`, `origin account`
     * - DbWrites: `ProposalCount`, `Proposals`, `origin account`
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Treasury.propose_spend') === 'ffef9f31e8ae5085e7c0a55a685daef52218f0bf7083015ac904dafceedf09ee'
    }

    /**
     * Put forward a suggestion for spending. A deposit proportional to the value
     * is reserved and slashed if the proposal is rejected. It is returned once the
     * proposal is awarded.
     * 
     * # <weight>
     * - Complexity: O(1)
     * - DbReads: `ProposalCount`, `origin account`
     * - DbWrites: `ProposalCount`, `Proposals`, `origin account`
     * # </weight>
     */
    get asV100(): {value: bigint, beneficiary: v100.MultiAddress} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryRejectProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.reject_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Reject a proposed spend. The original deposit will be slashed.
     * 
     * May only be called from `T::RejectOrigin`.
     * 
     * # <weight>
     * - Complexity: O(1)
     * - DbReads: `Proposals`, `rejected proposer account`
     * - DbWrites: `Proposals`, `rejected proposer account`
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Treasury.reject_proposal') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     * Reject a proposed spend. The original deposit will be slashed.
     * 
     * May only be called from `T::RejectOrigin`.
     * 
     * # <weight>
     * - Complexity: O(1)
     * - DbReads: `Proposals`, `rejected proposer account`
     * - DbWrites: `Proposals`, `rejected proposer account`
     * # </weight>
     */
    get asV100(): {proposalId: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryRemoveApprovalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.remove_approval')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     * The original deposit will no longer be returned.
     * 
     * May only be called from `T::RejectOrigin`.
     * - `proposal_id`: The index of a proposal
     * 
     * # <weight>
     * - Complexity: O(A) where `A` is the number of approvals
     * - Db reads and writes: `Approvals`
     * # </weight>
     * 
     * Errors:
     * - `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
     * i.e., the proposal has not been approved. This could also mean the proposal does not
     * exist altogether, thus there is no way it would have been approved in the first place.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Treasury.remove_approval') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     * The original deposit will no longer be returned.
     * 
     * May only be called from `T::RejectOrigin`.
     * - `proposal_id`: The index of a proposal
     * 
     * # <weight>
     * - Complexity: O(A) where `A` is the number of approvals
     * - Db reads and writes: `Approvals`
     * # </weight>
     * 
     * Errors:
     * - `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
     * i.e., the proposal has not been approved. This could also mean the proposal does not
     * exist altogether, thus there is no way it would have been approved in the first place.
     */
    get asV100(): {proposalId: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasurySpendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.spend')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Propose and approve a spend of treasury funds.
     * 
     * - `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     * 
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Treasury.spend') === '18a5bcfd718b2b225ac128952f0fc34fff8371520e0ab5bac3a0ab20286b496d'
    }

    /**
     * Propose and approve a spend of treasury funds.
     * 
     * - `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     * 
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     */
    get asV100(): {amount: bigint, beneficiary: v100.MultiAddress} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class UmpServiceOverweightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Ump.service_overweight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Service a single overweight upward message.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight message to service.
     * - `weight_limit`: The amount of weight that message execution may take.
     * 
     * Errors:
     * - `UnknownMessageIndex`: Message of `index` is unknown.
     * - `WeightOverLimit`: Message execution may use greater than `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Ump.service_overweight') === '80fae8875bf513efc1e06b7dac547fccfc1e5fc45888cc8afd9b43812cf51bf5'
    }

    /**
     * Service a single overweight upward message.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight message to service.
     * - `weight_limit`: The amount of weight that message execution may take.
     * 
     * Errors:
     * - `UnknownMessageIndex`: Message of `index` is unknown.
     * - `WeightOverLimit`: Message execution may use greater than `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get asV100(): {index: bigint, weightLimit: v100.Weight} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityAsDerivativeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.as_derivative')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'a6ae93fcb456424eefc936c15801ab836f49a590a3d77b87ecdb3c6024840134'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asMatrixEnjinV603(): {index: number, call: matrixEnjinV603.Call} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '487f4870b0fda45284651efd6ea18d1bcacdc401105e906a0d9e8bb4c5165898'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asMatrixEnjinV1000(): {index: number, call: matrixEnjinV1000.Call} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '96918109d90c288af1063d682c608fa1af280c82d7800a83673f69e78fadcf30'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asMatrixEnjinV1003(): {index: number, call: matrixEnjinV1003.Call} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'b6a49c0074bf4ede63d14b4d2304337c75962c455c35ea7d9217d3aaea498455'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV100(): {index: number, call: v100.Call} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '05c805cbfe5a15533e8522d29e0fb08af87b8d17a6bcbde9d72e8f354df7c8cc'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV101(): {index: number, call: v101.Call} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '292b7f2ca2fed38111c5032ee5edf6269a642bd55c597f10d03b9c9f32982417'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV102(): {index: number, call: v102.Call} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '0a782e7a917633d82edf74db2ca52f68f5cea23e19ecf79db7cfa16cfdb0d9cd'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV103(): {index: number, call: v103.Call} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'd2fe3ec86fbf09230c66a965482f39bff132c480b79e446946d931db268f5f24'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV104(): {index: number, call: v104.Call} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '86e6582a9488535bb8a7312e7dd4c5f902381af955222d0c7df25835b57a505b'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV105(): {index: number, call: v105.Call} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '6ddddf2b933f2fabda8919e75b42e5dfe4f22e208b4084da9102a71687344946'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV106(): {index: number, call: v106.Call} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '220effb500cd2e9dd28e5c589f0299bd6ee4a91fbc84f5c60ecdbde944113948'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV110(): {index: number, call: v110.Call} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '48689079a239590633149731a4e443ce6bcef276dc0e732b2ef75ff5f2f4e3e9'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV120(): {index: number, call: v120.Call} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'ba0d0a9344d1d2ce6011165e685d9f1a63cf39cd787b71ade6060f7e065607f9'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV1021(): {index: number, call: v1021.Call} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '229c58c65c339822d1b49926138de52b786e36fc677b875371d0ab13ae167928'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV1022(): {index: number, call: v1022.Call} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'ac45b18b90e3e4715d4193551141a02fb93e8b31ffcb2bde625e0e9456593f68'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV1023(): {index: number, call: v1023.Call} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityBatchCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.batch')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'eb3ad78843bf54214839c3f44256e037b4e4403e22a9563f61476f89d61b709a'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asMatrixEnjinV603(): {calls: matrixEnjinV603.Call[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Utility.batch') === '6943cec7e7f8904c41fe228dd3d064d18021f19c2eaf3bbacbf2c98a8725d94b'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asMatrixEnjinV1000(): {calls: matrixEnjinV1000.Call[]} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'a3efd343b618281196a70a4fcc7d78e60971f46d785bc24380c11d8d0f09f714'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asMatrixEnjinV1003(): {calls: matrixEnjinV1003.Call[]} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Utility.batch') === '7eff1a5e678d9cedc091d118372fd7e302d4d8a02699222ca5762160b67673db'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV100(): {calls: v100.Call[]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Utility.batch') === '167b74508848f8f29a718331dbefe39f61fad15ec5b2f901e6ac807429a8bcc4'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV101(): {calls: v101.Call[]} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Utility.batch') === '2effe7206af11eec44ff7f4a2efffe5a810d39fcaa2d5411eb11d11e3e9bf31a'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV102(): {calls: v102.Call[]} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Utility.batch') === '4f8400499efcd134687836bd22e57e0719ab1d68549a989ee4de90e56f2cb9c3'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV103(): {calls: v103.Call[]} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Utility.batch') === '5074b7ee998727da5627c275b3088fd699476b0563a7ee6c439bc3b61809495a'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV104(): {calls: v104.Call[]} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'fc9a592b664e03bac0727fff97cd8afdee81e955df6532d0e55f99011dcf0353'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV105(): {calls: v105.Call[]} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Utility.batch') === '8a73da049622ea8f4f305078aef0c260190754c254252918ac078a81403329dc'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV106(): {calls: v106.Call[]} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'eee3fce87c934ee4dd72d4b178361338ab7ff9efe59eb2ba63d4a2e24b9bc4fc'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV110(): {calls: v110.Call[]} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Utility.batch') === '4908589caa8027a87c547e064387808d48f6295c8ace0cd05751f4915e52c1f2'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV120(): {calls: v120.Call[]} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Utility.batch') === '81e9dbba8b5c69d19342289194cb2f8bd9230005af86f57995c3c0614a741dea'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV1021(): {calls: v1021.Call[]} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Utility.batch') === '91d63f8000e6b42aa80c594f83684a0fe9574ba5f7e0152075091ae8bfda09da'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV1022(): {calls: v1022.Call[]} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'afb4cb4b45c4ebbe32f93ee709d2ad633f59bc4703358ac8386bbdfaf996f16d'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV1023(): {calls: v1023.Call[]} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityBatchAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.batch_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'eb3ad78843bf54214839c3f44256e037b4e4403e22a9563f61476f89d61b709a'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asMatrixEnjinV603(): {calls: matrixEnjinV603.Call[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '6943cec7e7f8904c41fe228dd3d064d18021f19c2eaf3bbacbf2c98a8725d94b'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asMatrixEnjinV1000(): {calls: matrixEnjinV1000.Call[]} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'a3efd343b618281196a70a4fcc7d78e60971f46d785bc24380c11d8d0f09f714'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asMatrixEnjinV1003(): {calls: matrixEnjinV1003.Call[]} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '7eff1a5e678d9cedc091d118372fd7e302d4d8a02699222ca5762160b67673db'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV100(): {calls: v100.Call[]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '167b74508848f8f29a718331dbefe39f61fad15ec5b2f901e6ac807429a8bcc4'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV101(): {calls: v101.Call[]} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '2effe7206af11eec44ff7f4a2efffe5a810d39fcaa2d5411eb11d11e3e9bf31a'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV102(): {calls: v102.Call[]} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '4f8400499efcd134687836bd22e57e0719ab1d68549a989ee4de90e56f2cb9c3'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV103(): {calls: v103.Call[]} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '5074b7ee998727da5627c275b3088fd699476b0563a7ee6c439bc3b61809495a'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV104(): {calls: v104.Call[]} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'fc9a592b664e03bac0727fff97cd8afdee81e955df6532d0e55f99011dcf0353'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV105(): {calls: v105.Call[]} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '8a73da049622ea8f4f305078aef0c260190754c254252918ac078a81403329dc'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV106(): {calls: v106.Call[]} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'eee3fce87c934ee4dd72d4b178361338ab7ff9efe59eb2ba63d4a2e24b9bc4fc'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV110(): {calls: v110.Call[]} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '4908589caa8027a87c547e064387808d48f6295c8ace0cd05751f4915e52c1f2'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV120(): {calls: v120.Call[]} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '81e9dbba8b5c69d19342289194cb2f8bd9230005af86f57995c3c0614a741dea'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV1021(): {calls: v1021.Call[]} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '91d63f8000e6b42aa80c594f83684a0fe9574ba5f7e0152075091ae8bfda09da'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV1022(): {calls: v1022.Call[]} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'afb4cb4b45c4ebbe32f93ee709d2ad633f59bc4703358ac8386bbdfaf996f16d'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV1023(): {calls: v1023.Call[]} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityDispatchAsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.dispatch_as')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '53c74e412a2c7715329a8d9a5a1b15e10305868b02d52458849757df55fbd0d0'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asMatrixEnjinV603(): {asOrigin: matrixEnjinV603.OriginCaller, call: matrixEnjinV603.Call} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '7bd527143d49a84cc55caba5507dd4046a89deaf09fe49ff28f2578c919e81be'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asMatrixEnjinV1000(): {asOrigin: matrixEnjinV1000.OriginCaller, call: matrixEnjinV1000.Call} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'fae8b5d3311100f29264cf1593e7fe321d6cece7fd42232993589743245bb052'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asMatrixEnjinV1003(): {asOrigin: matrixEnjinV1003.OriginCaller, call: matrixEnjinV1003.Call} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'd2c07e22258477b06a3c3d64460ff64b2976e14af638f28d9df5e87b465492bb'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV100(): {asOrigin: v100.OriginCaller, call: v100.Call} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'f5fb8f06ce9f89da2fa5d7f358c0b275cf0a6daa5bd7aba824df54c2360d6916'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV101(): {asOrigin: v101.OriginCaller, call: v101.Call} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '519c18dc5c704fd5110b14ae3e7f1385c7050ea7de7c5881a61af8b275e06a6f'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV102(): {asOrigin: v102.OriginCaller, call: v102.Call} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '57670c33b337a9e54097fdae1b06ae1a6cbcbe56d85300c8894ae17956afa982'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV103(): {asOrigin: v103.OriginCaller, call: v103.Call} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '0de938c1569000cca0d9eb671825ecfe0ba4aafc4633edff30b0f643fff0e06a'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV104(): {asOrigin: v104.OriginCaller, call: v104.Call} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '552c0e43b905f634c4ad67dcd354071531b81f3849d0513350276a48eae900af'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV105(): {asOrigin: v105.OriginCaller, call: v105.Call} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '117b15149966b2e6ead208e1bbf09e389bb17a7a36b3bac64f621836e863fdfb'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV106(): {asOrigin: v106.OriginCaller, call: v106.Call} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'd20c6e5bd8a2a0ad961d30bd007096586ad14766f66818b98444a6318a938b6e'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV110(): {asOrigin: v110.OriginCaller, call: v110.Call} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '296c8b0f72d0232b53b15c73dcfa558a7ff8b3434e551d56586aea0a77231550'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV120(): {asOrigin: v120.OriginCaller, call: v120.Call} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '4bd4c42220a14ee4d83e4222e70cfa545ef539b326736259969dba867ba297dc'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1021(): {asOrigin: v1021.OriginCaller, call: v1021.Call} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '041cd688b1396e4628bcf4870c101d0d883bc4a7823d97baa1ee76d88b6e9f15'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1022(): {asOrigin: v1022.OriginCaller, call: v1022.Call} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '37dad2b17490bdeeb1836b3caad5ed64824648e81163150f4365b9566eab5dea'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * ## Complexity
     * - O(1).
     */
    get asV1023(): {asOrigin: v1023.OriginCaller, call: v1023.Call} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityForceBatchCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.force_batch')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'eb3ad78843bf54214839c3f44256e037b4e4403e22a9563f61476f89d61b709a'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asMatrixEnjinV603(): {calls: matrixEnjinV603.Call[]} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '6943cec7e7f8904c41fe228dd3d064d18021f19c2eaf3bbacbf2c98a8725d94b'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asMatrixEnjinV1000(): {calls: matrixEnjinV1000.Call[]} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'a3efd343b618281196a70a4fcc7d78e60971f46d785bc24380c11d8d0f09f714'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asMatrixEnjinV1003(): {calls: matrixEnjinV1003.Call[]} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '7eff1a5e678d9cedc091d118372fd7e302d4d8a02699222ca5762160b67673db'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV100(): {calls: v100.Call[]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '167b74508848f8f29a718331dbefe39f61fad15ec5b2f901e6ac807429a8bcc4'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV101(): {calls: v101.Call[]} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '2effe7206af11eec44ff7f4a2efffe5a810d39fcaa2d5411eb11d11e3e9bf31a'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV102(): {calls: v102.Call[]} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '4f8400499efcd134687836bd22e57e0719ab1d68549a989ee4de90e56f2cb9c3'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV103(): {calls: v103.Call[]} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '5074b7ee998727da5627c275b3088fd699476b0563a7ee6c439bc3b61809495a'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV104(): {calls: v104.Call[]} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'fc9a592b664e03bac0727fff97cd8afdee81e955df6532d0e55f99011dcf0353'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV105(): {calls: v105.Call[]} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '8a73da049622ea8f4f305078aef0c260190754c254252918ac078a81403329dc'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV106(): {calls: v106.Call[]} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'eee3fce87c934ee4dd72d4b178361338ab7ff9efe59eb2ba63d4a2e24b9bc4fc'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV110(): {calls: v110.Call[]} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '4908589caa8027a87c547e064387808d48f6295c8ace0cd05751f4915e52c1f2'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV120(): {calls: v120.Call[]} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '81e9dbba8b5c69d19342289194cb2f8bd9230005af86f57995c3c0614a741dea'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV1021(): {calls: v1021.Call[]} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '91d63f8000e6b42aa80c594f83684a0fe9574ba5f7e0152075091ae8bfda09da'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV1022(): {calls: v1022.Call[]} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'afb4cb4b45c4ebbe32f93ee709d2ad633f59bc4703358ac8386bbdfaf996f16d'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    get asV1023(): {calls: v1023.Call[]} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityWithWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.with_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '6b8fa0c31b033249e6762551824f0cbd1bf3f0ff2a66b52380d09a37c08d8c7e'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asMatrixEnjinV603(): {call: matrixEnjinV603.Call, weight: matrixEnjinV603.Weight} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isMatrixEnjinV1000(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '2f30217ca1d179414298d09a9d5e229de416ac54977604de88ba6b64fa10c0d7'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asMatrixEnjinV1000(): {call: matrixEnjinV1000.Call, weight: matrixEnjinV1000.Weight} {
        assert(this.isMatrixEnjinV1000)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isMatrixEnjinV1003(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '4a72a559f78e0d3adfb1681bcb1cd024d2325e9744d712bdf2fc95b8bad7caee'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asMatrixEnjinV1003(): {call: matrixEnjinV1003.Call, weight: matrixEnjinV1003.Weight} {
        assert(this.isMatrixEnjinV1003)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === 'f63d2c51b53005b2250bfd91aeb29b04e5229d45283f49f04c2c19dacbbae49f'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV100(): {call: v100.Call, weight: v100.Weight} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV101(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '709c2f9dcd69b7f7becea84e08955c3c1aa644d838b8ddeb21af6b1f5fcb7112'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV101(): {call: v101.Call, weight: v101.Weight} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV102(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '2afdd84dc329b8ece7e7a085c43373a1c04cf181641b82584da75c7b809e0378'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV102(): {call: v102.Call, weight: v102.Weight} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV103(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '4228622862b650ac972efe9daae57d9a0f8f6607c8951ccbb9603a6099c75182'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV103(): {call: v103.Call, weight: v103.Weight} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '0f5ca8098a0de6d2359055195bcf7da26f16e6290e0dba0ce6aed434d9ffd3b5'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV104(): {call: v104.Call, weight: v104.Weight} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV105(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '68b05038ca47bf9eecbc926b66a2c5d92716b6072343998c6b1c007c1e66683f'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV105(): {call: v105.Call, weight: v105.Weight} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV106(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '45dc4333de9729dca05fea2f3b761cf425ed079a6ab9846806d226be8b96c475'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV106(): {call: v106.Call, weight: v106.Weight} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV110(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === 'aaf9d7148ba3e93e5ad731ce273c531c9b89065fb41b04ccdf297900e76b7da6'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV110(): {call: v110.Call, weight: v110.Weight} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '4d3599e0b8fa0dd841470850d5f5f4ea469e0c7b81fbd9a6c309707ff047a6f3'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV120(): {call: v120.Call, weight: v120.Weight} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV1021(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === 'cbf453c1be5cc44fd79d2ade82b8ae1f4efa1b5669d5014bd4fa0ab49245f122'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV1021(): {call: v1021.Call, weight: v1021.Weight} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '57db7818a8d5e9dec1cd0013f2489b4dbd58c05e3604bf2e7cb8e45790ea4bae'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV1022(): {call: v1022.Call, weight: v1022.Weight} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV1023(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === 'f08cbe0b82a724c7f62cf81b46bc1894d8b9dba0ffcee4294ba126e16c9960e0'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV1023(): {call: v1023.Call, weight: v1023.Weight} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class ValidatorManagerDeregisterValidatorsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ValidatorManager.deregister_validators')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove validators from the set.
     * 
     * The removed validators will be deactivated from current session + 2.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ValidatorManager.deregister_validators') === '29f7c09ae365d68c20c11ff1fed7e18b97efdc9301be013378b2df5277f1557d'
    }

    /**
     * Remove validators from the set.
     * 
     * The removed validators will be deactivated from current session + 2.
     */
    get asV100(): {validators: Uint8Array[]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class ValidatorManagerRegisterValidatorsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ValidatorManager.register_validators')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add new validators to the set.
     * 
     * The new validators will be active from current session + 2.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('ValidatorManager.register_validators') === '29f7c09ae365d68c20c11ff1fed7e18b97efdc9301be013378b2df5277f1557d'
    }

    /**
     * Add new validators to the set.
     * 
     * The new validators will be active from current session + 2.
     */
    get asV100(): {validators: Uint8Array[]} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class VoteManagerRemoveOtherVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VoteManager.remove_other_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a vote for a poll.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     *   `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('VoteManager.remove_other_vote') === '852f4a0a1605e3f516a2a6871f4fb69a9ef09ca1678667ccfea4b04852621c76'
    }

    /**
     * Remove a vote for a poll.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     *   `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get asV120(): {target: v120.MultiAddress, class: number, index: number} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }
}

export class VoteManagerRemoveVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VoteManager.remove_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a vote for a poll.
     * 
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     *   - the vote of the account was in opposition to the result; or
     *   - there was no conviction to the account's vote; or
     *   - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     * 
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     * 
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     * 
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     *   which have finished or are cancelled, this must be `Some`.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('VoteManager.remove_vote') === 'be8a5ba82f77b6bda5e0784b678fdfe0fe9d28837d87406cb5d907269bb45b25'
    }

    /**
     * Remove a vote for a poll.
     * 
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     *   - the vote of the account was in opposition to the result; or
     *   - there was no conviction to the account's vote; or
     *   - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     * 
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     * 
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     * 
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     *   which have finished or are cancelled, this must be `Some`.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get asV120(): {class: (number | undefined), index: number} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }
}

export class VoteManagerUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VoteManager.unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('VoteManager.unlock') === '54d9d0de16dd3191af5be63c24957877a94689a21685cf0352d1ff067c40528e'
    }

    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get asV120(): {class: number, target: v120.MultiAddress, index: number} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }
}

export class VoteManagerVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VoteManager.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     */
    get isV120(): boolean {
        return this._chain.getCallHash('VoteManager.vote') === '66bd209021aba0eb799b4ba17e91f471b7b7a8f69f53e1ccdd2891e4bd5dea7c'
    }

    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     */
    get asV120(): {pollIndex: number, vote: v120.AccountVote, currency: v120.VoteCurrency} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }
}

export class VoterListPutInFrontOfCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VoterList.put_in_front_of')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Move the caller's Id directly in front of `lighter`.
     * 
     * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
     * the account going in front of `lighter`.
     * 
     * Only works if
     * - both nodes are within the same bag,
     * - and `origin` has a greater `Score` than `lighter`.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('VoterList.put_in_front_of') === '7e9287cfca368105d1ffcdf529d05020ce712c640b68f9f0b0e8791c224766ff'
    }

    /**
     * Move the caller's Id directly in front of `lighter`.
     * 
     * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
     * the account going in front of `lighter`.
     * 
     * Only works if
     * - both nodes are within the same bag,
     * - and `origin` has a greater `Score` than `lighter`.
     */
    get asV100(): {lighter: v100.MultiAddress} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class VoterListRebagCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VoterList.rebag')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
     * changed its score that it should properly fall into a different bag than its current
     * one.
     * 
     * Anyone can call this function about any potentially dislocated account.
     * 
     * Will always update the stored score of `dislocated` to the correct score, based on
     * `ScoreProvider`.
     * 
     * If `dislocated` does not exists, it returns an error.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('VoterList.rebag') === 'a58fcb324a2ede36cc16fb0fd8f25f392cc3d269670833be7cb969809a50d729'
    }

    /**
     * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
     * changed its score that it should properly fall into a different bag than its current
     * one.
     * 
     * Anyone can call this function about any potentially dislocated account.
     * 
     * Will always update the stored score of `dislocated` to the correct score, based on
     * `ScoreProvider`.
     * 
     * If `dislocated` does not exists, it returns an error.
     */
    get asV100(): {dislocated: v100.MultiAddress} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class WhitelistDispatchWhitelistedCallCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Whitelist.dispatch_whitelisted_call')
        this._chain = ctx._chain
        this.call = call
    }

    get isV100(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call') === '467e7b2aa84bd235d9f3a7f5ad68eb8b90858874c09d752f1eb716382fc6b96e'
    }

    get asV100(): {callHash: Uint8Array, callEncodedLen: number, callWeightWitness: v100.Weight} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class WhitelistDispatchWhitelistedCallWithPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Whitelist.dispatch_whitelisted_call_with_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    get isV100(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === '7e7ca4a51a27b75adcd5cc3fac290cea1b75ac762c8fda7f2b1677104875dfbc'
    }

    get asV100(): {call: v100.Call} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }

    get isV101(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === '54ea42f59e55ccc6a1395e61c5bdefb9b3e72e18b75663994461b7565fdea0ec'
    }

    get asV101(): {call: v101.Call} {
        assert(this.isV101)
        return this._chain.decodeCall(this.call)
    }

    get isV102(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === '0e1dd39cb361e50e1183aa4ac2baa5542de774621d2f85cc7067b6076f208958'
    }

    get asV102(): {call: v102.Call} {
        assert(this.isV102)
        return this._chain.decodeCall(this.call)
    }

    get isV103(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === 'b4af785b304541a5c22646c7efd0dba344eac099e9c0e80839b665a1e07f2e41'
    }

    get asV103(): {call: v103.Call} {
        assert(this.isV103)
        return this._chain.decodeCall(this.call)
    }

    get isV104(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === '3f59f17ab6406c8eb2c339ee5a640f47efb5b0e9c84096f26017f337bea08b60'
    }

    get asV104(): {call: v104.Call} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }

    get isV105(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === 'f6b0799f5685a02dc8c8a14b5067d055152e5c1f25dd50c18030380965b11d55'
    }

    get asV105(): {call: v105.Call} {
        assert(this.isV105)
        return this._chain.decodeCall(this.call)
    }

    get isV106(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === 'd435f1baa5f2dbfdda145f5adff46e9448bd416dc9f062fa1e12dc0c8a02c924'
    }

    get asV106(): {call: v106.Call} {
        assert(this.isV106)
        return this._chain.decodeCall(this.call)
    }

    get isV110(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === 'ebf55311d7e853f8586deeaa0b6e540ab2013c7561a373e6e7955f78ab73deb1'
    }

    get asV110(): {call: v110.Call} {
        assert(this.isV110)
        return this._chain.decodeCall(this.call)
    }

    get isV120(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === '56edfc3de7c89b3ed1d8cfc5400e6a3c37eeb47533810cb7a0e23e62d833f460'
    }

    get asV120(): {call: v120.Call} {
        assert(this.isV120)
        return this._chain.decodeCall(this.call)
    }

    get isV1021(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === 'fc358269cdcf12faf350eb6eda7e7c3d0c61c61285d54b10b6e5ab88abb9089d'
    }

    get asV1021(): {call: v1021.Call} {
        assert(this.isV1021)
        return this._chain.decodeCall(this.call)
    }

    get isV1022(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === 'e2166d7b602d573395d001e91fdae8f710fd9d126d5864b18e7ce0f1dba5f09b'
    }

    get asV1022(): {call: v1022.Call} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    get isV1023(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === '95bdab3bb6548e000ba2cf1fa20d486cbb856d04cc91966145545f76c479dada'
    }

    get asV1023(): {call: v1023.Call} {
        assert(this.isV1023)
        return this._chain.decodeCall(this.call)
    }
}

export class WhitelistRemoveWhitelistedCallCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Whitelist.remove_whitelisted_call')
        this._chain = ctx._chain
        this.call = call
    }

    get isV100(): boolean {
        return this._chain.getCallHash('Whitelist.remove_whitelisted_call') === 'b44e90452a13e65d907b0cefbea166547546a12683e4c0df57032f38a10e78b3'
    }

    get asV100(): {callHash: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class WhitelistWhitelistCallCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Whitelist.whitelist_call')
        this._chain = ctx._chain
        this.call = call
    }

    get isV100(): boolean {
        return this._chain.getCallHash('Whitelist.whitelist_call') === 'b44e90452a13e65d907b0cefbea166547546a12683e4c0df57032f38a10e78b3'
    }

    get asV100(): {callHash: Uint8Array} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === '26df7f19916781e6746694066c0d24f7fef9a20367132a192147dc6c414af64c'
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asMatrixEnjinV603(): {currencyId: matrixEnjinV603.AssetId, amount: bigint, dest: matrixEnjinV603.VersionedMultiLocation, destWeightLimit: matrixEnjinV603.V3WeightLimit} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferMultiassetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer_multiasset')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset') === 'a87b2931a2da31f4548173df0d164afbd7f9413f0b0a9373582011906fdc8ac9'
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asMatrixEnjinV603(): {asset: matrixEnjinV603.VersionedMultiAsset, dest: matrixEnjinV603.VersionedMultiLocation, destWeightLimit: matrixEnjinV603.V3WeightLimit} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferMultiassetWithFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer_multiasset_with_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer `MultiAsset` specifying the fee and amount as separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the multiasset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `MultiLocation` id.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset_with_fee') === 'e1673c048436ca84c1278f4f2f8a12456b25e4911f3ec72d0295b843ed7a4c7f'
    }

    /**
     * Transfer `MultiAsset` specifying the fee and amount as separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the multiasset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `MultiLocation` id.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asMatrixEnjinV603(): {asset: matrixEnjinV603.VersionedMultiAsset, fee: matrixEnjinV603.VersionedMultiAsset, dest: matrixEnjinV603.VersionedMultiLocation, destWeightLimit: matrixEnjinV603.V3WeightLimit} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferMultiassetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer_multiassets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer several `MultiAsset` specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the MultiAssets that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiassets') === 'b49a1a3bce05ffe02f0ac5efca4907e6bf7f963113419870a760a3013dc86495'
    }

    /**
     * Transfer several `MultiAsset` specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the MultiAssets that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asMatrixEnjinV603(): {assets: matrixEnjinV603.VersionedMultiAssets, feeItem: number, dest: matrixEnjinV603.VersionedMultiLocation, destWeightLimit: matrixEnjinV603.V3WeightLimit} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferMulticurrenciesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer_multicurrencies')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multicurrencies') === 'fa576588d6b62b5cf4c7bdd8bee764e1be7fc0c2fbe730e805ffd89ad1a3b1e6'
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asMatrixEnjinV603(): {currencies: [matrixEnjinV603.AssetId, bigint][], feeItem: number, dest: matrixEnjinV603.VersionedMultiLocation, destWeightLimit: matrixEnjinV603.V3WeightLimit} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferWithFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer_with_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XTokens.transfer_with_fee') === 'c05a522029f57db9f9e4ceeff8427cc674dd992c069c7798b3625e3d55e588cb'
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asMatrixEnjinV603(): {currencyId: matrixEnjinV603.AssetId, amount: bigint, fee: bigint, dest: matrixEnjinV603.VersionedMultiLocation, destWeightLimit: matrixEnjinV603.V3WeightLimit} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletExecuteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.execute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('XcmPallet.execute') === 'a1da862b5d9db8fd6f3072da00ea4e66052f97b5dcfb87e58d49ca1fd1f1ef90'
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get asV100(): {message: v100.Type_435, maxWeight: v100.Weight} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletForceDefaultXcmVersionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.force_default_xcm_version')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     * 
     * - `origin`: Must be Root.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('XcmPallet.force_default_xcm_version') === 'd4bcd64cc4c940eafd14296ec6cbfb7d27e4ca42a4c7dab4c0b89f6c8102257e'
    }

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     * 
     * - `origin`: Must be Root.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     */
    get asV100(): {maybeXcmVersion: (number | undefined)} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletForceSubscribeVersionNotifyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.force_subscribe_version_notify')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('XcmPallet.force_subscribe_version_notify') === '0448b7eed1a6d9cd0a489ea792df94cc3ce5a37e203f19b1a5a0c4516a8d696c'
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get asV100(): {location: v100.VersionedMultiLocation} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletForceSuspensionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.force_suspension')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set or unset the global suspension state of the XCM executor.
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     */
    get isV104(): boolean {
        return this._chain.getCallHash('XcmPallet.force_suspension') === '8ed7e51efeeeccee1e0e2e2dca71da38a9e5bdab470452a56d790711652babc1'
    }

    /**
     * Set or unset the global suspension state of the XCM executor.
     * 
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     */
    get asV104(): {suspended: boolean} {
        assert(this.isV104)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletForceUnsubscribeVersionNotifyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.force_unsubscribe_version_notify')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('XcmPallet.force_unsubscribe_version_notify') === '0448b7eed1a6d9cd0a489ea792df94cc3ce5a37e203f19b1a5a0c4516a8d696c'
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get asV100(): {location: v100.VersionedMultiLocation} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletForceXcmVersionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.force_xcm_version')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('XcmPallet.force_xcm_version') === '998b5a56e7662d76955b41c2526c2219fe8304fec6501afa115db1bd705e7ff6'
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get asV100(): {location: v100.V3MultiLocation, xcmVersion: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletLimitedReserveTransferAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.limited_reserve_transfer_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('XcmPallet.limited_reserve_transfer_assets') === 'c5f45c1775bd92c7b425f46c92a6891334f7df5ae2518cd2c0a106447da3bbd9'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV100(): {dest: v100.VersionedMultiLocation, beneficiary: v100.VersionedMultiLocation, assets: v100.VersionedMultiAssets, feeAssetItem: number, weightLimit: v100.V3WeightLimit} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletLimitedTeleportAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.limited_teleport_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('XcmPallet.limited_teleport_assets') === 'c5f45c1775bd92c7b425f46c92a6891334f7df5ae2518cd2c0a106447da3bbd9'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV100(): {dest: v100.VersionedMultiLocation, beneficiary: v100.VersionedMultiLocation, assets: v100.VersionedMultiAssets, feeAssetItem: number, weightLimit: v100.V3WeightLimit} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletReserveTransferAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.reserve_transfer_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('XcmPallet.reserve_transfer_assets') === 'ebd99cece75c1b0fc48830527bc513cf672b8d0c6c0c505498bba5c8c5e1617c'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asV100(): {dest: v100.VersionedMultiLocation, beneficiary: v100.VersionedMultiLocation, assets: v100.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletSendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.send')
        this._chain = ctx._chain
        this.call = call
    }

    get isV100(): boolean {
        return this._chain.getCallHash('XcmPallet.send') === '9c814457e6c06e355f17d8e2e59924a734ef38dfc7852490ba89fd5b845b6f48'
    }

    get asV100(): {dest: v100.VersionedMultiLocation, message: v100.VersionedXcm} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletTeleportAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.teleport_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isV100(): boolean {
        return this._chain.getCallHash('XcmPallet.teleport_assets') === 'ebd99cece75c1b0fc48830527bc513cf672b8d0c6c0c505498bba5c8c5e1617c'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asV100(): {dest: v100.VersionedMultiLocation, beneficiary: v100.VersionedMultiLocation, assets: v100.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV100)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueResumeXcmExecutionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.resume_xcm_execution')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Resumes all XCM executions for the XCMP queue.
     * 
     * Note that this function doesn't change the status of the in/out bound channels.
     * 
     * - `origin`: Must pass `ControllerOrigin`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XcmpQueue.resume_xcm_execution') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Resumes all XCM executions for the XCMP queue.
     * 
     * Note that this function doesn't change the status of the in/out bound channels.
     * 
     * - `origin`: Must pass `ControllerOrigin`.
     */
    get asMatrixEnjinV603(): null {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueServiceOverweightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.service_overweight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Services a single overweight XCM.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight XCM to service
     * - `weight_limit`: The amount of weight that XCM execution may take.
     * 
     * Errors:
     * - `BadOverweightIndex`: XCM under `index` is not found in the `Overweight` storage map.
     * - `BadXcm`: XCM under `index` cannot be properly decoded into a valid XCM format.
     * - `WeightOverLimit`: XCM execution may use greater `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XcmpQueue.service_overweight') === '80fae8875bf513efc1e06b7dac547fccfc1e5fc45888cc8afd9b43812cf51bf5'
    }

    /**
     * Services a single overweight XCM.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight XCM to service
     * - `weight_limit`: The amount of weight that XCM execution may take.
     * 
     * Errors:
     * - `BadOverweightIndex`: XCM under `index` is not found in the `Overweight` storage map.
     * - `BadXcm`: XCM under `index` cannot be properly decoded into a valid XCM format.
     * - `WeightOverLimit`: XCM execution may use greater `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get asMatrixEnjinV603(): {index: bigint, weightLimit: matrixEnjinV603.Weight} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueSuspendXcmExecutionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.suspend_xcm_execution')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.
     * 
     * - `origin`: Must pass `ControllerOrigin`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XcmpQueue.suspend_xcm_execution') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.
     * 
     * - `origin`: Must pass `ControllerOrigin`.
     */
    get asMatrixEnjinV603(): null {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateDropThresholdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_drop_threshold')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrites the number of pages of messages which must be in the queue after which we drop any further
     * messages from the channel.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.drop_threshold`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_drop_threshold') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Overwrites the number of pages of messages which must be in the queue after which we drop any further
     * messages from the channel.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.drop_threshold`
     */
    get asMatrixEnjinV603(): {new: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateResumeThresholdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_resume_threshold')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrites the number of pages of messages which the queue must be reduced to before it signals that
     * message sending may recommence after it has been suspended.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.resume_threshold`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_resume_threshold') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Overwrites the number of pages of messages which the queue must be reduced to before it signals that
     * message sending may recommence after it has been suspended.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.resume_threshold`
     */
    get asMatrixEnjinV603(): {new: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateSuspendThresholdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_suspend_threshold')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrites the number of pages of messages which must be in the queue for the other side to be told to
     * suspend their sending.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.suspend_value`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_suspend_threshold') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Overwrites the number of pages of messages which must be in the queue for the other side to be told to
     * suspend their sending.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.suspend_value`
     */
    get asMatrixEnjinV603(): {new: number} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateThresholdWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_threshold_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrites the amount of remaining weight under which we stop processing messages.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.threshold_weight`
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_threshold_weight') === '75eef6f2cd3523e44f50db837d1610f4db03539037986ac2704c4a043d58ba81'
    }

    /**
     * Overwrites the amount of remaining weight under which we stop processing messages.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.threshold_weight`
     */
    get asMatrixEnjinV603(): {new: matrixEnjinV603.Weight} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateWeightRestrictDecayCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_weight_restrict_decay')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrites the speed to which the available weight approaches the maximum weight.
     * A lower number results in a faster progression. A value of 1 makes the entire weight available initially.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.weight_restrict_decay`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_weight_restrict_decay') === '75eef6f2cd3523e44f50db837d1610f4db03539037986ac2704c4a043d58ba81'
    }

    /**
     * Overwrites the speed to which the available weight approaches the maximum weight.
     * A lower number results in a faster progression. A value of 1 makes the entire weight available initially.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.weight_restrict_decay`.
     */
    get asMatrixEnjinV603(): {new: matrixEnjinV603.Weight} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateXcmpMaxIndividualWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_xcmp_max_individual_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrite the maximum amount of weight any individual message may consume.
     * Messages above this weight go into the overweight queue and may only be serviced explicitly.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.xcmp_max_individual_weight`.
     */
    get isMatrixEnjinV603(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_xcmp_max_individual_weight') === '75eef6f2cd3523e44f50db837d1610f4db03539037986ac2704c4a043d58ba81'
    }

    /**
     * Overwrite the maximum amount of weight any individual message may consume.
     * Messages above this weight go into the overweight queue and may only be serviced explicitly.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.xcmp_max_individual_weight`.
     */
    get asMatrixEnjinV603(): {new: matrixEnjinV603.Weight} {
        assert(this.isMatrixEnjinV603)
        return this._chain.decodeCall(this.call)
    }
}
